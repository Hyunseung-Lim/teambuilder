import { NextRequest, NextResponse } from "next/server";
import {
  getTeamById,
  getAgentById,
  getIdeas,
  getChatHistory,
  addIdea,
  addChatMessage,
  getAgentMemory,
} from "@/lib/redis";
import { redis } from "@/lib/redis";
import {
  planNextAction,
  generateIdeaAction,
  preEvaluationAction,
  executeEvaluationAction,
  giveFeedbackOnIdea,
  makeRequestAction,
  alreadyEvaluatedResponseAction,
  planFeedbackStrategy,
} from "@/lib/openai";
import { processMemoryUpdate } from "@/lib/memory";
import {
  AgentStateInfo,
  getAgentState,
  setAgentState,
  isFeedbackSessionActive,
  validateTimer,
  createNewIdleTimer,
} from "@/lib/agent-state-utils";

// 에이전트 상태 업데이트 (시간 경과 반영)
async function updateAgentStateTimer(
  teamId: string,
  state: AgentStateInfo
): Promise<AgentStateInfo> {
  const now = new Date();

  // 피드백 세션 중인 에이전트는 자동 상태 전환하지 않음
  if (isFeedbackSessionActive(state)) {
    console.log(`🔒 ${state.agentId} 피드백 세션 중 - 자동 상태 전환 차단`);
    return state;
  }

  if (state.currentState === "idle" && state.idleTimer) {
    // 타이머 안정성 검사
    if (!validateTimer(state)) {
      console.warn(`⚠️ ${state.agentId} 비정상적인 타이머 상태 감지, 초기화`);
      state.idleTimer = createNewIdleTimer();
      return state;
    }

    // idle 타이머 업데이트
    const startTime = new Date(state.idleTimer.startTime).getTime();
    const elapsed = Math.floor((now.getTime() - startTime) / 1000);
    const newRemainingTime = Math.max(
      0,
      state.idleTimer.plannedDuration - elapsed
    );

    state.idleTimer.remainingTime = newRemainingTime;

    // 타이머가 끝나면 planning 실행 (비동기로 처리)
    if (newRemainingTime <= 0) {
      console.log(`🧠 ${state.agentId} planning 시작 (비동기 처리)`);

      // planning 상태로 즉시 전환 (AI 작업은 백그라운드에서 진행)
      state.currentState = "plan";
      state.lastStateChange = now.toISOString();
      state.isProcessing = true;
      state.currentTask = {
        type: "planning",
        description: "다음 행동 계획 수립 중...",
        startTime: now.toISOString(),
        estimatedDuration: 15,
        trigger: "autonomous",
      };
      delete state.idleTimer;

      // AI planning 작업을 백그라운드에서 비동기 실행
      setTimeout(async () => {
        try {
          const team = await getTeamById(teamId);
          const agentProfile = await getAgentById(state.agentId);
          const ideas = await getIdeas(teamId);
          const recentMessages = await getChatHistory(teamId, 5);

          const agents = await Promise.all(
            (team?.members || [])
              .filter((m) => !m.isUser && m.agentId)
              .map((m) => getAgentById(m.agentId!))
          );

          // 팀 멤버 정보에서 해당 에이전트의 역할 가져오기
          const teamMember = team?.members.find(
            (m) => m.agentId === state.agentId
          );
          const agentProfileWithRoles = agentProfile
            ? {
                ...agentProfile,
                roles: teamMember?.roles || [], // 팀 멤버의 역할 정보 추가
              }
            : null;

          if (!agentProfileWithRoles) {
            console.error(`❌ ${state.agentId} 에이전트 프로필을 찾을 수 없음`);
            return;
          }

          console.log(
            `🔍 ${agentProfileWithRoles.name}의 팀 멤버 역할:`,
            teamMember?.roles
          );

          // 계획 수립
          const planResult = await planNextAction(agentProfileWithRoles, {
            teamName: team?.teamName || "Unknown Team",
            topic: team?.topic || "Carbon Emission Reduction",
            currentIdeasCount: ideas.length,
            recentMessages: recentMessages,
            teamMembers: (team?.members || [])
              .filter((m) => !m.isUser)
              .map((m) => {
                const agent = agents
                  .filter(Boolean)
                  .find((a) => a?.id === m.agentId);
                return agent?.name || `에이전트 ${m.agentId}`;
              }),
            existingIdeas: ideas.map((idea, index) => ({
              ideaNumber: index + 1,
              authorName:
                idea.author === "나"
                  ? "나"
                  : (() => {
                      const member = team?.members.find(
                        (tm) => tm.agentId === idea.author
                      );
                      if (member && !member.isUser) {
                        const agent = agents
                          .filter(Boolean)
                          .find((a) => a?.id === idea.author);
                        return agent?.name || `에이전트 ${idea.author}`;
                      }
                      return idea.author;
                    })(),
              object: idea.content.object,
              function: idea.content.function,
            })),
          });

          // planning 완료 후 상태 업데이트
          const currentState = await getAgentState(teamId, state.agentId);
          if (currentState && currentState.currentState === "plan") {
            currentState.plannedAction = planResult;
            currentState.currentTask = {
              type: "planning",
              description: `다음 행동 계획: ${planResult.action}`,
              startTime: now.toISOString(),
              estimatedDuration: 15,
              trigger: "autonomous",
            };
            await setAgentState(teamId, state.agentId, currentState);
            console.log(`📋 ${state.agentId} 계획 완료:`, planResult.action);

            // 계획 완료 후 3초 뒤에 실행
            setTimeout(async () => {
              try {
                await executeAgentAction(teamId, state.agentId, planResult);
              } catch (error) {
                console.error(`❌ ${state.agentId} 액션 실행 실패:`, error);
                // 실패 시 idle 상태로 복귀 (피드백 세션 중이 아닌 경우만)
                const failedState = await getAgentState(teamId, state.agentId);
                if (failedState) {
                  // 🔒 피드백 세션 중인지 확인
                  if (isFeedbackSessionActive(failedState)) {
                    console.log(
                      `🔒 ${state.agentId} 액션 실행 실패했지만 피드백 세션 중이므로 idle 전환 스킵`
                    );
                    return;
                  }

                  failedState.currentState = "idle";
                  failedState.lastStateChange = new Date().toISOString();
                  failedState.isProcessing = false;
                  failedState.idleTimer = createNewIdleTimer();
                  delete failedState.currentTask;
                  delete failedState.plannedAction;
                  await setAgentState(teamId, state.agentId, failedState);
                }
              }
            }, 3000);
          }
        } catch (error) {
          console.error(`❌ ${state.agentId} planning 실패:`, error);
          // planning 실패 시 idle 상태로 복귀
          const failedState = await getAgentState(teamId, state.agentId);
          if (failedState) {
            failedState.currentState = "idle";
            failedState.lastStateChange = new Date().toISOString();
            failedState.isProcessing = false;
            failedState.idleTimer = createNewIdleTimer();
            delete failedState.currentTask;
            delete failedState.plannedAction;
            await setAgentState(teamId, state.agentId, failedState);
          }
        }
      }, 0); // 즉시 비동기 실행

      return state; // planning 상태로 즉시 반환
    }
  } else if (state.currentTask) {
    // 현재 작업이 있는 경우 시간 업데이트
    const taskStartTime = new Date(state.currentTask.startTime).getTime();
    const elapsed = Math.floor((now.getTime() - taskStartTime) / 1000);

    // 작업 시간이 비정상적으로 긴 경우 (10분 이상) 강제 종료
    // 🔒 단, 피드백 세션 중인 경우는 예외 처리
    if (elapsed > 600) {
      if (isFeedbackSessionActive(state)) {
        console.log(
          `🔒 ${state.agentId} 작업 시간 초과이지만 피드백 세션 중이므로 강제 종료 차단`
        );
        // 피드백 세션의 경우 더 긴 시간 허용 (30분)
        if (elapsed > 1800) {
          console.warn(
            `⚠️ ${state.agentId} 피드백 세션이 30분을 초과하여 강제 idle 전환`
          );
          state.currentState = "idle";
          state.lastStateChange = now.toISOString();
          state.isProcessing = false;
          state.idleTimer = createNewIdleTimer();
          delete state.currentTask;
          delete state.plannedAction;
        }
      } else {
        console.warn(`⚠️ ${state.agentId} 작업 시간 초과, 강제 idle 전환`);
        state.currentState = "idle";
        state.lastStateChange = now.toISOString();
        state.isProcessing = false;
        state.idleTimer = createNewIdleTimer();
        delete state.currentTask;
        delete state.plannedAction;
      }
    }
  }

  return state;
}

// 실제 에이전트 작업 실행 함수
async function executeAgentAction(
  teamId: string,
  agentId: string,
  plannedAction: {
    action:
      | "generate_idea"
      | "evaluate_idea"
      | "give_feedback"
      | "make_request"
      | "wait";
    reasoning: string;
    target?: string;
  }
) {
  try {
    const team = await getTeamById(teamId);
    const agentProfile = await getAgentById(agentId);

    if (!team || !agentProfile) {
      console.error(`❌ ${agentId} 팀 또는 에이전트 정보 없음`);
      return;
    }

    console.log(
      `🎯 ${agentProfile.name} 자율 행동 실행: ${plannedAction.action}`
    );

    if (plannedAction.action === "generate_idea") {
      // 아이디어 생성
      const ideas = await getIdeas(teamId);
      const existingIdeas = ideas.map((idea, index) => ({
        ideaNumber: index + 1,
        authorName: idea.author,
        object: idea.content.object,
        function: idea.content.function,
      }));

      // 에이전트 메모리 가져오기
      const { getAgentMemory } = await import("@/lib/redis");
      const agentMemory = await getAgentMemory(agentId);

      const generatedContent = await generateIdeaAction(
        team.topic || "Carbon Emission Reduction",
        agentProfile,
        existingIdeas,
        agentMemory || undefined
      );

      const newIdea = await addIdea(teamId, {
        author: agentId,
        timestamp: new Date().toISOString(),
        content: {
          object: generatedContent.object || "생성된 아이디어",
          function: generatedContent.function || "기능 설명",
          behavior:
            typeof generatedContent.behavior === "object"
              ? JSON.stringify(generatedContent.behavior)
              : generatedContent.behavior || "동작 설명",
          structure:
            typeof generatedContent.structure === "object"
              ? JSON.stringify(generatedContent.structure)
              : generatedContent.structure || "구조 설명",
        },
        evaluations: [],
      });

      // 채팅 알림 (자율적 행동)
      await addChatMessage(teamId, {
        sender: agentId,
        type: "system",
        payload: {
          content: `새로운 아이디어를 생성했습니다.`,
        },
      });

      // 메모리 업데이트 - 자율적 아이디어 생성
      try {
        await processMemoryUpdate({
          type: "IDEA_GENERATED",
          payload: {
            teamId,
            authorId: agentId,
            idea: newIdea,
            isAutonomous: true, // 자율적 생성
          },
        });
        console.log(
          `✅ 자율적 아이디어 생성 후 메모리 업데이트 성공: ${agentId} -> idea ${newIdea.id}`
        );
      } catch (memoryError) {
        console.error(
          "❌ 자율적 아이디어 생성 후 메모리 업데이트 실패:",
          memoryError
        );
      }

      console.log(
        `✅ ${agentProfile.name} 아이디어 생성 완료:`,
        generatedContent.object
      );
    }

    if (plannedAction.action === "evaluate_idea") {
      // 아이디어 평가 - 2단계 프롬프트 사용
      const team = await getTeamById(teamId);
      const agentProfile = await getAgentById(agentId);

      if (!team || !agentProfile) {
        console.error(`❌ ${agentId} 팀 또는 에이전트 정보 없음`);
        return;
      }

      const ideas = await getIdeas(teamId);

      if (ideas.length === 0) {
        console.log(`⚠️ ${agentProfile.name} 평가할 아이디어가 없음`);
        return;
      }

      // 본인이 만든 아이디어 제외
      const otherIdeas = ideas.filter((idea) => idea.author !== agentId);

      if (otherIdeas.length === 0) {
        console.log(
          `⚠️ 에이전트 ${agentId} 평가할 다른 사람의 아이디어가 없음`
        );
        return;
      }

      // 🔍 이미 평가한 아이디어 제외
      const unevaluatedIdeas = otherIdeas.filter((idea) => {
        const hasAlreadyEvaluated = idea.evaluations.some(
          (evaluation) => evaluation.evaluator === agentId
        );
        return !hasAlreadyEvaluated;
      });

      if (unevaluatedIdeas.length === 0) {
        console.log(
          `⚠️ 에이전트 ${agentId} 평가할 새로운 아이디어가 없음 (모두 평가 완료)`
        );
        return;
      }

      // 🎯 실제 아이디어 평가 수행
      await setAgentState(teamId, agentId, {
        agentId,
        currentState: "action",
        lastStateChange: new Date().toISOString(),
        isProcessing: true,
        currentTask: {
          type: "evaluate_idea",
          description: `요청받은 아이디어 평가`,
          startTime: new Date().toISOString(),
          estimatedDuration: 300,
        },
      });

      // 아이디어 평가 수행
      const { evaluateIdeaAction } = await import("@/lib/openai");
      const randomIdea =
        unevaluatedIdeas[Math.floor(Math.random() * unevaluatedIdeas.length)];

      console.log(
        `📊 ${agentProfile.name} → ${randomIdea.content.object} 평가 시작`
      );

      try {
        const evaluation = await evaluateIdeaAction(
          randomIdea,
          agentProfile.name
        );

        // 평가 저장
        const response = await fetch(
          `${
            process.env.NEXTAUTH_URL || "http://localhost:3000"
          }/api/teams/${teamId}/ideas/${randomIdea.id}/evaluate`,
          {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              "User-Agent": "TeamBuilder-Internal",
            },
            body: JSON.stringify({
              evaluator: agentId,
              scores: {
                insightful: evaluation.insightful,
                actionable: evaluation.actionable,
                relevance: evaluation.relevance,
              },
              comment: evaluation.comment,
            }),
          }
        );

        if (response.ok) {
          console.log(`✅ ${agentProfile.name} 아이디어 평가 완료`);

          // 평가 완료 메시지
          await addChatMessage(teamId, {
            sender: agentId,
            type: "system",
            payload: {
              content: `요청받은 아이디어를 평가했습니다.`,
            },
          });
        } else {
          console.error(
            `❌ ${agentProfile.name} 평가 저장 실패:`,
            response.status
          );
        }
      } catch (evaluationError) {
        console.error(
          `❌ ${agentProfile.name} 평가 수행 실패:`,
          evaluationError
        );
      }

      console.log(`✅ 에이전트 ${agentId} 아이디어 평가 요청 처리 완료`);
    }

    if (plannedAction.action === "give_feedback") {
      // 피드백 제공 - 피드백 세션으로 진행
      console.log(`💬 ${agentProfile.name} 피드백 세션 시작 로직`);

      const ideas = await getIdeas(teamId);

      if (ideas.length === 0) {
        console.log(`⚠️ ${agentProfile.name} 피드백할 아이디어가 없음`);
        return;
      }

      // 본인이 만든 아이디어 제외
      const otherIdeas = ideas.filter((idea) => idea.author !== agentId);

      if (otherIdeas.length === 0) {
        console.log(
          `⚠️ ${agentProfile.name} 피드백할 다른 사람의 아이디어가 없음`
        );
        return;
      }

      // 팀의 모든 에이전트 정보 가져오기
      const agents = await Promise.all(
        (team?.members || [])
          .filter((m) => !m.isUser && m.agentId)
          .map((m) => getAgentById(m.agentId!))
      );
      const validAgents = agents.filter((agent) => agent !== null);

      // 피드백 가능한 다른 팀원들 찾기 (본인 제외)
      const otherMembers = team.members.filter(
        (member) => !member.isUser && member.agentId !== agentId
      );

      if (otherMembers.length === 0) {
        console.log(`⚠️ ${agentProfile.name} 피드백할 다른 팀원이 없음`);
        return;
      }

      // 랜덤하게 피드백 대상 선택
      const targetMember =
        otherMembers[Math.floor(Math.random() * otherMembers.length)];
      const targetAgent = validAgents.find(
        (a: any) => a.id === targetMember.agentId
      );

      if (!targetAgent) {
        console.log(`⚠️ ${agentProfile.name} 대상 에이전트를 찾을 수 없음`);
        return;
      }

      console.log(
        `🎯 ${agentProfile.name} → ${targetAgent.name} 피드백 세션 생성`
      );

      // 락 키 생성 (작은 ID가 먼저 오도록 정렬)
      const lockKey = `feedback_lock:${[agentId, targetAgent.id]
        .sort()
        .join(":")}`;

      // 분산 락 사용
      const lockAcquired = await redis.set(lockKey, "locked", {
        ex: 30, // 30초 TTL
        nx: true, // 키가 존재하지 않을 때만 설정
      });

      if (!lockAcquired) {
        console.log(
          `⚠️ ${agentProfile.name} → ${targetAgent.name} 피드백 세션 락 획득 실패 (이미 진행 중)`
        );
        return;
      }

      try {
        // 피드백 세션 생성 API 호출
        const baseUrl = process.env.NEXTAUTH_URL || `http://localhost:3000`;
        const sessionResponse = await fetch(
          `${baseUrl}/api/teams/${teamId}/feedback-sessions`,
          {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              "User-Agent": "TeamBuilder-Internal",
            },
            body: JSON.stringify({
              action: "create",
              initiatorId: agentId,
              targetAgentId: targetAgent.id,
              message: `${agentProfile.name}이 피드백을 제공하고 싶어합니다.`,
              feedbackContext: {
                type: "general_feedback",
                initiatedBy: "ai",
                description: "일반적인 협업과 팀워크에 대한 피드백",
              },
            }),
          }
        );

        if (sessionResponse.ok) {
          const sessionData = await sessionResponse.json();
          console.log(
            `✅ ${agentProfile.name} → ${targetAgent.name} 피드백 세션 생성 성공: ${sessionData.sessionId}`
          );

          // 🔄 피드백 세션 생성 즉시 양쪽 에이전트 상태 변경
          // 1. 피드백 제공자(현재 에이전트) 상태 변경
          try {
            const initiatorResponse = await fetch(
              `${baseUrl}/api/teams/${teamId}/agent-states`,
              {
                method: "POST",
                headers: {
                  "Content-Type": "application/json",
                  "User-Agent": "TeamBuilder-Internal",
                },
                body: JSON.stringify({
                  agentId: agentId,
                  currentState: "feedback_session",
                  taskType: "feedback_session",
                  taskDescription: `${targetAgent.name}와 피드백 세션 진행 중`,
                  estimatedDuration: 300,
                  trigger: "autonomous",
                  sessionInfo: {
                    sessionId: sessionData.sessionId,
                    participants: [agentProfile.name, targetAgent.name],
                  },
                }),
              }
            );

            if (initiatorResponse.ok) {
              console.log(
                `✅ ${agentProfile.name} 상태가 feedback_session으로 변경됨`
              );
            } else {
              console.error(
                `❌ ${agentProfile.name} feedback_session 상태 변경 실패:`,
                initiatorResponse.status
              );
            }
          } catch (error) {
            console.error(
              `❌ ${agentProfile.name} feedback_session 상태 변경 오류:`,
              error
            );
          }

          // 2. 피드백 대상자(타겟 에이전트) 상태 변경 (인간이 아닌 경우만)
          if (targetAgent.name !== "나") {
            try {
              const targetResponse = await fetch(
                `${baseUrl}/api/teams/${teamId}/agent-states`,
                {
                  method: "POST",
                  headers: {
                    "Content-Type": "application/json",
                    "User-Agent": "TeamBuilder-Internal",
                  },
                  body: JSON.stringify({
                    agentId: targetAgent.id,
                    currentState: "feedback_session",
                    taskType: "feedback_session",
                    taskDescription: `${agentProfile.name}와 피드백 세션 진행 중`,
                    estimatedDuration: 300,
                    trigger: "autonomous",
                    sessionInfo: {
                      sessionId: sessionData.sessionId,
                      participants: [agentProfile.name, targetAgent.name],
                    },
                  }),
                }
              );

              if (targetResponse.ok) {
                console.log(
                  `✅ ${targetAgent.name} 상태가 feedback_session으로 변경됨`
                );
              } else {
                console.error(
                  `❌ ${targetAgent.name} feedback_session 상태 변경 실패:`,
                  targetResponse.status
                );
              }
            } catch (error) {
              console.error(
                `❌ ${targetAgent.name} feedback_session 상태 변경 오류:`,
                error
              );
            }
          }

          // 인간에게 피드백하는 경우 즉시 첫 메시지 생성
          const isTargetHuman = targetAgent.name === "나";
          const delay = isTargetHuman ? 1000 : 3000; // 인간에게는 1초 후, AI에게는 3초 후

          setTimeout(async () => {
            try {
              const aiProcessResponse = await fetch(
                `${baseUrl}/api/teams/${teamId}/feedback-sessions/${sessionData.sessionId}/ai-process`,
                {
                  method: "POST",
                  headers: {
                    "Content-Type": "application/json",
                    "User-Agent": "TeamBuilder-Internal",
                  },
                  body: JSON.stringify({
                    triggerAgentId: agentId,
                    action: "respond",
                  }),
                }
              );

              if (aiProcessResponse.ok) {
                console.log(
                  `✅ ${agentProfile.name} 첫 피드백 메시지 생성 트리거 성공 (대상: ${targetAgent.name})`
                );
              } else {
                console.error(
                  `❌ ${agentProfile.name} 첫 피드백 메시지 생성 트리거 실패:`,
                  aiProcessResponse.status
                );
              }
            } catch (error) {
              console.error(
                `❌ ${agentProfile.name} 첫 피드백 메시지 생성 트리거 오류:`,
                error
              );
            }
          }, delay);
        } else {
          const errorData = await sessionResponse.json();
          console.error(
            `❌ ${agentProfile.name} → ${targetAgent.name} 피드백 세션 생성 실패:`,
            errorData
          );
        }
      } finally {
        // 락 해제
        await redis.del(lockKey);
        console.log(`🔓 ${agentProfile.name} → ${targetAgent.name} 락 해제`);
      }
    }

    if (plannedAction.action === "wait") {
      // 대기 액션 - 바로 idle 상태로 전환
      console.log(`😴 ${agentProfile.name} 대기 액션 선택 - idle 상태로 전환`);

      // 2초 후 idle 상태로 전환
      setTimeout(async () => {
        try {
          // 🔍 피드백 세션 중인지 확인
          const currentState = await getAgentState(teamId, agentId);
          if (currentState && isFeedbackSessionActive(currentState)) {
            console.log(
              `🔒 에이전트 ${agentId}는 피드백 세션 중이므로 wait 후 idle 전환 스킵`
            );
            return;
          }

          console.log(
            `😴 에이전트 ${agentId} → Wait 후 Idle 상태 전환 시도 중...`
          );
          const baseUrl = process.env.NEXTAUTH_URL || `http://localhost:3000`;
          const response = await fetch(
            `${baseUrl}/api/teams/${teamId}/agent-states`,
            {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
                "User-Agent": "TeamBuilder-Internal",
              },
              body: JSON.stringify({
                agentId,
                currentState: "idle",
              }),
            }
          );

          if (response.ok) {
            console.log(`😴 에이전트 ${agentId} → Wait 후 Idle 상태 전환 완료`);
          } else {
            const errorText = await response.text();
            console.error(
              `❌ 에이전트 ${agentId} Wait 후 Idle 전환 실패:`,
              response.status,
              errorText
            );
          }
        } catch (e) {
          console.error(`❌ 에이전트 ${agentId} Wait 후 Idle 전환 실패:`, e);
        }
      }, 2000);

      return; // wait 액션은 여기서 종료
    }
  } catch (error) {
    console.error(`❌ ${agentId} 작업 실행 실패:`, error);

    // 🔍 실패 시에도 피드백 세션 중인지 확인
    const currentState = await getAgentState(teamId, agentId);
    if (currentState && isFeedbackSessionActive(currentState)) {
      console.log(
        `🔒 에이전트 ${agentId}는 피드백 세션 중이므로 실패 후에도 idle 전환 스킵`
      );
      return;
    }

    // 실패 시에도 idle 상태로 전환 (피드백 세션 중이 아닌 경우만)
    setTimeout(async () => {
      try {
        // 다시 한번 피드백 세션 상태 확인
        const finalState = await getAgentState(teamId, agentId);
        if (finalState && isFeedbackSessionActive(finalState)) {
          console.log(
            `🔒 에이전트 ${agentId}는 여전히 피드백 세션 중이므로 실패 후에도 idle 전환 스킵`
          );
          return;
        }

        console.log(
          `😴 에이전트 ${agentId} → 실패 후 Idle 상태 전환 시도 중...`
        );
        const baseUrl = process.env.NEXTAUTH_URL || `http://localhost:3000`;
        const response = await fetch(
          `${baseUrl}/api/teams/${teamId}/agent-states`,
          {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              "User-Agent": "TeamBuilder-Internal",
            },
            body: JSON.stringify({
              agentId,
              currentState: "idle",
            }),
          }
        );

        if (response.ok) {
          console.log(`😴 에이전트 ${agentId} → 실패 후 Idle 상태 전환 완료`);
        } else {
          const errorText = await response.text();
          console.error(
            `❌ 에이전트 ${agentId} 실패 후 Idle 전환 실패:`,
            response.status,
            errorText
          );
        }
      } catch (e) {
        console.error(`❌ 에이전트 ${agentId} 실패 후 Idle 전환 실패:`, e);
      }
    }, 2000);
  }
}

export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ teamId: string }> }
) {
  try {
    const { teamId } = await params;

    // 팀 정보 가져오기
    const team = await getTeamById(teamId);
    if (!team) {
      return NextResponse.json(
        { error: "팀을 찾을 수 없습니다." },
        { status: 404 }
      );
    }

    // 모든 에이전트 상태를 병렬로 조회 및 처리
    const agentStatePromises = team.members
      .filter((member) => !member.isUser && member.agentId)
      .map(async (member) => {
        try {
          let state = await getAgentState(teamId, member.agentId!);

          // 상태가 있으면 타이머 업데이트 실행
          if (state) {
            const updatedState = await updateAgentStateTimer(teamId, state);
            // 업데이트된 상태를 Redis에 저장
            await setAgentState(teamId, member.agentId!, updatedState);
            state = updatedState;
          }

          const agent = await getAgentById(member.agentId!);
          return {
            agentId: member.agentId!,
            name: agent?.name || member.agentId!,
            state: state || null,
            isFeedbackSession: state ? isFeedbackSessionActive(state) : false,
          };
        } catch (error) {
          console.error(`❌ 에이전트 ${member.agentId} 상태 조회 실패:`, error);
          return {
            agentId: member.agentId!,
            name: member.agentId!,
            state: null,
            isFeedbackSession: false,
          };
        }
      });

    // 활성 피드백 세션 조회와 사용자 상태 조회도 병렬로 처리
    const [agentStates, activeSessions, userStateData] = await Promise.all([
      Promise.all(agentStatePromises),
      redis.keys("feedback_session:*"),
      redis.get(`team:${teamId}:user_state`),
    ]);

    // 활성 피드백 세션 정보 처리
    const sessionInfoPromises = activeSessions.map(async (sessionKey) => {
      try {
        const sessionData = await redis.get(sessionKey);
        if (sessionData) {
          const session =
            typeof sessionData === "string"
              ? JSON.parse(sessionData)
              : sessionData;
          return {
            sessionId: session.id,
            status: session.status,
            participants: session.participants.map((p: any) => ({
              id: p.id,
              name: p.name,
              isUser: p.isUser,
            })),
            createdAt: session.createdAt,
            endedAt: session.endedAt,
          };
        }
        return null;
      } catch (error) {
        console.error(`❌ 세션 ${sessionKey} 조회 실패:`, error);
        return null;
      }
    });

    const sessionInfo = (await Promise.all(sessionInfoPromises)).filter(
      Boolean
    );

    // 인간 사용자 상태 처리
    const userState = userStateData
      ? typeof userStateData === "string"
        ? JSON.parse(userStateData)
        : userStateData
      : null;

    return NextResponse.json({
      teamId,
      agentStates,
      activeFeedbackSessions: sessionInfo,
      userState,
      timestamp: new Date().toISOString(),
    });
  } catch (error) {
    console.error("에이전트 상태 조회 실패:", error);
    return NextResponse.json(
      { error: "상태 조회에 실패했습니다." },
      { status: 500 }
    );
  }
}

// 에이전트 상태 업데이트를 위한 POST 메서드
export async function POST(
  request: NextRequest,
  { params }: { params: Promise<{ teamId: string }> }
) {
  try {
    const { teamId } = await params;
    const body = await request.json();
    const {
      agentId,
      currentState,
      taskType,
      taskDescription,
      estimatedDuration,
      trigger = "autonomous",
      plannedAction,
      sessionInfo,
      forceClear = false, // 강제 초기화 플래그 추가
      action, // 새로운 필드: 요청 처리용
      requestData, // 새로운 필드: 요청 데이터
      requestInfo, // 요청 정보 필드 추가
    } = body;

    console.log(`📋 에이전트 ${agentId} 상태 변경 요청:`, {
      currentState,
      taskType,
      forceClear,
    });

    // forceClear가 true이면 모든 체크를 무시하고 강제로 상태 변경
    if (forceClear && currentState === "idle") {
      console.log(`🔧 에이전트 ${agentId} 강제 idle 상태 초기화`);

      const forcedState: AgentStateInfo = {
        agentId,
        currentState: "idle",
        lastStateChange: new Date().toISOString(),
        isProcessing: false,
        idleTimer: createNewIdleTimer(),
      };

      await setAgentState(teamId, agentId, forcedState);

      console.log(`✅ 에이전트 ${agentId} 강제 idle 상태 초기화 완료`);

      return NextResponse.json({
        success: true,
        message: "에이전트 상태가 강제로 idle로 초기화되었습니다",
        state: forcedState,
      });
    }

    // 다른 액션들은 agentId가 필요함
    if (!agentId) {
      return NextResponse.json(
        { error: "agentId가 필요합니다." },
        { status: 400 }
      );
    }

    // 요청 처리 액션인 경우
    if (action === "process_request" && requestData) {
      console.log(`📨 에이전트 ${agentId}에게 요청 처리: ${requestData.type}`);
      console.log(`요청 상세 정보:`, JSON.stringify(requestData, null, 2));

      // 현재 에이전트 상태 확인
      const currentAgentState = await getAgentState(teamId, agentId);
      console.log(
        `현재 에이전트 상태:`,
        JSON.stringify(currentAgentState, null, 2)
      );

      // 에이전트 상태가 없는 경우
      if (!currentAgentState) {
        console.error(`❌ 에이전트 ${agentId} 상태를 찾을 수 없습니다.`);
        return NextResponse.json(
          { error: "에이전트 상태를 찾을 수 없습니다." },
          { status: 404 }
        );
      }

      // 피드백 세션 중인지 확인
      if (isFeedbackSessionActive(currentAgentState)) {
        console.log(
          `⚠️ 에이전트 ${agentId}가 피드백 세션 중이므로 요청 처리 불가`
        );
        return NextResponse.json(
          {
            error: "에이전트가 현재 피드백 세션에 참여 중입니다.",
            agentState: currentAgentState,
          },
          { status: 409 }
        );
      }

      // 백그라운드에서 요청 처리
      processRequestInBackground(teamId, agentId, requestData);

      return NextResponse.json({
        message: "요청이 처리 중입니다.",
        agentId,
        requestType: requestData.type,
      });
    }

    const now = new Date();
    let newState: AgentStateInfo;

    if (currentState === "idle") {
      // idle 상태로 전환 시 큐 확인
      const queueKey = `agent_queue:${teamId}:${agentId}`;
      const queuedRequest = await redis.rpop(queueKey);

      // 디버깅을 위한 상세 로깅
      console.log(`🔍 큐 확인 결과:`, {
        agentId,
        queueKey,
        queuedRequest,
        queuedRequestType: typeof queuedRequest,
        queuedRequestIsNull: queuedRequest === null,
      });

      if (queuedRequest && queuedRequest !== null) {
        // 큐에 대기 중인 요청이 있으면 즉시 처리
        console.log(`📋 에이전트 ${agentId} 큐에서 요청 발견 - 즉시 처리`);

        // Redis에서 가져온 데이터가 이미 객체일 수 있으므로 타입 확인
        let requestData;
        try {
          if (typeof queuedRequest === "string") {
            requestData = JSON.parse(queuedRequest);
          } else if (
            typeof queuedRequest === "object" &&
            queuedRequest !== null
          ) {
            requestData = queuedRequest;
          } else {
            throw new Error(
              `예상하지 못한 큐 데이터 타입: ${typeof queuedRequest}`
            );
          }

          // requestData 유효성 검사
          if (!requestData || typeof requestData !== "object") {
            throw new Error("유효하지 않은 요청 데이터");
          }
        } catch (parseError) {
          console.error(
            `❌ 에이전트 ${agentId} 큐 데이터 파싱 실패:`,
            parseError
          );
          console.error(`큐 데이터 상세:`, {
            queuedRequest,
            type: typeof queuedRequest,
            isNull: queuedRequest === null,
            isUndefined: queuedRequest === undefined,
          });

          // 파싱 실패 시 기본 idle 상태로
          newState = {
            agentId,
            currentState: "idle",
            lastStateChange: now.toISOString(),
            isProcessing: false,
            idleTimer: createNewIdleTimer(),
          };
          await setAgentState(teamId, agentId, newState);
          return NextResponse.json({
            success: true,
            message: "큐 데이터 파싱 실패로 idle 상태로 전환되었습니다.",
            state: newState,
          });
        }

        newState = {
          agentId,
          currentState: "action",
          lastStateChange: now.toISOString(),
          isProcessing: true,
          currentTask: {
            type:
              requestData.type === "evaluate_idea"
                ? "evaluate_idea"
                : "thinking",
            description: `${requestData.requesterName}의 요청: ${
              requestData.payload?.message || "요청 처리"
            }`,
            startTime: now.toISOString(),
            estimatedDuration: 30,
            trigger: "user_request",
            requestInfo: {
              requesterName: requestData.requesterName,
              requestMessage: requestData.payload?.message || "",
            },
          },
        };

        // 백그라운드에서 요청 처리
        processRequestInBackground(teamId, agentId, requestData);
      } else {
        // 큐가 비어있으면 일반 idle 상태
        newState = {
          agentId,
          currentState: "idle",
          lastStateChange: now.toISOString(),
          isProcessing: false,
          idleTimer: createNewIdleTimer(),
        };
      }
    } else if (currentState === "plan" || currentState === "action") {
      // 작업 상태로 전환
      newState = {
        agentId,
        currentState,
        lastStateChange: now.toISOString(),
        isProcessing: true,
        currentTask: {
          type: taskType || "thinking",
          description: taskDescription || "작업을 수행하고 있습니다",
          startTime: now.toISOString(),
          estimatedDuration: estimatedDuration || 60,
          trigger: trigger || "autonomous",
          requestInfo: requestInfo,
        },
      };
    } else if (currentState === "feedback_session") {
      // 피드백 세션 상태로 전환
      newState = {
        agentId,
        currentState: "feedback_session",
        lastStateChange: now.toISOString(),
        isProcessing: true,
        currentTask: {
          type: "feedback_session",
          description: taskDescription || "피드백 세션 진행 중",
          startTime: now.toISOString(),
          estimatedDuration: estimatedDuration || 300, // 5분 기본값
          trigger: trigger || "user_request",
          requestInfo: requestInfo,
          sessionInfo: sessionInfo,
        },
      };
    } else if (currentState === "reflecting") {
      // 회고 상태로 전환
      newState = {
        agentId,
        currentState: "reflecting",
        lastStateChange: now.toISOString(),
        isProcessing: true,
        currentTask: {
          type: "reflecting",
          description: taskDescription || "경험을 바탕으로 자기 성찰 중",
          startTime: now.toISOString(),
          estimatedDuration: estimatedDuration || 10,
          trigger: "autonomous",
          requestInfo: requestInfo,
        },
      };
    } else {
      return NextResponse.json(
        { error: "유효하지 않은 상태입니다." },
        { status: 400 }
      );
    }

    // Redis에 상태 저장
    await setAgentState(teamId, agentId, newState);

    return NextResponse.json({
      success: true,
      message: "에이전트 상태가 업데이트되었습니다.",
      state: newState,
    });
  } catch (error) {
    console.error("에이전트 상태 업데이트 실패:", error);
    return NextResponse.json(
      { error: "상태 업데이트에 실패했습니다." },
      { status: 500 }
    );
  }
}

// 백그라운드에서 요청 처리하는 함수
async function processRequestInBackground(
  teamId: string,
  agentId: string,
  requestData: any
) {
  try {
    console.log(
      `🔧 에이전트 ${agentId} 백그라운드 요청 처리 시작: ${requestData.type}`
    );

    if (requestData.type === "evaluate_idea") {
      // 아이디어 평가 요청 처리
      await handleEvaluateIdeaRequestDirect(teamId, agentId, requestData);
    } else if (requestData.type === "generate_idea") {
      // 아이디어 생성 요청 처리
      await handleGenerateIdeaRequestDirect(teamId, agentId, requestData);
    } else if (requestData.type === "give_feedback") {
      // 피드백 요청 처리
      await handleGiveFeedbackRequestDirect(teamId, agentId, requestData);
    }

    console.log(`✅ 에이전트 ${agentId} 요청 처리 완료`);

    // 🔍 피드백 세션 중인지 확인 후 상태 전환 결정
    const currentState = await getAgentState(teamId, agentId);
    if (currentState && isFeedbackSessionActive(currentState)) {
      console.log(
        `🔒 에이전트 ${agentId}는 피드백 세션 중이므로 idle 전환 스킵`
      );
      return; // 피드백 세션 중이면 idle로 전환하지 않음
    }

    // 처리 완료 후 idle 상태로 전환 (피드백 세션 중이 아닌 경우만)
    setTimeout(async () => {
      try {
        // 다시 한번 피드백 세션 상태 확인 (상태가 변경될 수 있음)
        const finalState = await getAgentState(teamId, agentId);
        if (finalState && isFeedbackSessionActive(finalState)) {
          console.log(
            `🔒 에이전트 ${agentId}는 여전히 피드백 세션 중이므로 idle 전환 스킵`
          );
          return;
        }

        console.log(`😴 에이전트 ${agentId} → Idle 상태 전환 시도 중...`);
        const baseUrl = process.env.NEXTAUTH_URL || `http://localhost:3000`;
        const response = await fetch(
          `${baseUrl}/api/teams/${teamId}/agent-states`,
          {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              "User-Agent": "TeamBuilder-Internal",
            },
            body: JSON.stringify({
              agentId,
              currentState: "idle",
            }),
          }
        );

        if (response.ok) {
          console.log(`😴 에이전트 ${agentId} → Idle 상태 전환 완료`);
        } else {
          const errorText = await response.text();
          console.error(
            `❌ 에이전트 ${agentId} Idle 전환 실패:`,
            response.status,
            errorText
          );
        }
      } catch (error) {
        console.error(`❌ 에이전트 ${agentId} Idle 전환 실패:`, error);
      }
    }, 2000); // 2초 후 idle로 전환
  } catch (error) {
    console.error(`❌ 에이전트 ${agentId} 백그라운드 요청 처리 실패:`, error);

    // 🔍 실패 시에도 피드백 세션 중인지 확인
    const currentState = await getAgentState(teamId, agentId);
    if (currentState && isFeedbackSessionActive(currentState)) {
      console.log(
        `🔒 에이전트 ${agentId}는 피드백 세션 중이므로 실패 후에도 idle 전환 스킵`
      );
      return;
    }

    // 실패 시에도 idle 상태로 전환 (피드백 세션 중이 아닌 경우만)
    setTimeout(async () => {
      try {
        // 다시 한번 피드백 세션 상태 확인
        const finalState = await getAgentState(teamId, agentId);
        if (finalState && isFeedbackSessionActive(finalState)) {
          console.log(
            `🔒 에이전트 ${agentId}는 여전히 피드백 세션 중이므로 실패 후에도 idle 전환 스킵`
          );
          return;
        }

        console.log(
          `😴 에이전트 ${agentId} → 실패 후 Idle 상태 전환 시도 중...`
        );
        const baseUrl = process.env.NEXTAUTH_URL || `http://localhost:3000`;
        const response = await fetch(
          `${baseUrl}/api/teams/${teamId}/agent-states`,
          {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              "User-Agent": "TeamBuilder-Internal",
            },
            body: JSON.stringify({
              agentId,
              currentState: "idle",
            }),
          }
        );

        if (response.ok) {
          console.log(`😴 에이전트 ${agentId} → 실패 후 Idle 상태 전환 완료`);
        } else {
          const errorText = await response.text();
          console.error(
            `❌ 에이전트 ${agentId} 실패 후 Idle 전환 실패:`,
            response.status,
            errorText
          );
        }
      } catch (e) {
        console.error(`❌ 에이전트 ${agentId} 실패 후 Idle 전환 실패:`, e);
      }
    }, 2000);
  }
}

// 직접 아이디어 평가 요청 처리
async function handleEvaluateIdeaRequestDirect(
  teamId: string,
  agentId: string,
  requestData: any
) {
  console.log(`📊 에이전트 ${agentId} 아이디어 평가 요청 직접 처리`);

  try {
    // 🚫 요청자가 피드백 세션 중인지 확인
    const activeSessions = await redis.keys("feedback_session:*");
    const requesterId = requestData.requesterId;

    if (requesterId) {
      for (const sessionKey of activeSessions) {
        const sessionData = await redis.get(sessionKey);
        if (sessionData) {
          const session =
            typeof sessionData === "string"
              ? JSON.parse(sessionData)
              : sessionData;
          if (
            session.status === "active" &&
            session.participants.some((p: any) => p.id === requesterId)
          ) {
            console.log(`⏳ 요청자가 피드백 세션 중 - 아이디어 평가 요청 무시`);
            return;
          }
        }
      }
    }

    // 🚫 대상 에이전트(agentId)가 피드백 세션 중인지 확인
    for (const sessionKey of activeSessions) {
      const sessionData = await redis.get(sessionKey);
      if (sessionData) {
        const session =
          typeof sessionData === "string"
            ? JSON.parse(sessionData)
            : sessionData;
        if (
          session.status === "active" &&
          session.participants.some((p: any) => p.id === agentId)
        ) {
          console.log(
            `⏳ 대상 에이전트가 피드백 세션 중 - 아이디어 평가 요청 무시`
          );
          return;
        }
      }
    }

    const ideas = await getIdeas(teamId);

    if (ideas.length === 0) {
      console.log(`⚠️ 에이전트 ${agentId} 평가할 아이디어가 없음`);
      return;
    }

    // 본인이 만든 아이디어 제외
    const otherIdeas = ideas.filter((idea) => idea.author !== agentId);

    if (otherIdeas.length === 0) {
      console.log(`⚠️ 에이전트 ${agentId} 평가할 다른 사람의 아이디어가 없음`);
      return;
    }

    // 🔍 이미 평가한 아이디어 제외
    const unevaluatedIdeas = otherIdeas.filter((idea) => {
      const hasAlreadyEvaluated = idea.evaluations.some(
        (evaluation) => evaluation.evaluator === agentId
      );
      return !hasAlreadyEvaluated;
    });

    if (unevaluatedIdeas.length === 0) {
      console.log(
        `⚠️ 에이전트 ${agentId} 평가할 새로운 아이디어가 없음 (모두 평가 완료)`
      );
      return;
    }

    // 🎯 실제 아이디어 평가 수행
    const team = await getTeamById(teamId);
    const agentProfile = await getAgentById(agentId);

    if (!team || !agentProfile) {
      console.error(`❌ ${agentId} 팀 또는 에이전트 정보 없음`);
      return;
    }

    // 에이전트 상태를 작업 중으로 변경
    await setAgentState(teamId, agentId, {
      agentId,
      currentState: "action",
      lastStateChange: new Date().toISOString(),
      isProcessing: true,
      currentTask: {
        type: "evaluate_idea",
        description: `요청받은 아이디어 평가`,
        startTime: new Date().toISOString(),
        estimatedDuration: 300,
      },
    });

    // 아이디어 평가 수행
    const { evaluateIdeaAction } = await import("@/lib/openai");
    const randomIdea =
      unevaluatedIdeas[Math.floor(Math.random() * unevaluatedIdeas.length)];

    console.log(
      `📊 ${agentProfile.name} → ${randomIdea.content.object} 평가 시작`
    );

    try {
      const evaluation = await evaluateIdeaAction(
        randomIdea,
        agentProfile.name
      );

      // 평가 저장
      const response = await fetch(
        `${
          process.env.NEXTAUTH_URL || "http://localhost:3000"
        }/api/teams/${teamId}/ideas/${randomIdea.id}/evaluate`,
        {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "User-Agent": "TeamBuilder-Internal",
          },
          body: JSON.stringify({
            evaluator: agentId,
            scores: {
              insightful: evaluation.insightful,
              actionable: evaluation.actionable,
              relevance: evaluation.relevance,
            },
            comment: evaluation.comment,
          }),
        }
      );

      if (response.ok) {
        console.log(`✅ ${agentProfile.name} 아이디어 평가 완료`);

        // 평가 완료 메시지
        await addChatMessage(teamId, {
          sender: agentId,
          type: "system",
          payload: {
            content: `요청받은 아이디어를 평가했습니다.`,
          },
        });
      } else {
        console.error(
          `❌ ${agentProfile.name} 평가 저장 실패:`,
          response.status
        );
      }
    } catch (evaluationError) {
      console.error(`❌ ${agentProfile.name} 평가 수행 실패:`, evaluationError);
    }

    console.log(`✅ 에이전트 ${agentId} 아이디어 평가 요청 처리 완료`);
  } catch (error) {
    console.error(`❌ 에이전트 ${agentId} 평가 요청 처리 실패:`, error);
  }
}

// 아이디어 생성 요청 처리
async function handleGenerateIdeaRequestDirect(
  teamId: string,
  agentId: string,
  requestData: any
) {
  console.log(`📊 에이전트 ${agentId} 아이디어 생성 요청 직접 처리`);

  try {
    // 🚫 요청자가 피드백 세션 중인지 확인
    const activeSessions = await redis.keys("feedback_session:*");
    const requesterId = requestData.requesterId;

    if (requesterId) {
      for (const sessionKey of activeSessions) {
        const sessionData = await redis.get(sessionKey);
        if (sessionData) {
          const session =
            typeof sessionData === "string"
              ? JSON.parse(sessionData)
              : sessionData;
          if (
            session.status === "active" &&
            session.participants.some((p: any) => p.id === requesterId)
          ) {
            console.log(`⏳ 요청자가 피드백 세션 중 - 아이디어 생성 요청 무시`);
            return;
          }
        }
      }
    }

    // 🚫 대상 에이전트(agentId)가 피드백 세션 중인지 확인
    for (const sessionKey of activeSessions) {
      const sessionData = await redis.get(sessionKey);
      if (sessionData) {
        const session =
          typeof sessionData === "string"
            ? JSON.parse(sessionData)
            : sessionData;
        if (
          session.status === "active" &&
          session.participants.some((p: any) => p.id === agentId)
        ) {
          console.log(
            `⏳ 대상 에이전트가 피드백 세션 중 - 아이디어 생성 요청 무시`
          );
          return;
        }
      }
    }

    const team = await getTeamById(teamId);
    const agentProfile = await getAgentById(agentId);

    if (!team || !agentProfile) {
      console.error(`❌ ${agentId} 팀 또는 에이전트 정보 없음`);
      return;
    }

    // 에이전트 상태를 작업 중으로 변경
    await setAgentState(teamId, agentId, {
      agentId,
      currentState: "action",
      lastStateChange: new Date().toISOString(),
      isProcessing: true,
      currentTask: {
        type: "generate_idea",
        description: `요청받은 아이디어 생성`,
        startTime: new Date().toISOString(),
        estimatedDuration: 300,
      },
    });

    console.log(`🎯 ${agentProfile.name} 요청받은 아이디어 생성 시작`);

    const ideas = await getIdeas(teamId);
    const existingIdeas = ideas.map((idea, index) => ({
      ideaNumber: index + 1,
      authorName: idea.author,
      object: idea.content.object,
      function: idea.content.function,
    }));

    const agentMemory = await getAgentMemory(agentId);
    const generatedContent = await generateIdeaAction(
      team.topic || "Carbon Emission Reduction",
      agentProfile,
      existingIdeas,
      agentMemory || undefined
    );

    const newIdea = await addIdea(teamId, {
      author: agentId,
      timestamp: new Date().toISOString(),
      content: {
        object: generatedContent.object || "생성된 아이디어",
        function: generatedContent.function || "기능 설명",
        behavior:
          typeof generatedContent.behavior === "object"
            ? JSON.stringify(generatedContent.behavior)
            : generatedContent.behavior || "동작 설명",
        structure:
          typeof generatedContent.structure === "object"
            ? JSON.stringify(generatedContent.structure)
            : generatedContent.structure || "구조 설명",
      },
      evaluations: [],
    });

    // 채팅 알림
    await addChatMessage(teamId, {
      sender: agentId,
      type: "system",
      payload: {
        content: `${requestData.requesterName}의 요청에 따라 새로운 아이디어를 생성했습니다.`,
      },
    });

    console.log(
      `✅ ${agentProfile.name} 아이디어 생성 완료:`,
      generatedContent.object
    );
  } catch (error) {
    console.error(
      `❌ 에이전트 ${agentId} 아이디어 생성 요청 처리 실패:`,
      error
    );
  }
}

// 피드백 요청 처리
async function handleGiveFeedbackRequestDirect(
  teamId: string,
  agentId: string,
  requestData: any
) {
  console.log(`💬 에이전트 ${agentId} 피드백 요청 직접 처리`);

  try {
    const team = await getTeamById(teamId);
    const agentProfile = await getAgentById(agentId);

    if (!team || !agentProfile) {
      console.error(`❌ ${agentId} 팀 또는 에이전트 정보 없음`);
      return;
    }

    // 요청자 정보 확인
    const requesterName = requestData.requesterName;
    const requesterId = requestData.requesterId;

    console.log(`📋 피드백 요청 상세 정보:`, {
      requesterName,
      requesterId,
      agentName: agentProfile.name,
      agentId,
    });

    // 🚫 요청자가 피드백 세션 중인지 확인
    const activeSessions = await redis.keys("feedback_session:*");
    let requesterInFeedbackSession = false;

    for (const sessionKey of activeSessions) {
      const sessionData = await redis.get(sessionKey);
      if (sessionData) {
        const session =
          typeof sessionData === "string"
            ? JSON.parse(sessionData)
            : sessionData;
        if (
          session.status === "active" &&
          session.participants.some((p: any) => p.id === requesterId)
        ) {
          requesterInFeedbackSession = true;
          break;
        }
      }
    }

    if (requesterInFeedbackSession) {
      console.log(
        `⏳ 요청자 ${requesterName}가 피드백 세션 중 - 피드백 요청 무시`
      );
      return;
    }

    // 🚫 대상 에이전트(agentId)가 피드백 세션 중인지 확인
    let targetInFeedbackSession = false;
    for (const sessionKey of activeSessions) {
      const sessionData = await redis.get(sessionKey);
      if (sessionData) {
        const session =
          typeof sessionData === "string"
            ? JSON.parse(sessionData)
            : sessionData;
        if (
          session.status === "active" &&
          session.participants.some((p: any) => p.id === agentId)
        ) {
          targetInFeedbackSession = true;
          break;
        }
      }
    }

    if (targetInFeedbackSession) {
      console.log(`⏳ 대상 에이전트가 피드백 세션 중 - 피드백 요청 무시`);
      return;
    }

    // 에이전트 상태를 작업 중으로 변경
    await setAgentState(teamId, agentId, {
      agentId,
      currentState: "action",
      lastStateChange: new Date().toISOString(),
      isProcessing: true,
      currentTask: {
        type: "give_feedback",
        description: `${requesterName}의 요청에 따른 피드백 전략 수립 중`,
        startTime: new Date().toISOString(),
        estimatedDuration: 60,
      },
    });

    console.log(`🎯 ${agentProfile.name} 피드백 전략 수립 시작`);

    // 🔍 모든 필요한 정보 수집
    // 1. 팀의 모든 에이전트 정보 가져오기
    const agents = await Promise.all(
      (team?.members || [])
        .filter((m) => !m.isUser && m.agentId)
        .map((m) => getAgentById(m.agentId!))
    );
    const validAgents = agents.filter((agent) => agent !== null);

    // 2. 팀원 정보 구성 (사용 가능 여부 포함)
    const busyAgents = new Set<string>();
    for (const sessionKey of activeSessions) {
      const sessionData = await redis.get(sessionKey);
      if (sessionData) {
        const session =
          typeof sessionData === "string"
            ? JSON.parse(sessionData)
            : sessionData;
        if (session.status === "active") {
          session.participants.forEach((p: any) => {
            busyAgents.add(p.id);
          });
        }
      }
    }

    const teamMembers = [];

    // AI 에이전트들 추가 (본인 제외)
    for (const member of team.members) {
      if (!member.isUser && member.agentId && member.agentId !== agentId) {
        const agent = validAgents.find((a: any) => a?.id === member.agentId);
        if (agent) {
          teamMembers.push({
            id: member.agentId,
            name: agent.name,
            isUser: false,
            roles: member.roles || [],
            isAvailable: !busyAgents.has(member.agentId),
          });
        }
      }
    }

    // 인간 사용자 추가
    const humanMember = team.members.find((member) => member.isUser);
    if (humanMember) {
      teamMembers.push({
        id: "나",
        name: "나",
        isUser: true,
        roles: humanMember.roles || [],
        isAvailable: !busyAgents.has("나"),
      });
    }

    // 3. 아이디어 정보 가져오기
    const ideas = await getIdeas(teamId);
    const existingIdeas = ideas.map((idea, index) => ({
      ideaNumber: index + 1,
      authorId: idea.author,
      authorName:
        idea.author === "나"
          ? "나"
          : (() => {
              const member = team?.members.find(
                (tm) => tm.agentId === idea.author
              );
              if (member && !member.isUser) {
                const agent = validAgents.find(
                  (a: any) => a?.id === idea.author
                );
                return agent?.name || `에이전트 ${idea.author}`;
              }
              return idea.author;
            })(),
      object: idea.content.object,
      function: idea.content.function,
      behavior: idea.content.behavior,
      structure: idea.content.structure,
      timestamp: idea.timestamp,
      evaluations: idea.evaluations || [],
    }));

    // 4. 최근 메시지 가져오기
    const recentMessages = await getChatHistory(teamId, 5);

    // 5. 에이전트 메모리 가져오기
    const agentMemory = await getAgentMemory(agentId);

    // 사용 가능한 팀원이 없는 경우
    const availableMembers = teamMembers.filter((member) => member.isAvailable);
    if (availableMembers.length === 0) {
      console.log(
        `⚠️ ${agentProfile.name} 현재 사용 가능한 피드백 대상이 없음`
      );

      await addChatMessage(teamId, {
        sender: agentId,
        type: "system",
        payload: {
          content: `현재 모든 팀원이 다른 작업 중이어서 피드백을 제공할 수 없습니다.`,
        },
      });
      return;
    }

    // 🧠 AI에게 피드백 전략 결정 요청
    console.log(`🧠 ${agentProfile.name} AI 피드백 전략 결정 중...`);

    const feedbackStrategy = await planFeedbackStrategy(
      agentProfile,
      {
        teamName: team.teamName || "팀",
        topic: team.topic || "아이디에이션",
        teamMembers: availableMembers, // 사용 가능한 팀원만 전달
        existingIdeas,
        recentMessages,
      },
      {
        requesterName,
        originalMessage:
          requestData.payload?.message || "피드백을 요청했습니다.",
      },
      agentMemory || undefined
    );

    console.log(`🎯 ${agentProfile.name} 피드백 전략 결정 완료:`, {
      target: feedbackStrategy.targetMember.name,
      type: feedbackStrategy.feedbackType,
      reasoning: feedbackStrategy.reasoning,
    });

    const targetMember = feedbackStrategy.targetMember;

    // 락 키 생성 (작은 ID가 먼저 오도록 정렬)
    const lockKey = `feedback_lock:${[agentId, targetMember.id]
      .sort()
      .join(":")}`;

    // 분산 락 사용
    const lockAcquired = await redis.set(lockKey, "locked", {
      ex: 30, // 30초 TTL
      nx: true, // 키가 존재하지 않을 때만 설정
    });

    if (!lockAcquired) {
      console.log(
        `⚠️ ${agentProfile.name} → ${targetMember.name} 피드백 세션 락 획득 실패 (이미 진행 중)`
      );

      await addChatMessage(teamId, {
        sender: agentId,
        type: "system",
        payload: {
          content: `${targetMember.name}와의 피드백 세션이 이미 진행 중입니다.`,
        },
      });
      return;
    }

    try {
      // 피드백 컨텍스트 구성
      const feedbackContext = {
        type: feedbackStrategy.feedbackType,
        initiatedBy: "user_request",
        description: `${requesterName}의 요청에 따른 ${feedbackStrategy.feedbackType} 피드백`,
        originalRequest: requestData.payload?.message,
        targetIdea: feedbackStrategy.targetIdea,
        aiStrategy: {
          reasoning: feedbackStrategy.reasoning,
          plannedMessage: feedbackStrategy.feedbackMessage,
        },
      };

      // 피드백 세션 생성 API 호출
      const baseUrl = process.env.NEXTAUTH_URL || `http://localhost:3000`;
      const sessionResponse = await fetch(
        `${baseUrl}/api/teams/${teamId}/feedback-sessions`,
        {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "User-Agent": "TeamBuilder-Internal",
          },
          body: JSON.stringify({
            action: "create",
            initiatorId: agentId,
            targetAgentId: targetMember.id,
            message: feedbackStrategy.feedbackMessage,
            feedbackContext: feedbackContext,
          }),
        }
      );

      if (sessionResponse.ok) {
        const sessionData = await sessionResponse.json();
        console.log(
          `✅ ${agentProfile.name} → ${targetMember.name} 피드백 세션 생성 성공: ${sessionData.sessionId}`
        );

        // 성공 메시지 (전략 포함)
        await addChatMessage(teamId, {
          sender: agentId,
          type: "system",
          payload: {
            content: `${requesterName}의 요청에 따라 ${targetMember.name}와 ${
              feedbackStrategy.feedbackType === "specific_idea"
                ? "특정 아이디어에 대한"
                : "협업"
            } 피드백 세션을 시작합니다.`,
          },
        });

        // 🔄 피드백 세션 생성 즉시 양쪽 에이전트 상태 변경
        // 1. 피드백 제공자(현재 에이전트) 상태 변경
        try {
          const initiatorResponse = await fetch(
            `${baseUrl}/api/teams/${teamId}/agent-states`,
            {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
                "User-Agent": "TeamBuilder-Internal",
              },
              body: JSON.stringify({
                agentId: agentId,
                currentState: "feedback_session",
                taskType: "feedback_session",
                taskDescription: `${targetMember.name}와 ${feedbackStrategy.feedbackType} 피드백 세션 진행 중`,
                estimatedDuration: 300,
                trigger: "autonomous",
                sessionInfo: {
                  sessionId: sessionData.sessionId,
                  participants: [agentProfile.name, targetMember.name],
                  feedbackType: feedbackStrategy.feedbackType,
                },
              }),
            }
          );

          if (initiatorResponse.ok) {
            console.log(
              `✅ ${agentProfile.name} 상태가 feedback_session으로 변경됨`
            );
          } else {
            console.error(
              `❌ ${agentProfile.name} feedback_session 상태 변경 실패:`,
              initiatorResponse.status
            );
          }
        } catch (error) {
          console.error(
            `❌ ${agentProfile.name} feedback_session 상태 변경 오류:`,
            error
          );
        }

        // 2. 피드백 대상자(타겟 에이전트) 상태 변경 (인간이 아닌 경우만)
        if (!targetMember.isUser) {
          try {
            const targetResponse = await fetch(
              `${baseUrl}/api/teams/${teamId}/agent-states`,
              {
                method: "POST",
                headers: {
                  "Content-Type": "application/json",
                  "User-Agent": "TeamBuilder-Internal",
                },
                body: JSON.stringify({
                  agentId: targetMember.id,
                  currentState: "feedback_session",
                  taskType: "feedback_session",
                  taskDescription: `${agentProfile.name}와 ${feedbackStrategy.feedbackType} 피드백 세션 진행 중`,
                  estimatedDuration: 300,
                  trigger: "autonomous",
                  sessionInfo: {
                    sessionId: sessionData.sessionId,
                    participants: [agentProfile.name, targetMember.name],
                    feedbackType: feedbackStrategy.feedbackType,
                  },
                }),
              }
            );

            if (targetResponse.ok) {
              console.log(
                `✅ ${targetMember.name} 상태가 feedback_session으로 변경됨`
              );
            } else {
              console.error(
                `❌ ${targetMember.name} feedback_session 상태 변경 실패:`,
                targetResponse.status
              );
            }
          } catch (error) {
            console.error(
              `❌ ${targetMember.name} feedback_session 상태 변경 오류:`,
              error
            );
          }
        }

        // 인간에게 피드백하는 경우 즉시 첫 메시지 생성
        const isTargetHuman = targetMember.isUser;
        const delay = isTargetHuman ? 1000 : 3000; // 인간에게는 1초 후, AI에게는 3초 후

        setTimeout(async () => {
          try {
            const aiProcessResponse = await fetch(
              `${baseUrl}/api/teams/${teamId}/feedback-sessions/${sessionData.sessionId}/ai-process`,
              {
                method: "POST",
                headers: {
                  "Content-Type": "application/json",
                  "User-Agent": "TeamBuilder-Internal",
                },
                body: JSON.stringify({
                  triggerAgentId: agentId,
                  action: "respond",
                }),
              }
            );

            if (aiProcessResponse.ok) {
              console.log(
                `✅ ${agentProfile.name} 첫 피드백 메시지 생성 트리거 성공 (대상: ${targetMember.name})`
              );
            } else {
              console.error(
                `❌ ${agentProfile.name} 첫 피드백 메시지 생성 트리거 실패:`,
                aiProcessResponse.status
              );
            }
          } catch (error) {
            console.error(
              `❌ ${agentProfile.name} 첫 피드백 메시지 생성 트리거 오류:`,
              error
            );
          }
        }, delay);
      } else {
        const errorData = await sessionResponse.json();
        console.error(
          `❌ ${agentProfile.name} → ${targetMember.name} 피드백 세션 생성 실패:`,
          errorData
        );

        await addChatMessage(teamId, {
          sender: agentId,
          type: "system",
          payload: {
            content: `${targetMember.name}와의 피드백 세션 생성에 실패했습니다.`,
          },
        });
      }
    } finally {
      // 락 해제
      await redis.del(lockKey);
      console.log(`🔓 ${agentProfile.name} → ${targetMember.name} 락 해제`);
    }
  } catch (error) {
    console.error(`❌ 에이전트 ${agentId} 피드백 요청 처리 실패:`, error);

    await addChatMessage(teamId, {
      sender: agentId,
      type: "system",
      payload: {
        content: `피드백 요청 처리 중 오류가 발생했습니다.`,
      },
    });
  }
}
