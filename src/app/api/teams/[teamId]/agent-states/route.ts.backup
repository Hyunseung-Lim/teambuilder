import { NextRequest, NextResponse } from "next/server";
import {
  getTeamById,
  getAgentById,
  getIdeas,
  getChatHistory,
  addIdea,
  addChatMessage,
  getAgentMemory,
} from "@/lib/redis";
import { redis } from "@/lib/redis";
import {
  planNextAction,
  generateIdeaAction,
  preEvaluationAction,
  executeEvaluationAction,
  giveFeedbackOnIdea,
  makeRequestAction,
  alreadyEvaluatedResponseAction,
  planFeedbackStrategy,
} from "@/lib/openai";
import { processMemoryUpdate } from "@/lib/memory";
import {
  AgentStateInfo,
  getAgentState,
  setAgentState,
  isFeedbackSessionActive,
  validateTimer,
  createNewIdleTimer,
} from "@/lib/agent-state-utils";

// ì—ì´ì „íŠ¸ ìƒíƒœ ì—…ë°ì´íŠ¸ (ì‹œê°„ ê²½ê³¼ ë°˜ì˜)
async function updateAgentStateTimer(
  teamId: string,
  state: AgentStateInfo
): Promise<AgentStateInfo> {
  const now = new Date();

  // í”¼ë“œë°± ì„¸ì…˜ ì¤‘ì¸ ì—ì´ì „íŠ¸ëŠ” ìë™ ìƒíƒœ ì „í™˜í•˜ì§€ ì•ŠìŒ
  if (isFeedbackSessionActive(state)) {
    console.log(`ğŸ”’ ${state.agentId} í”¼ë“œë°± ì„¸ì…˜ ì¤‘ - ìë™ ìƒíƒœ ì „í™˜ ì°¨ë‹¨`);
    return state;
  }

  if (state.currentState === "idle" && state.idleTimer) {
    // íƒ€ì´ë¨¸ ì•ˆì •ì„± ê²€ì‚¬
    if (!validateTimer(state)) {
      console.warn(`âš ï¸ ${state.agentId} ë¹„ì •ìƒì ì¸ íƒ€ì´ë¨¸ ìƒíƒœ ê°ì§€, ì´ˆê¸°í™”`);
      state.idleTimer = createNewIdleTimer();
      return state;
    }

    // idle íƒ€ì´ë¨¸ ì—…ë°ì´íŠ¸
    const startTime = new Date(state.idleTimer.startTime).getTime();
    const elapsed = Math.floor((now.getTime() - startTime) / 1000);
    const newRemainingTime = Math.max(
      0,
      state.idleTimer.plannedDuration - elapsed
    );

    state.idleTimer.remainingTime = newRemainingTime;

    // íƒ€ì´ë¨¸ê°€ ëë‚˜ë©´ planning ì‹¤í–‰ (ë¹„ë™ê¸°ë¡œ ì²˜ë¦¬)
    if (newRemainingTime <= 0) {
      console.log(`ğŸ§  ${state.agentId} planning ì‹œì‘ (ë¹„ë™ê¸° ì²˜ë¦¬)`);

      // planning ìƒíƒœë¡œ ì¦‰ì‹œ ì „í™˜ (AI ì‘ì—…ì€ ë°±ê·¸ë¼ìš´ë“œì—ì„œ ì§„í–‰)
      state.currentState = "plan";
      state.lastStateChange = now.toISOString();
      state.isProcessing = true;
      state.currentTask = {
        type: "planning",
        description: "ë‹¤ìŒ í–‰ë™ ê³„íš ìˆ˜ë¦½ ì¤‘...",
        startTime: now.toISOString(),
        estimatedDuration: 15,
        trigger: "autonomous",
      };
      delete state.idleTimer;

      // AI planning ì‘ì—…ì„ ë°±ê·¸ë¼ìš´ë“œì—ì„œ ë¹„ë™ê¸° ì‹¤í–‰
      setTimeout(async () => {
        try {
          const team = await getTeamById(teamId);
          const agentProfile = await getAgentById(state.agentId);
          const ideas = await getIdeas(teamId);
          const recentMessages = await getChatHistory(teamId, 5);

          const agents = await Promise.all(
            (team?.members || [])
              .filter((m) => !m.isUser && m.agentId)
              .map((m) => getAgentById(m.agentId!))
          );

          // íŒ€ ë©¤ë²„ ì •ë³´ì—ì„œ í•´ë‹¹ ì—ì´ì „íŠ¸ì˜ ì—­í•  ê°€ì ¸ì˜¤ê¸°
          const teamMember = team?.members.find(
            (m) => m.agentId === state.agentId
          );
          const agentProfileWithRoles = agentProfile
            ? {
                ...agentProfile,
                roles: teamMember?.roles || [], // íŒ€ ë©¤ë²„ì˜ ì—­í•  ì •ë³´ ì¶”ê°€
              }
            : null;

          if (!agentProfileWithRoles) {
            console.error(`âŒ ${state.agentId} ì—ì´ì „íŠ¸ í”„ë¡œí•„ì„ ì°¾ì„ ìˆ˜ ì—†ìŒ`);
            return;
          }

          console.log(
            `ğŸ” ${agentProfileWithRoles.name}ì˜ íŒ€ ë©¤ë²„ ì—­í• :`,
            teamMember?.roles
          );

          // ê³„íš ìˆ˜ë¦½
          const planResult = await planNextAction(agentProfileWithRoles, {
            teamName: team?.teamName || "Unknown Team",
            topic: team?.topic || "Carbon Emission Reduction",
            currentIdeasCount: ideas.length,
            recentMessages: recentMessages,
            teamMembers: (team?.members || [])
              .filter((m) => !m.isUser)
              .map((m) => {
                const agent = agents
                  .filter(Boolean)
                  .find((a) => a?.id === m.agentId);
                return agent?.name || `ì—ì´ì „íŠ¸ ${m.agentId}`;
              }),
            existingIdeas: ideas.map((idea, index) => ({
              ideaNumber: index + 1,
              authorName:
                idea.author === "ë‚˜"
                  ? "ë‚˜"
                  : (() => {
                      const member = team?.members.find(
                        (tm) => tm.agentId === idea.author
                      );
                      if (member && !member.isUser) {
                        const agent = agents
                          .filter(Boolean)
                          .find((a) => a?.id === idea.author);
                        return agent?.name || `ì—ì´ì „íŠ¸ ${idea.author}`;
                      }
                      return idea.author;
                    })(),
              object: idea.content.object,
              function: idea.content.function,
            })),
          });

          // planning ì™„ë£Œ í›„ ìƒíƒœ ì—…ë°ì´íŠ¸
          const currentState = await getAgentState(teamId, state.agentId);
          if (currentState && currentState.currentState === "plan") {
            currentState.plannedAction = planResult;
            currentState.currentTask = {
              type: "planning",
              description: `ë‹¤ìŒ í–‰ë™ ê³„íš: ${planResult.action}`,
              startTime: now.toISOString(),
              estimatedDuration: 15,
              trigger: "autonomous",
            };
            await setAgentState(teamId, state.agentId, currentState);
            console.log(`ğŸ“‹ ${state.agentId} ê³„íš ì™„ë£Œ:`, planResult.action);

            // ê³„íš ì™„ë£Œ í›„ 3ì´ˆ ë’¤ì— ì‹¤í–‰
            setTimeout(async () => {
              try {
                await executeAgentAction(teamId, state.agentId, planResult);
              } catch (error) {
                console.error(`âŒ ${state.agentId} ì•¡ì…˜ ì‹¤í–‰ ì‹¤íŒ¨:`, error);
                // ì‹¤íŒ¨ ì‹œ idle ìƒíƒœë¡œ ë³µê·€ (í”¼ë“œë°± ì„¸ì…˜ ì¤‘ì´ ì•„ë‹Œ ê²½ìš°ë§Œ)
                const failedState = await getAgentState(teamId, state.agentId);
                if (failedState) {
                  // ğŸ”’ í”¼ë“œë°± ì„¸ì…˜ ì¤‘ì¸ì§€ í™•ì¸
                  if (isFeedbackSessionActive(failedState)) {
                    console.log(
                      `ğŸ”’ ${state.agentId} ì•¡ì…˜ ì‹¤í–‰ ì‹¤íŒ¨í–ˆì§€ë§Œ í”¼ë“œë°± ì„¸ì…˜ ì¤‘ì´ë¯€ë¡œ idle ì „í™˜ ìŠ¤í‚µ`
                    );
                    return;
                  }

                  failedState.currentState = "idle";
                  failedState.lastStateChange = new Date().toISOString();
                  failedState.isProcessing = false;
                  failedState.idleTimer = createNewIdleTimer();
                  delete failedState.currentTask;
                  delete failedState.plannedAction;
                  await setAgentState(teamId, state.agentId, failedState);
                }
              }
            }, 3000);
          }
        } catch (error) {
          console.error(`âŒ ${state.agentId} planning ì‹¤íŒ¨:`, error);
          // planning ì‹¤íŒ¨ ì‹œ idle ìƒíƒœë¡œ ë³µê·€
          const failedState = await getAgentState(teamId, state.agentId);
          if (failedState) {
            failedState.currentState = "idle";
            failedState.lastStateChange = new Date().toISOString();
            failedState.isProcessing = false;
            failedState.idleTimer = createNewIdleTimer();
            delete failedState.currentTask;
            delete failedState.plannedAction;
            await setAgentState(teamId, state.agentId, failedState);
          }
        }
      }, 0); // ì¦‰ì‹œ ë¹„ë™ê¸° ì‹¤í–‰

      return state; // planning ìƒíƒœë¡œ ì¦‰ì‹œ ë°˜í™˜
    }
  } else if (state.currentTask) {
    // í˜„ì¬ ì‘ì—…ì´ ìˆëŠ” ê²½ìš° ì‹œê°„ ì—…ë°ì´íŠ¸
    const taskStartTime = new Date(state.currentTask.startTime).getTime();
    const elapsed = Math.floor((now.getTime() - taskStartTime) / 1000);

    // ì‘ì—… ì‹œê°„ì´ ë¹„ì •ìƒì ìœ¼ë¡œ ê¸´ ê²½ìš° (10ë¶„ ì´ìƒ) ê°•ì œ ì¢…ë£Œ
    // ğŸ”’ ë‹¨, í”¼ë“œë°± ì„¸ì…˜ ì¤‘ì¸ ê²½ìš°ëŠ” ì˜ˆì™¸ ì²˜ë¦¬
    if (elapsed > 600) {
      if (isFeedbackSessionActive(state)) {
        console.log(
          `ğŸ”’ ${state.agentId} ì‘ì—… ì‹œê°„ ì´ˆê³¼ì´ì§€ë§Œ í”¼ë“œë°± ì„¸ì…˜ ì¤‘ì´ë¯€ë¡œ ê°•ì œ ì¢…ë£Œ ì°¨ë‹¨`
        );
        // í”¼ë“œë°± ì„¸ì…˜ì˜ ê²½ìš° ë” ê¸´ ì‹œê°„ í—ˆìš© (30ë¶„)
        if (elapsed > 1800) {
          console.warn(
            `âš ï¸ ${state.agentId} í”¼ë“œë°± ì„¸ì…˜ì´ 30ë¶„ì„ ì´ˆê³¼í•˜ì—¬ ê°•ì œ idle ì „í™˜`
          );
          state.currentState = "idle";
          state.lastStateChange = now.toISOString();
          state.isProcessing = false;
          state.idleTimer = createNewIdleTimer();
          delete state.currentTask;
          delete state.plannedAction;
        }
      } else {
        console.warn(`âš ï¸ ${state.agentId} ì‘ì—… ì‹œê°„ ì´ˆê³¼, ê°•ì œ idle ì „í™˜`);
        state.currentState = "idle";
        state.lastStateChange = now.toISOString();
        state.isProcessing = false;
        state.idleTimer = createNewIdleTimer();
        delete state.currentTask;
        delete state.plannedAction;
      }
    }
  }

  return state;
}

// ì‹¤ì œ ì—ì´ì „íŠ¸ ì‘ì—… ì‹¤í–‰ í•¨ìˆ˜
async function executeAgentAction(
  teamId: string,
  agentId: string,
  plannedAction: {
    action:
      | "generate_idea"
      | "evaluate_idea"
      | "give_feedback"
      | "make_request"
      | "wait";
    reasoning: string;
    target?: string;
  }
) {
  try {
    const team = await getTeamById(teamId);
    const agentProfile = await getAgentById(agentId);

    if (!team || !agentProfile) {
      console.error(`âŒ ${agentId} íŒ€ ë˜ëŠ” ì—ì´ì „íŠ¸ ì •ë³´ ì—†ìŒ`);
      return;
    }

    console.log(
      `ğŸ¯ ${agentProfile.name} ììœ¨ í–‰ë™ ì‹¤í–‰: ${plannedAction.action}`
    );

    if (plannedAction.action === "generate_idea") {
      // ì•„ì´ë””ì–´ ìƒì„±
      const ideas = await getIdeas(teamId);
      const existingIdeas = ideas.map((idea, index) => ({
        ideaNumber: index + 1,
        authorName: idea.author,
        object: idea.content.object,
        function: idea.content.function,
      }));

      // ì—ì´ì „íŠ¸ ë©”ëª¨ë¦¬ ê°€ì ¸ì˜¤ê¸°
      const { getAgentMemory } = await import("@/lib/redis");
      const agentMemory = await getAgentMemory(agentId);

      const generatedContent = await generateIdeaAction(
        team.topic || "Carbon Emission Reduction",
        agentProfile,
        existingIdeas,
        agentMemory || undefined
      );

      const newIdea = await addIdea(teamId, {
        author: agentId,
        timestamp: new Date().toISOString(),
        content: {
          object: generatedContent.object || "ìƒì„±ëœ ì•„ì´ë””ì–´",
          function: generatedContent.function || "ê¸°ëŠ¥ ì„¤ëª…",
          behavior:
            typeof generatedContent.behavior === "object"
              ? JSON.stringify(generatedContent.behavior)
              : generatedContent.behavior || "ë™ì‘ ì„¤ëª…",
          structure:
            typeof generatedContent.structure === "object"
              ? JSON.stringify(generatedContent.structure)
              : generatedContent.structure || "êµ¬ì¡° ì„¤ëª…",
        },
        evaluations: [],
      });

      // ì±„íŒ… ì•Œë¦¼ (ììœ¨ì  í–‰ë™)
      await addChatMessage(teamId, {
        sender: agentId,
        type: "system",
        payload: {
          content: `ìƒˆë¡œìš´ ì•„ì´ë””ì–´ë¥¼ ìƒì„±í–ˆìŠµë‹ˆë‹¤.`,
        },
      });

      // ë©”ëª¨ë¦¬ ì—…ë°ì´íŠ¸ - ììœ¨ì  ì•„ì´ë””ì–´ ìƒì„±
      try {
        await processMemoryUpdate({
          type: "IDEA_GENERATED",
          payload: {
            teamId,
            authorId: agentId,
            idea: newIdea,
            isAutonomous: true, // ììœ¨ì  ìƒì„±
          },
        });
        console.log(
          `âœ… ììœ¨ì  ì•„ì´ë””ì–´ ìƒì„± í›„ ë©”ëª¨ë¦¬ ì—…ë°ì´íŠ¸ ì„±ê³µ: ${agentId} -> idea ${newIdea.id}`
        );
      } catch (memoryError) {
        console.error(
          "âŒ ììœ¨ì  ì•„ì´ë””ì–´ ìƒì„± í›„ ë©”ëª¨ë¦¬ ì—…ë°ì´íŠ¸ ì‹¤íŒ¨:",
          memoryError
        );
      }

      console.log(
        `âœ… ${agentProfile.name} ì•„ì´ë””ì–´ ìƒì„± ì™„ë£Œ:`,
        generatedContent.object
      );
    }

    if (plannedAction.action === "evaluate_idea") {
      // ì•„ì´ë””ì–´ í‰ê°€ - 2ë‹¨ê³„ í”„ë¡¬í”„íŠ¸ ì‚¬ìš©
      const team = await getTeamById(teamId);
      const agentProfile = await getAgentById(agentId);

      if (!team || !agentProfile) {
        console.error(`âŒ ${agentId} íŒ€ ë˜ëŠ” ì—ì´ì „íŠ¸ ì •ë³´ ì—†ìŒ`);
        return;
      }

      const ideas = await getIdeas(teamId);

      if (ideas.length === 0) {
        console.log(`âš ï¸ ${agentProfile.name} í‰ê°€í•  ì•„ì´ë””ì–´ê°€ ì—†ìŒ`);
        return;
      }

      // ë³¸ì¸ì´ ë§Œë“  ì•„ì´ë””ì–´ ì œì™¸
      const otherIdeas = ideas.filter((idea) => idea.author !== agentId);

      if (otherIdeas.length === 0) {
        console.log(
          `âš ï¸ ì—ì´ì „íŠ¸ ${agentId} í‰ê°€í•  ë‹¤ë¥¸ ì‚¬ëŒì˜ ì•„ì´ë””ì–´ê°€ ì—†ìŒ`
        );
        return;
      }

      // ğŸ” ì´ë¯¸ í‰ê°€í•œ ì•„ì´ë””ì–´ ì œì™¸
      const unevaluatedIdeas = otherIdeas.filter((idea) => {
        const hasAlreadyEvaluated = idea.evaluations.some(
          (evaluation) => evaluation.evaluator === agentId
        );
        return !hasAlreadyEvaluated;
      });

      if (unevaluatedIdeas.length === 0) {
        console.log(
          `âš ï¸ ì—ì´ì „íŠ¸ ${agentId} í‰ê°€í•  ìƒˆë¡œìš´ ì•„ì´ë””ì–´ê°€ ì—†ìŒ (ëª¨ë‘ í‰ê°€ ì™„ë£Œ)`
        );
        return;
      }

      // ğŸ¯ ì‹¤ì œ ì•„ì´ë””ì–´ í‰ê°€ ìˆ˜í–‰
      await setAgentState(teamId, agentId, {
        agentId,
        currentState: "action",
        lastStateChange: new Date().toISOString(),
        isProcessing: true,
        currentTask: {
          type: "evaluate_idea",
          description: `ìš”ì²­ë°›ì€ ì•„ì´ë””ì–´ í‰ê°€`,
          startTime: new Date().toISOString(),
          estimatedDuration: 300,
        },
      });

      // ì•„ì´ë””ì–´ í‰ê°€ ìˆ˜í–‰
      const { evaluateIdeaAction } = await import("@/lib/openai");
      const randomIdea =
        unevaluatedIdeas[Math.floor(Math.random() * unevaluatedIdeas.length)];

      console.log(
        `ğŸ“Š ${agentProfile.name} â†’ ${randomIdea.content.object} í‰ê°€ ì‹œì‘`
      );

      try {
        const evaluation = await evaluateIdeaAction(
          randomIdea,
          agentProfile.name
        );

        // í‰ê°€ ì €ì¥
        const response = await fetch(
          `${
            process.env.NEXTAUTH_URL || "http://localhost:3000"
          }/api/teams/${teamId}/ideas/${randomIdea.id}/evaluate`,
          {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              "User-Agent": "TeamBuilder-Internal",
            },
            body: JSON.stringify({
              evaluator: agentId,
              scores: {
                insightful: evaluation.insightful,
                actionable: evaluation.actionable,
                relevance: evaluation.relevance,
              },
              comment: evaluation.comment,
            }),
          }
        );

        if (response.ok) {
          console.log(`âœ… ${agentProfile.name} ì•„ì´ë””ì–´ í‰ê°€ ì™„ë£Œ`);

          // í‰ê°€ ì™„ë£Œ ë©”ì‹œì§€
          await addChatMessage(teamId, {
            sender: agentId,
            type: "system",
            payload: {
              content: `ìš”ì²­ë°›ì€ ì•„ì´ë””ì–´ë¥¼ í‰ê°€í–ˆìŠµë‹ˆë‹¤.`,
            },
          });
        } else {
          console.error(
            `âŒ ${agentProfile.name} í‰ê°€ ì €ì¥ ì‹¤íŒ¨:`,
            response.status
          );
        }
      } catch (evaluationError) {
        console.error(
          `âŒ ${agentProfile.name} í‰ê°€ ìˆ˜í–‰ ì‹¤íŒ¨:`,
          evaluationError
        );
      }

      console.log(`âœ… ì—ì´ì „íŠ¸ ${agentId} ì•„ì´ë””ì–´ í‰ê°€ ìš”ì²­ ì²˜ë¦¬ ì™„ë£Œ`);
    }

    if (plannedAction.action === "give_feedback") {
      // í”¼ë“œë°± ì œê³µ - í”¼ë“œë°± ì„¸ì…˜ìœ¼ë¡œ ì§„í–‰
      console.log(`ğŸ’¬ ${agentProfile.name} í”¼ë“œë°± ì„¸ì…˜ ì‹œì‘ ë¡œì§`);

      const ideas = await getIdeas(teamId);

      if (ideas.length === 0) {
        console.log(`âš ï¸ ${agentProfile.name} í”¼ë“œë°±í•  ì•„ì´ë””ì–´ê°€ ì—†ìŒ`);
        return;
      }

      // ë³¸ì¸ì´ ë§Œë“  ì•„ì´ë””ì–´ ì œì™¸
      const otherIdeas = ideas.filter((idea) => idea.author !== agentId);

      if (otherIdeas.length === 0) {
        console.log(
          `âš ï¸ ${agentProfile.name} í”¼ë“œë°±í•  ë‹¤ë¥¸ ì‚¬ëŒì˜ ì•„ì´ë””ì–´ê°€ ì—†ìŒ`
        );
        return;
      }

      // íŒ€ì˜ ëª¨ë“  ì—ì´ì „íŠ¸ ì •ë³´ ê°€ì ¸ì˜¤ê¸°
      const agents = await Promise.all(
        (team?.members || [])
          .filter((m) => !m.isUser && m.agentId)
          .map((m) => getAgentById(m.agentId!))
      );
      const validAgents = agents.filter((agent) => agent !== null);

      // í”¼ë“œë°± ê°€ëŠ¥í•œ ë‹¤ë¥¸ íŒ€ì›ë“¤ ì°¾ê¸° (ë³¸ì¸ ì œì™¸)
      const otherMembers = team.members.filter(
        (member) => !member.isUser && member.agentId !== agentId
      );

      if (otherMembers.length === 0) {
        console.log(`âš ï¸ ${agentProfile.name} í”¼ë“œë°±í•  ë‹¤ë¥¸ íŒ€ì›ì´ ì—†ìŒ`);
        return;
      }

      // ëœë¤í•˜ê²Œ í”¼ë“œë°± ëŒ€ìƒ ì„ íƒ
      const targetMember =
        otherMembers[Math.floor(Math.random() * otherMembers.length)];
      const targetAgent = validAgents.find(
        (a: any) => a.id === targetMember.agentId
      );

      if (!targetAgent) {
        console.log(`âš ï¸ ${agentProfile.name} ëŒ€ìƒ ì—ì´ì „íŠ¸ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŒ`);
        return;
      }

      console.log(
        `ğŸ¯ ${agentProfile.name} â†’ ${targetAgent.name} í”¼ë“œë°± ì„¸ì…˜ ìƒì„±`
      );

      // ë½ í‚¤ ìƒì„± (ì‘ì€ IDê°€ ë¨¼ì € ì˜¤ë„ë¡ ì •ë ¬)
      const lockKey = `feedback_lock:${[agentId, targetAgent.id]
        .sort()
        .join(":")}`;

      // ë¶„ì‚° ë½ ì‚¬ìš©
      const lockAcquired = await redis.set(lockKey, "locked", {
        ex: 30, // 30ì´ˆ TTL
        nx: true, // í‚¤ê°€ ì¡´ì¬í•˜ì§€ ì•Šì„ ë•Œë§Œ ì„¤ì •
      });

      if (!lockAcquired) {
        console.log(
          `âš ï¸ ${agentProfile.name} â†’ ${targetAgent.name} í”¼ë“œë°± ì„¸ì…˜ ë½ íšë“ ì‹¤íŒ¨ (ì´ë¯¸ ì§„í–‰ ì¤‘)`
        );
        return;
      }

      try {
        // í”¼ë“œë°± ì„¸ì…˜ ìƒì„± API í˜¸ì¶œ
        const baseUrl = process.env.NEXTAUTH_URL || `http://localhost:3000`;
        const sessionResponse = await fetch(
          `${baseUrl}/api/teams/${teamId}/feedback-sessions`,
          {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              "User-Agent": "TeamBuilder-Internal",
            },
            body: JSON.stringify({
              action: "create",
              initiatorId: agentId,
              targetAgentId: targetAgent.id,
              message: `${agentProfile.name}ì´ í”¼ë“œë°±ì„ ì œê³µí•˜ê³  ì‹¶ì–´í•©ë‹ˆë‹¤.`,
              feedbackContext: {
                type: "general_feedback",
                initiatedBy: "ai",
                description: "ì¼ë°˜ì ì¸ í˜‘ì—…ê³¼ íŒ€ì›Œí¬ì— ëŒ€í•œ í”¼ë“œë°±",
              },
            }),
          }
        );

        if (sessionResponse.ok) {
          const sessionData = await sessionResponse.json();
          console.log(
            `âœ… ${agentProfile.name} â†’ ${targetAgent.name} í”¼ë“œë°± ì„¸ì…˜ ìƒì„± ì„±ê³µ: ${sessionData.sessionId}`
          );

          // ğŸ”„ í”¼ë“œë°± ì„¸ì…˜ ìƒì„± ì¦‰ì‹œ ì–‘ìª½ ì—ì´ì „íŠ¸ ìƒíƒœ ë³€ê²½
          // 1. í”¼ë“œë°± ì œê³µì(í˜„ì¬ ì—ì´ì „íŠ¸) ìƒíƒœ ë³€ê²½
          try {
            const initiatorResponse = await fetch(
              `${baseUrl}/api/teams/${teamId}/agent-states`,
              {
                method: "POST",
                headers: {
                  "Content-Type": "application/json",
                  "User-Agent": "TeamBuilder-Internal",
                },
                body: JSON.stringify({
                  agentId: agentId,
                  currentState: "feedback_session",
                  taskType: "feedback_session",
                  taskDescription: `${targetAgent.name}ì™€ í”¼ë“œë°± ì„¸ì…˜ ì§„í–‰ ì¤‘`,
                  estimatedDuration: 300,
                  trigger: "autonomous",
                  sessionInfo: {
                    sessionId: sessionData.sessionId,
                    participants: [agentProfile.name, targetAgent.name],
                  },
                }),
              }
            );

            if (initiatorResponse.ok) {
              console.log(
                `âœ… ${agentProfile.name} ìƒíƒœê°€ feedback_sessionìœ¼ë¡œ ë³€ê²½ë¨`
              );
            } else {
              console.error(
                `âŒ ${agentProfile.name} feedback_session ìƒíƒœ ë³€ê²½ ì‹¤íŒ¨:`,
                initiatorResponse.status
              );
            }
          } catch (error) {
            console.error(
              `âŒ ${agentProfile.name} feedback_session ìƒíƒœ ë³€ê²½ ì˜¤ë¥˜:`,
              error
            );
          }

          // 2. í”¼ë“œë°± ëŒ€ìƒì(íƒ€ê²Ÿ ì—ì´ì „íŠ¸) ìƒíƒœ ë³€ê²½ (ì¸ê°„ì´ ì•„ë‹Œ ê²½ìš°ë§Œ)
          if (targetAgent.name !== "ë‚˜") {
            try {
              const targetResponse = await fetch(
                `${baseUrl}/api/teams/${teamId}/agent-states`,
                {
                  method: "POST",
                  headers: {
                    "Content-Type": "application/json",
                    "User-Agent": "TeamBuilder-Internal",
                  },
                  body: JSON.stringify({
                    agentId: targetAgent.id,
                    currentState: "feedback_session",
                    taskType: "feedback_session",
                    taskDescription: `${agentProfile.name}ì™€ í”¼ë“œë°± ì„¸ì…˜ ì§„í–‰ ì¤‘`,
                    estimatedDuration: 300,
                    trigger: "autonomous",
                    sessionInfo: {
                      sessionId: sessionData.sessionId,
                      participants: [agentProfile.name, targetAgent.name],
                    },
                  }),
                }
              );

              if (targetResponse.ok) {
                console.log(
                  `âœ… ${targetAgent.name} ìƒíƒœê°€ feedback_sessionìœ¼ë¡œ ë³€ê²½ë¨`
                );
              } else {
                console.error(
                  `âŒ ${targetAgent.name} feedback_session ìƒíƒœ ë³€ê²½ ì‹¤íŒ¨:`,
                  targetResponse.status
                );
              }
            } catch (error) {
              console.error(
                `âŒ ${targetAgent.name} feedback_session ìƒíƒœ ë³€ê²½ ì˜¤ë¥˜:`,
                error
              );
            }
          }

          // ì¸ê°„ì—ê²Œ í”¼ë“œë°±í•˜ëŠ” ê²½ìš° ì¦‰ì‹œ ì²« ë©”ì‹œì§€ ìƒì„±
          const isTargetHuman = targetAgent.name === "ë‚˜";
          const delay = isTargetHuman ? 1000 : 3000; // ì¸ê°„ì—ê²ŒëŠ” 1ì´ˆ í›„, AIì—ê²ŒëŠ” 3ì´ˆ í›„

          setTimeout(async () => {
            try {
              const aiProcessResponse = await fetch(
                `${baseUrl}/api/teams/${teamId}/feedback-sessions/${sessionData.sessionId}/ai-process`,
                {
                  method: "POST",
                  headers: {
                    "Content-Type": "application/json",
                    "User-Agent": "TeamBuilder-Internal",
                  },
                  body: JSON.stringify({
                    triggerAgentId: agentId,
                    action: "respond",
                  }),
                }
              );

              if (aiProcessResponse.ok) {
                console.log(
                  `âœ… ${agentProfile.name} ì²« í”¼ë“œë°± ë©”ì‹œì§€ ìƒì„± íŠ¸ë¦¬ê±° ì„±ê³µ (ëŒ€ìƒ: ${targetAgent.name})`
                );
              } else {
                console.error(
                  `âŒ ${agentProfile.name} ì²« í”¼ë“œë°± ë©”ì‹œì§€ ìƒì„± íŠ¸ë¦¬ê±° ì‹¤íŒ¨:`,
                  aiProcessResponse.status
                );
              }
            } catch (error) {
              console.error(
                `âŒ ${agentProfile.name} ì²« í”¼ë“œë°± ë©”ì‹œì§€ ìƒì„± íŠ¸ë¦¬ê±° ì˜¤ë¥˜:`,
                error
              );
            }
          }, delay);
        } else {
          const errorData = await sessionResponse.json();
          console.error(
            `âŒ ${agentProfile.name} â†’ ${targetAgent.name} í”¼ë“œë°± ì„¸ì…˜ ìƒì„± ì‹¤íŒ¨:`,
            errorData
          );
        }
      } finally {
        // ë½ í•´ì œ
        await redis.del(lockKey);
        console.log(`ğŸ”“ ${agentProfile.name} â†’ ${targetAgent.name} ë½ í•´ì œ`);
      }
    }

    if (plannedAction.action === "wait") {
      // ëŒ€ê¸° ì•¡ì…˜ - ë°”ë¡œ idle ìƒíƒœë¡œ ì „í™˜
      console.log(`ğŸ˜´ ${agentProfile.name} ëŒ€ê¸° ì•¡ì…˜ ì„ íƒ - idle ìƒíƒœë¡œ ì „í™˜`);

      // 2ì´ˆ í›„ idle ìƒíƒœë¡œ ì „í™˜
      setTimeout(async () => {
        try {
          // ğŸ” í”¼ë“œë°± ì„¸ì…˜ ì¤‘ì¸ì§€ í™•ì¸
          const currentState = await getAgentState(teamId, agentId);
          if (currentState && isFeedbackSessionActive(currentState)) {
            console.log(
              `ğŸ”’ ì—ì´ì „íŠ¸ ${agentId}ëŠ” í”¼ë“œë°± ì„¸ì…˜ ì¤‘ì´ë¯€ë¡œ wait í›„ idle ì „í™˜ ìŠ¤í‚µ`
            );
            return;
          }

          console.log(
            `ğŸ˜´ ì—ì´ì „íŠ¸ ${agentId} â†’ Wait í›„ Idle ìƒíƒœ ì „í™˜ ì‹œë„ ì¤‘...`
          );
          const baseUrl = process.env.NEXTAUTH_URL || `http://localhost:3000`;
          const response = await fetch(
            `${baseUrl}/api/teams/${teamId}/agent-states`,
            {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
                "User-Agent": "TeamBuilder-Internal",
              },
              body: JSON.stringify({
                agentId,
                currentState: "idle",
              }),
            }
          );

          if (response.ok) {
            console.log(`ğŸ˜´ ì—ì´ì „íŠ¸ ${agentId} â†’ Wait í›„ Idle ìƒíƒœ ì „í™˜ ì™„ë£Œ`);
          } else {
            const errorText = await response.text();
            console.error(
              `âŒ ì—ì´ì „íŠ¸ ${agentId} Wait í›„ Idle ì „í™˜ ì‹¤íŒ¨:`,
              response.status,
              errorText
            );
          }
        } catch (e) {
          console.error(`âŒ ì—ì´ì „íŠ¸ ${agentId} Wait í›„ Idle ì „í™˜ ì‹¤íŒ¨:`, e);
        }
      }, 2000);

      return; // wait ì•¡ì…˜ì€ ì—¬ê¸°ì„œ ì¢…ë£Œ
    }
  } catch (error) {
    console.error(`âŒ ${agentId} ì‘ì—… ì‹¤í–‰ ì‹¤íŒ¨:`, error);

    // ğŸ” ì‹¤íŒ¨ ì‹œì—ë„ í”¼ë“œë°± ì„¸ì…˜ ì¤‘ì¸ì§€ í™•ì¸
    const currentState = await getAgentState(teamId, agentId);
    if (currentState && isFeedbackSessionActive(currentState)) {
      console.log(
        `ğŸ”’ ì—ì´ì „íŠ¸ ${agentId}ëŠ” í”¼ë“œë°± ì„¸ì…˜ ì¤‘ì´ë¯€ë¡œ ì‹¤íŒ¨ í›„ì—ë„ idle ì „í™˜ ìŠ¤í‚µ`
      );
      return;
    }

    // ì‹¤íŒ¨ ì‹œì—ë„ idle ìƒíƒœë¡œ ì „í™˜ (í”¼ë“œë°± ì„¸ì…˜ ì¤‘ì´ ì•„ë‹Œ ê²½ìš°ë§Œ)
    setTimeout(async () => {
      try {
        // ë‹¤ì‹œ í•œë²ˆ í”¼ë“œë°± ì„¸ì…˜ ìƒíƒœ í™•ì¸
        const finalState = await getAgentState(teamId, agentId);
        if (finalState && isFeedbackSessionActive(finalState)) {
          console.log(
            `ğŸ”’ ì—ì´ì „íŠ¸ ${agentId}ëŠ” ì—¬ì „íˆ í”¼ë“œë°± ì„¸ì…˜ ì¤‘ì´ë¯€ë¡œ ì‹¤íŒ¨ í›„ì—ë„ idle ì „í™˜ ìŠ¤í‚µ`
          );
          return;
        }

        console.log(
          `ğŸ˜´ ì—ì´ì „íŠ¸ ${agentId} â†’ ì‹¤íŒ¨ í›„ Idle ìƒíƒœ ì „í™˜ ì‹œë„ ì¤‘...`
        );
        const baseUrl = process.env.NEXTAUTH_URL || `http://localhost:3000`;
        const response = await fetch(
          `${baseUrl}/api/teams/${teamId}/agent-states`,
          {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              "User-Agent": "TeamBuilder-Internal",
            },
            body: JSON.stringify({
              agentId,
              currentState: "idle",
            }),
          }
        );

        if (response.ok) {
          console.log(`ğŸ˜´ ì—ì´ì „íŠ¸ ${agentId} â†’ ì‹¤íŒ¨ í›„ Idle ìƒíƒœ ì „í™˜ ì™„ë£Œ`);
        } else {
          const errorText = await response.text();
          console.error(
            `âŒ ì—ì´ì „íŠ¸ ${agentId} ì‹¤íŒ¨ í›„ Idle ì „í™˜ ì‹¤íŒ¨:`,
            response.status,
            errorText
          );
        }
      } catch (e) {
        console.error(`âŒ ì—ì´ì „íŠ¸ ${agentId} ì‹¤íŒ¨ í›„ Idle ì „í™˜ ì‹¤íŒ¨:`, e);
      }
    }, 2000);
  }
}

export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ teamId: string }> }
) {
  try {
    const { teamId } = await params;

    // íŒ€ ì •ë³´ ê°€ì ¸ì˜¤ê¸°
    const team = await getTeamById(teamId);
    if (!team) {
      return NextResponse.json(
        { error: "íŒ€ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤." },
        { status: 404 }
      );
    }

    // ëª¨ë“  ì—ì´ì „íŠ¸ ìƒíƒœë¥¼ ë³‘ë ¬ë¡œ ì¡°íšŒ ë° ì²˜ë¦¬
    const agentStatePromises = team.members
      .filter((member) => !member.isUser && member.agentId)
      .map(async (member) => {
        try {
          let state = await getAgentState(teamId, member.agentId!);

          // ìƒíƒœê°€ ìˆìœ¼ë©´ íƒ€ì´ë¨¸ ì—…ë°ì´íŠ¸ ì‹¤í–‰
          if (state) {
            const updatedState = await updateAgentStateTimer(teamId, state);
            // ì—…ë°ì´íŠ¸ëœ ìƒíƒœë¥¼ Redisì— ì €ì¥
            await setAgentState(teamId, member.agentId!, updatedState);
            state = updatedState;
          }

          const agent = await getAgentById(member.agentId!);
          return {
            agentId: member.agentId!,
            name: agent?.name || member.agentId!,
            state: state || null,
            isFeedbackSession: state ? isFeedbackSessionActive(state) : false,
          };
        } catch (error) {
          console.error(`âŒ ì—ì´ì „íŠ¸ ${member.agentId} ìƒíƒœ ì¡°íšŒ ì‹¤íŒ¨:`, error);
          return {
            agentId: member.agentId!,
            name: member.agentId!,
            state: null,
            isFeedbackSession: false,
          };
        }
      });

    // í™œì„± í”¼ë“œë°± ì„¸ì…˜ ì¡°íšŒì™€ ì‚¬ìš©ì ìƒíƒœ ì¡°íšŒë„ ë³‘ë ¬ë¡œ ì²˜ë¦¬
    const [agentStates, activeSessions, userStateData] = await Promise.all([
      Promise.all(agentStatePromises),
      redis.keys("feedback_session:*"),
      redis.get(`team:${teamId}:user_state`),
    ]);

    // í™œì„± í”¼ë“œë°± ì„¸ì…˜ ì •ë³´ ì²˜ë¦¬
    const sessionInfoPromises = activeSessions.map(async (sessionKey) => {
      try {
        const sessionData = await redis.get(sessionKey);
        if (sessionData) {
          const session =
            typeof sessionData === "string"
              ? JSON.parse(sessionData)
              : sessionData;
          return {
            sessionId: session.id,
            status: session.status,
            participants: session.participants.map((p: any) => ({
              id: p.id,
              name: p.name,
              isUser: p.isUser,
            })),
            createdAt: session.createdAt,
            endedAt: session.endedAt,
          };
        }
        return null;
      } catch (error) {
        console.error(`âŒ ì„¸ì…˜ ${sessionKey} ì¡°íšŒ ì‹¤íŒ¨:`, error);
        return null;
      }
    });

    const sessionInfo = (await Promise.all(sessionInfoPromises)).filter(
      Boolean
    );

    // ì¸ê°„ ì‚¬ìš©ì ìƒíƒœ ì²˜ë¦¬
    const userState = userStateData
      ? typeof userStateData === "string"
        ? JSON.parse(userStateData)
        : userStateData
      : null;

    return NextResponse.json({
      teamId,
      agentStates,
      activeFeedbackSessions: sessionInfo,
      userState,
      timestamp: new Date().toISOString(),
    });
  } catch (error) {
    console.error("ì—ì´ì „íŠ¸ ìƒíƒœ ì¡°íšŒ ì‹¤íŒ¨:", error);
    return NextResponse.json(
      { error: "ìƒíƒœ ì¡°íšŒì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤." },
      { status: 500 }
    );
  }
}

// ì—ì´ì „íŠ¸ ìƒíƒœ ì—…ë°ì´íŠ¸ë¥¼ ìœ„í•œ POST ë©”ì„œë“œ
export async function POST(
  request: NextRequest,
  { params }: { params: Promise<{ teamId: string }> }
) {
  try {
    const { teamId } = await params;
    const body = await request.json();
    const {
      agentId,
      currentState,
      taskType,
      taskDescription,
      estimatedDuration,
      trigger = "autonomous",
      plannedAction,
      sessionInfo,
      forceClear = false, // ê°•ì œ ì´ˆê¸°í™” í”Œë˜ê·¸ ì¶”ê°€
      action, // ìƒˆë¡œìš´ í•„ë“œ: ìš”ì²­ ì²˜ë¦¬ìš©
      requestData, // ìƒˆë¡œìš´ í•„ë“œ: ìš”ì²­ ë°ì´í„°
      requestInfo, // ìš”ì²­ ì •ë³´ í•„ë“œ ì¶”ê°€
    } = body;

    console.log(`ğŸ“‹ ì—ì´ì „íŠ¸ ${agentId} ìƒíƒœ ë³€ê²½ ìš”ì²­:`, {
      currentState,
      taskType,
      forceClear,
    });

    // forceClearê°€ trueì´ë©´ ëª¨ë“  ì²´í¬ë¥¼ ë¬´ì‹œí•˜ê³  ê°•ì œë¡œ ìƒíƒœ ë³€ê²½
    if (forceClear && currentState === "idle") {
      console.log(`ğŸ”§ ì—ì´ì „íŠ¸ ${agentId} ê°•ì œ idle ìƒíƒœ ì´ˆê¸°í™”`);

      const forcedState: AgentStateInfo = {
        agentId,
        currentState: "idle",
        lastStateChange: new Date().toISOString(),
        isProcessing: false,
        idleTimer: createNewIdleTimer(),
      };

      await setAgentState(teamId, agentId, forcedState);

      console.log(`âœ… ì—ì´ì „íŠ¸ ${agentId} ê°•ì œ idle ìƒíƒœ ì´ˆê¸°í™” ì™„ë£Œ`);

      return NextResponse.json({
        success: true,
        message: "ì—ì´ì „íŠ¸ ìƒíƒœê°€ ê°•ì œë¡œ idleë¡œ ì´ˆê¸°í™”ë˜ì—ˆìŠµë‹ˆë‹¤",
        state: forcedState,
      });
    }

    // ë‹¤ë¥¸ ì•¡ì…˜ë“¤ì€ agentIdê°€ í•„ìš”í•¨
    if (!agentId) {
      return NextResponse.json(
        { error: "agentIdê°€ í•„ìš”í•©ë‹ˆë‹¤." },
        { status: 400 }
      );
    }

    // ìš”ì²­ ì²˜ë¦¬ ì•¡ì…˜ì¸ ê²½ìš°
    if (action === "process_request" && requestData) {
      console.log(`ğŸ“¨ ì—ì´ì „íŠ¸ ${agentId}ì—ê²Œ ìš”ì²­ ì²˜ë¦¬: ${requestData.type}`);
      console.log(`ìš”ì²­ ìƒì„¸ ì •ë³´:`, JSON.stringify(requestData, null, 2));

      // í˜„ì¬ ì—ì´ì „íŠ¸ ìƒíƒœ í™•ì¸
      const currentAgentState = await getAgentState(teamId, agentId);
      console.log(
        `í˜„ì¬ ì—ì´ì „íŠ¸ ìƒíƒœ:`,
        JSON.stringify(currentAgentState, null, 2)
      );

      // ì—ì´ì „íŠ¸ ìƒíƒœê°€ ì—†ëŠ” ê²½ìš°
      if (!currentAgentState) {
        console.error(`âŒ ì—ì´ì „íŠ¸ ${agentId} ìƒíƒœë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.`);
        return NextResponse.json(
          { error: "ì—ì´ì „íŠ¸ ìƒíƒœë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤." },
          { status: 404 }
        );
      }

      // í”¼ë“œë°± ì„¸ì…˜ ì¤‘ì¸ì§€ í™•ì¸
      if (isFeedbackSessionActive(currentAgentState)) {
        console.log(
          `âš ï¸ ì—ì´ì „íŠ¸ ${agentId}ê°€ í”¼ë“œë°± ì„¸ì…˜ ì¤‘ì´ë¯€ë¡œ ìš”ì²­ ì²˜ë¦¬ ë¶ˆê°€`
        );
        return NextResponse.json(
          {
            error: "ì—ì´ì „íŠ¸ê°€ í˜„ì¬ í”¼ë“œë°± ì„¸ì…˜ì— ì°¸ì—¬ ì¤‘ì…ë‹ˆë‹¤.",
            agentState: currentAgentState,
          },
          { status: 409 }
        );
      }

      // ë°±ê·¸ë¼ìš´ë“œì—ì„œ ìš”ì²­ ì²˜ë¦¬
      processRequestInBackground(teamId, agentId, requestData);

      return NextResponse.json({
        message: "ìš”ì²­ì´ ì²˜ë¦¬ ì¤‘ì…ë‹ˆë‹¤.",
        agentId,
        requestType: requestData.type,
      });
    }

    const now = new Date();
    let newState: AgentStateInfo;

    if (currentState === "idle") {
      // idle ìƒíƒœë¡œ ì „í™˜ ì‹œ í í™•ì¸
      const queueKey = `agent_queue:${teamId}:${agentId}`;
      const queuedRequest = await redis.rpop(queueKey);

      // ë””ë²„ê¹…ì„ ìœ„í•œ ìƒì„¸ ë¡œê¹…
      console.log(`ğŸ” í í™•ì¸ ê²°ê³¼:`, {
        agentId,
        queueKey,
        queuedRequest,
        queuedRequestType: typeof queuedRequest,
        queuedRequestIsNull: queuedRequest === null,
      });

      if (queuedRequest && queuedRequest !== null) {
        // íì— ëŒ€ê¸° ì¤‘ì¸ ìš”ì²­ì´ ìˆìœ¼ë©´ ì¦‰ì‹œ ì²˜ë¦¬
        console.log(`ğŸ“‹ ì—ì´ì „íŠ¸ ${agentId} íì—ì„œ ìš”ì²­ ë°œê²¬ - ì¦‰ì‹œ ì²˜ë¦¬`);

        // Redisì—ì„œ ê°€ì ¸ì˜¨ ë°ì´í„°ê°€ ì´ë¯¸ ê°ì²´ì¼ ìˆ˜ ìˆìœ¼ë¯€ë¡œ íƒ€ì… í™•ì¸
        let requestData;
        try {
          if (typeof queuedRequest === "string") {
            requestData = JSON.parse(queuedRequest);
          } else if (
            typeof queuedRequest === "object" &&
            queuedRequest !== null
          ) {
            requestData = queuedRequest;
          } else {
            throw new Error(
              `ì˜ˆìƒí•˜ì§€ ëª»í•œ í ë°ì´í„° íƒ€ì…: ${typeof queuedRequest}`
            );
          }

          // requestData ìœ íš¨ì„± ê²€ì‚¬
          if (!requestData || typeof requestData !== "object") {
            throw new Error("ìœ íš¨í•˜ì§€ ì•Šì€ ìš”ì²­ ë°ì´í„°");
          }
        } catch (parseError) {
          console.error(
            `âŒ ì—ì´ì „íŠ¸ ${agentId} í ë°ì´í„° íŒŒì‹± ì‹¤íŒ¨:`,
            parseError
          );
          console.error(`í ë°ì´í„° ìƒì„¸:`, {
            queuedRequest,
            type: typeof queuedRequest,
            isNull: queuedRequest === null,
            isUndefined: queuedRequest === undefined,
          });

          // íŒŒì‹± ì‹¤íŒ¨ ì‹œ ê¸°ë³¸ idle ìƒíƒœë¡œ
          newState = {
            agentId,
            currentState: "idle",
            lastStateChange: now.toISOString(),
            isProcessing: false,
            idleTimer: createNewIdleTimer(),
          };
          await setAgentState(teamId, agentId, newState);
          return NextResponse.json({
            success: true,
            message: "í ë°ì´í„° íŒŒì‹± ì‹¤íŒ¨ë¡œ idle ìƒíƒœë¡œ ì „í™˜ë˜ì—ˆìŠµë‹ˆë‹¤.",
            state: newState,
          });
        }

        newState = {
          agentId,
          currentState: "action",
          lastStateChange: now.toISOString(),
          isProcessing: true,
          currentTask: {
            type:
              requestData.type === "evaluate_idea"
                ? "evaluate_idea"
                : "thinking",
            description: `${requestData.requesterName}ì˜ ìš”ì²­: ${
              requestData.payload?.message || "ìš”ì²­ ì²˜ë¦¬"
            }`,
            startTime: now.toISOString(),
            estimatedDuration: 30,
            trigger: "user_request",
            requestInfo: {
              requesterName: requestData.requesterName,
              requestMessage: requestData.payload?.message || "",
            },
          },
        };

        // ë°±ê·¸ë¼ìš´ë“œì—ì„œ ìš”ì²­ ì²˜ë¦¬
        processRequestInBackground(teamId, agentId, requestData);
      } else {
        // íê°€ ë¹„ì–´ìˆìœ¼ë©´ ì¼ë°˜ idle ìƒíƒœ
        newState = {
          agentId,
          currentState: "idle",
          lastStateChange: now.toISOString(),
          isProcessing: false,
          idleTimer: createNewIdleTimer(),
        };
      }
    } else if (currentState === "plan" || currentState === "action") {
      // ì‘ì—… ìƒíƒœë¡œ ì „í™˜
      newState = {
        agentId,
        currentState,
        lastStateChange: now.toISOString(),
        isProcessing: true,
        currentTask: {
          type: taskType || "thinking",
          description: taskDescription || "ì‘ì—…ì„ ìˆ˜í–‰í•˜ê³  ìˆìŠµë‹ˆë‹¤",
          startTime: now.toISOString(),
          estimatedDuration: estimatedDuration || 60,
          trigger: trigger || "autonomous",
          requestInfo: requestInfo,
        },
      };
    } else if (currentState === "feedback_session") {
      // í”¼ë“œë°± ì„¸ì…˜ ìƒíƒœë¡œ ì „í™˜
      newState = {
        agentId,
        currentState: "feedback_session",
        lastStateChange: now.toISOString(),
        isProcessing: true,
        currentTask: {
          type: "feedback_session",
          description: taskDescription || "í”¼ë“œë°± ì„¸ì…˜ ì§„í–‰ ì¤‘",
          startTime: now.toISOString(),
          estimatedDuration: estimatedDuration || 300, // 5ë¶„ ê¸°ë³¸ê°’
          trigger: trigger || "user_request",
          requestInfo: requestInfo,
          sessionInfo: sessionInfo,
        },
      };
    } else if (currentState === "reflecting") {
      // íšŒê³  ìƒíƒœë¡œ ì „í™˜
      newState = {
        agentId,
        currentState: "reflecting",
        lastStateChange: now.toISOString(),
        isProcessing: true,
        currentTask: {
          type: "reflecting",
          description: taskDescription || "ê²½í—˜ì„ ë°”íƒ•ìœ¼ë¡œ ìê¸° ì„±ì°° ì¤‘",
          startTime: now.toISOString(),
          estimatedDuration: estimatedDuration || 10,
          trigger: "autonomous",
          requestInfo: requestInfo,
        },
      };
    } else {
      return NextResponse.json(
        { error: "ìœ íš¨í•˜ì§€ ì•Šì€ ìƒíƒœì…ë‹ˆë‹¤." },
        { status: 400 }
      );
    }

    // Redisì— ìƒíƒœ ì €ì¥
    await setAgentState(teamId, agentId, newState);

    return NextResponse.json({
      success: true,
      message: "ì—ì´ì „íŠ¸ ìƒíƒœê°€ ì—…ë°ì´íŠ¸ë˜ì—ˆìŠµë‹ˆë‹¤.",
      state: newState,
    });
  } catch (error) {
    console.error("ì—ì´ì „íŠ¸ ìƒíƒœ ì—…ë°ì´íŠ¸ ì‹¤íŒ¨:", error);
    return NextResponse.json(
      { error: "ìƒíƒœ ì—…ë°ì´íŠ¸ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤." },
      { status: 500 }
    );
  }
}

// ë°±ê·¸ë¼ìš´ë“œì—ì„œ ìš”ì²­ ì²˜ë¦¬í•˜ëŠ” í•¨ìˆ˜
async function processRequestInBackground(
  teamId: string,
  agentId: string,
  requestData: any
) {
  try {
    console.log(
      `ğŸ”§ ì—ì´ì „íŠ¸ ${agentId} ë°±ê·¸ë¼ìš´ë“œ ìš”ì²­ ì²˜ë¦¬ ì‹œì‘: ${requestData.type}`
    );

    if (requestData.type === "evaluate_idea") {
      // ì•„ì´ë””ì–´ í‰ê°€ ìš”ì²­ ì²˜ë¦¬
      await handleEvaluateIdeaRequestDirect(teamId, agentId, requestData);
    } else if (requestData.type === "generate_idea") {
      // ì•„ì´ë””ì–´ ìƒì„± ìš”ì²­ ì²˜ë¦¬
      await handleGenerateIdeaRequestDirect(teamId, agentId, requestData);
    } else if (requestData.type === "give_feedback") {
      // í”¼ë“œë°± ìš”ì²­ ì²˜ë¦¬
      await handleGiveFeedbackRequestDirect(teamId, agentId, requestData);
    }

    console.log(`âœ… ì—ì´ì „íŠ¸ ${agentId} ìš”ì²­ ì²˜ë¦¬ ì™„ë£Œ`);

    // ğŸ” í”¼ë“œë°± ì„¸ì…˜ ì¤‘ì¸ì§€ í™•ì¸ í›„ ìƒíƒœ ì „í™˜ ê²°ì •
    const currentState = await getAgentState(teamId, agentId);
    if (currentState && isFeedbackSessionActive(currentState)) {
      console.log(
        `ğŸ”’ ì—ì´ì „íŠ¸ ${agentId}ëŠ” í”¼ë“œë°± ì„¸ì…˜ ì¤‘ì´ë¯€ë¡œ idle ì „í™˜ ìŠ¤í‚µ`
      );
      return; // í”¼ë“œë°± ì„¸ì…˜ ì¤‘ì´ë©´ idleë¡œ ì „í™˜í•˜ì§€ ì•ŠìŒ
    }

    // ì²˜ë¦¬ ì™„ë£Œ í›„ idle ìƒíƒœë¡œ ì „í™˜ (í”¼ë“œë°± ì„¸ì…˜ ì¤‘ì´ ì•„ë‹Œ ê²½ìš°ë§Œ)
    setTimeout(async () => {
      try {
        // ë‹¤ì‹œ í•œë²ˆ í”¼ë“œë°± ì„¸ì…˜ ìƒíƒœ í™•ì¸ (ìƒíƒœê°€ ë³€ê²½ë  ìˆ˜ ìˆìŒ)
        const finalState = await getAgentState(teamId, agentId);
        if (finalState && isFeedbackSessionActive(finalState)) {
          console.log(
            `ğŸ”’ ì—ì´ì „íŠ¸ ${agentId}ëŠ” ì—¬ì „íˆ í”¼ë“œë°± ì„¸ì…˜ ì¤‘ì´ë¯€ë¡œ idle ì „í™˜ ìŠ¤í‚µ`
          );
          return;
        }

        console.log(`ğŸ˜´ ì—ì´ì „íŠ¸ ${agentId} â†’ Idle ìƒíƒœ ì „í™˜ ì‹œë„ ì¤‘...`);
        const baseUrl = process.env.NEXTAUTH_URL || `http://localhost:3000`;
        const response = await fetch(
          `${baseUrl}/api/teams/${teamId}/agent-states`,
          {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              "User-Agent": "TeamBuilder-Internal",
            },
            body: JSON.stringify({
              agentId,
              currentState: "idle",
            }),
          }
        );

        if (response.ok) {
          console.log(`ğŸ˜´ ì—ì´ì „íŠ¸ ${agentId} â†’ Idle ìƒíƒœ ì „í™˜ ì™„ë£Œ`);
        } else {
          const errorText = await response.text();
          console.error(
            `âŒ ì—ì´ì „íŠ¸ ${agentId} Idle ì „í™˜ ì‹¤íŒ¨:`,
            response.status,
            errorText
          );
        }
      } catch (error) {
        console.error(`âŒ ì—ì´ì „íŠ¸ ${agentId} Idle ì „í™˜ ì‹¤íŒ¨:`, error);
      }
    }, 2000); // 2ì´ˆ í›„ idleë¡œ ì „í™˜
  } catch (error) {
    console.error(`âŒ ì—ì´ì „íŠ¸ ${agentId} ë°±ê·¸ë¼ìš´ë“œ ìš”ì²­ ì²˜ë¦¬ ì‹¤íŒ¨:`, error);

    // ğŸ” ì‹¤íŒ¨ ì‹œì—ë„ í”¼ë“œë°± ì„¸ì…˜ ì¤‘ì¸ì§€ í™•ì¸
    const currentState = await getAgentState(teamId, agentId);
    if (currentState && isFeedbackSessionActive(currentState)) {
      console.log(
        `ğŸ”’ ì—ì´ì „íŠ¸ ${agentId}ëŠ” í”¼ë“œë°± ì„¸ì…˜ ì¤‘ì´ë¯€ë¡œ ì‹¤íŒ¨ í›„ì—ë„ idle ì „í™˜ ìŠ¤í‚µ`
      );
      return;
    }

    // ì‹¤íŒ¨ ì‹œì—ë„ idle ìƒíƒœë¡œ ì „í™˜ (í”¼ë“œë°± ì„¸ì…˜ ì¤‘ì´ ì•„ë‹Œ ê²½ìš°ë§Œ)
    setTimeout(async () => {
      try {
        // ë‹¤ì‹œ í•œë²ˆ í”¼ë“œë°± ì„¸ì…˜ ìƒíƒœ í™•ì¸
        const finalState = await getAgentState(teamId, agentId);
        if (finalState && isFeedbackSessionActive(finalState)) {
          console.log(
            `ğŸ”’ ì—ì´ì „íŠ¸ ${agentId}ëŠ” ì—¬ì „íˆ í”¼ë“œë°± ì„¸ì…˜ ì¤‘ì´ë¯€ë¡œ ì‹¤íŒ¨ í›„ì—ë„ idle ì „í™˜ ìŠ¤í‚µ`
          );
          return;
        }

        console.log(
          `ğŸ˜´ ì—ì´ì „íŠ¸ ${agentId} â†’ ì‹¤íŒ¨ í›„ Idle ìƒíƒœ ì „í™˜ ì‹œë„ ì¤‘...`
        );
        const baseUrl = process.env.NEXTAUTH_URL || `http://localhost:3000`;
        const response = await fetch(
          `${baseUrl}/api/teams/${teamId}/agent-states`,
          {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              "User-Agent": "TeamBuilder-Internal",
            },
            body: JSON.stringify({
              agentId,
              currentState: "idle",
            }),
          }
        );

        if (response.ok) {
          console.log(`ğŸ˜´ ì—ì´ì „íŠ¸ ${agentId} â†’ ì‹¤íŒ¨ í›„ Idle ìƒíƒœ ì „í™˜ ì™„ë£Œ`);
        } else {
          const errorText = await response.text();
          console.error(
            `âŒ ì—ì´ì „íŠ¸ ${agentId} ì‹¤íŒ¨ í›„ Idle ì „í™˜ ì‹¤íŒ¨:`,
            response.status,
            errorText
          );
        }
      } catch (e) {
        console.error(`âŒ ì—ì´ì „íŠ¸ ${agentId} ì‹¤íŒ¨ í›„ Idle ì „í™˜ ì‹¤íŒ¨:`, e);
      }
    }, 2000);
  }
}

// ì§ì ‘ ì•„ì´ë””ì–´ í‰ê°€ ìš”ì²­ ì²˜ë¦¬
async function handleEvaluateIdeaRequestDirect(
  teamId: string,
  agentId: string,
  requestData: any
) {
  console.log(`ğŸ“Š ì—ì´ì „íŠ¸ ${agentId} ì•„ì´ë””ì–´ í‰ê°€ ìš”ì²­ ì§ì ‘ ì²˜ë¦¬`);

  try {
    // ğŸš« ìš”ì²­ìê°€ í”¼ë“œë°± ì„¸ì…˜ ì¤‘ì¸ì§€ í™•ì¸
    const activeSessions = await redis.keys("feedback_session:*");
    const requesterId = requestData.requesterId;

    if (requesterId) {
      for (const sessionKey of activeSessions) {
        const sessionData = await redis.get(sessionKey);
        if (sessionData) {
          const session =
            typeof sessionData === "string"
              ? JSON.parse(sessionData)
              : sessionData;
          if (
            session.status === "active" &&
            session.participants.some((p: any) => p.id === requesterId)
          ) {
            console.log(`â³ ìš”ì²­ìê°€ í”¼ë“œë°± ì„¸ì…˜ ì¤‘ - ì•„ì´ë””ì–´ í‰ê°€ ìš”ì²­ ë¬´ì‹œ`);
            return;
          }
        }
      }
    }

    // ğŸš« ëŒ€ìƒ ì—ì´ì „íŠ¸(agentId)ê°€ í”¼ë“œë°± ì„¸ì…˜ ì¤‘ì¸ì§€ í™•ì¸
    for (const sessionKey of activeSessions) {
      const sessionData = await redis.get(sessionKey);
      if (sessionData) {
        const session =
          typeof sessionData === "string"
            ? JSON.parse(sessionData)
            : sessionData;
        if (
          session.status === "active" &&
          session.participants.some((p: any) => p.id === agentId)
        ) {
          console.log(
            `â³ ëŒ€ìƒ ì—ì´ì „íŠ¸ê°€ í”¼ë“œë°± ì„¸ì…˜ ì¤‘ - ì•„ì´ë””ì–´ í‰ê°€ ìš”ì²­ ë¬´ì‹œ`
          );
          return;
        }
      }
    }

    const ideas = await getIdeas(teamId);

    if (ideas.length === 0) {
      console.log(`âš ï¸ ì—ì´ì „íŠ¸ ${agentId} í‰ê°€í•  ì•„ì´ë””ì–´ê°€ ì—†ìŒ`);
      return;
    }

    // ë³¸ì¸ì´ ë§Œë“  ì•„ì´ë””ì–´ ì œì™¸
    const otherIdeas = ideas.filter((idea) => idea.author !== agentId);

    if (otherIdeas.length === 0) {
      console.log(`âš ï¸ ì—ì´ì „íŠ¸ ${agentId} í‰ê°€í•  ë‹¤ë¥¸ ì‚¬ëŒì˜ ì•„ì´ë””ì–´ê°€ ì—†ìŒ`);
      return;
    }

    // ğŸ” ì´ë¯¸ í‰ê°€í•œ ì•„ì´ë””ì–´ ì œì™¸
    const unevaluatedIdeas = otherIdeas.filter((idea) => {
      const hasAlreadyEvaluated = idea.evaluations.some(
        (evaluation) => evaluation.evaluator === agentId
      );
      return !hasAlreadyEvaluated;
    });

    if (unevaluatedIdeas.length === 0) {
      console.log(
        `âš ï¸ ì—ì´ì „íŠ¸ ${agentId} í‰ê°€í•  ìƒˆë¡œìš´ ì•„ì´ë””ì–´ê°€ ì—†ìŒ (ëª¨ë‘ í‰ê°€ ì™„ë£Œ)`
      );
      return;
    }

    // ğŸ¯ ì‹¤ì œ ì•„ì´ë””ì–´ í‰ê°€ ìˆ˜í–‰
    const team = await getTeamById(teamId);
    const agentProfile = await getAgentById(agentId);

    if (!team || !agentProfile) {
      console.error(`âŒ ${agentId} íŒ€ ë˜ëŠ” ì—ì´ì „íŠ¸ ì •ë³´ ì—†ìŒ`);
      return;
    }

    // ì—ì´ì „íŠ¸ ìƒíƒœë¥¼ ì‘ì—… ì¤‘ìœ¼ë¡œ ë³€ê²½
    await setAgentState(teamId, agentId, {
      agentId,
      currentState: "action",
      lastStateChange: new Date().toISOString(),
      isProcessing: true,
      currentTask: {
        type: "evaluate_idea",
        description: `ìš”ì²­ë°›ì€ ì•„ì´ë””ì–´ í‰ê°€`,
        startTime: new Date().toISOString(),
        estimatedDuration: 300,
      },
    });

    // ì•„ì´ë””ì–´ í‰ê°€ ìˆ˜í–‰
    const { evaluateIdeaAction } = await import("@/lib/openai");
    const randomIdea =
      unevaluatedIdeas[Math.floor(Math.random() * unevaluatedIdeas.length)];

    console.log(
      `ğŸ“Š ${agentProfile.name} â†’ ${randomIdea.content.object} í‰ê°€ ì‹œì‘`
    );

    try {
      const evaluation = await evaluateIdeaAction(
        randomIdea,
        agentProfile.name
      );

      // í‰ê°€ ì €ì¥
      const response = await fetch(
        `${
          process.env.NEXTAUTH_URL || "http://localhost:3000"
        }/api/teams/${teamId}/ideas/${randomIdea.id}/evaluate`,
        {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "User-Agent": "TeamBuilder-Internal",
          },
          body: JSON.stringify({
            evaluator: agentId,
            scores: {
              insightful: evaluation.insightful,
              actionable: evaluation.actionable,
              relevance: evaluation.relevance,
            },
            comment: evaluation.comment,
          }),
        }
      );

      if (response.ok) {
        console.log(`âœ… ${agentProfile.name} ì•„ì´ë””ì–´ í‰ê°€ ì™„ë£Œ`);

        // í‰ê°€ ì™„ë£Œ ë©”ì‹œì§€
        await addChatMessage(teamId, {
          sender: agentId,
          type: "system",
          payload: {
            content: `ìš”ì²­ë°›ì€ ì•„ì´ë””ì–´ë¥¼ í‰ê°€í–ˆìŠµë‹ˆë‹¤.`,
          },
        });
      } else {
        console.error(
          `âŒ ${agentProfile.name} í‰ê°€ ì €ì¥ ì‹¤íŒ¨:`,
          response.status
        );
      }
    } catch (evaluationError) {
      console.error(`âŒ ${agentProfile.name} í‰ê°€ ìˆ˜í–‰ ì‹¤íŒ¨:`, evaluationError);
    }

    console.log(`âœ… ì—ì´ì „íŠ¸ ${agentId} ì•„ì´ë””ì–´ í‰ê°€ ìš”ì²­ ì²˜ë¦¬ ì™„ë£Œ`);
  } catch (error) {
    console.error(`âŒ ì—ì´ì „íŠ¸ ${agentId} í‰ê°€ ìš”ì²­ ì²˜ë¦¬ ì‹¤íŒ¨:`, error);
  }
}

// ì•„ì´ë””ì–´ ìƒì„± ìš”ì²­ ì²˜ë¦¬
async function handleGenerateIdeaRequestDirect(
  teamId: string,
  agentId: string,
  requestData: any
) {
  console.log(`ğŸ“Š ì—ì´ì „íŠ¸ ${agentId} ì•„ì´ë””ì–´ ìƒì„± ìš”ì²­ ì§ì ‘ ì²˜ë¦¬`);

  try {
    // ğŸš« ìš”ì²­ìê°€ í”¼ë“œë°± ì„¸ì…˜ ì¤‘ì¸ì§€ í™•ì¸
    const activeSessions = await redis.keys("feedback_session:*");
    const requesterId = requestData.requesterId;

    if (requesterId) {
      for (const sessionKey of activeSessions) {
        const sessionData = await redis.get(sessionKey);
        if (sessionData) {
          const session =
            typeof sessionData === "string"
              ? JSON.parse(sessionData)
              : sessionData;
          if (
            session.status === "active" &&
            session.participants.some((p: any) => p.id === requesterId)
          ) {
            console.log(`â³ ìš”ì²­ìê°€ í”¼ë“œë°± ì„¸ì…˜ ì¤‘ - ì•„ì´ë””ì–´ ìƒì„± ìš”ì²­ ë¬´ì‹œ`);
            return;
          }
        }
      }
    }

    // ğŸš« ëŒ€ìƒ ì—ì´ì „íŠ¸(agentId)ê°€ í”¼ë“œë°± ì„¸ì…˜ ì¤‘ì¸ì§€ í™•ì¸
    for (const sessionKey of activeSessions) {
      const sessionData = await redis.get(sessionKey);
      if (sessionData) {
        const session =
          typeof sessionData === "string"
            ? JSON.parse(sessionData)
            : sessionData;
        if (
          session.status === "active" &&
          session.participants.some((p: any) => p.id === agentId)
        ) {
          console.log(
            `â³ ëŒ€ìƒ ì—ì´ì „íŠ¸ê°€ í”¼ë“œë°± ì„¸ì…˜ ì¤‘ - ì•„ì´ë””ì–´ ìƒì„± ìš”ì²­ ë¬´ì‹œ`
          );
          return;
        }
      }
    }

    const team = await getTeamById(teamId);
    const agentProfile = await getAgentById(agentId);

    if (!team || !agentProfile) {
      console.error(`âŒ ${agentId} íŒ€ ë˜ëŠ” ì—ì´ì „íŠ¸ ì •ë³´ ì—†ìŒ`);
      return;
    }

    // ì—ì´ì „íŠ¸ ìƒíƒœë¥¼ ì‘ì—… ì¤‘ìœ¼ë¡œ ë³€ê²½
    await setAgentState(teamId, agentId, {
      agentId,
      currentState: "action",
      lastStateChange: new Date().toISOString(),
      isProcessing: true,
      currentTask: {
        type: "generate_idea",
        description: `ìš”ì²­ë°›ì€ ì•„ì´ë””ì–´ ìƒì„±`,
        startTime: new Date().toISOString(),
        estimatedDuration: 300,
      },
    });

    console.log(`ğŸ¯ ${agentProfile.name} ìš”ì²­ë°›ì€ ì•„ì´ë””ì–´ ìƒì„± ì‹œì‘`);

    const ideas = await getIdeas(teamId);
    const existingIdeas = ideas.map((idea, index) => ({
      ideaNumber: index + 1,
      authorName: idea.author,
      object: idea.content.object,
      function: idea.content.function,
    }));

    const agentMemory = await getAgentMemory(agentId);
    const generatedContent = await generateIdeaAction(
      team.topic || "Carbon Emission Reduction",
      agentProfile,
      existingIdeas,
      agentMemory || undefined
    );

    const newIdea = await addIdea(teamId, {
      author: agentId,
      timestamp: new Date().toISOString(),
      content: {
        object: generatedContent.object || "ìƒì„±ëœ ì•„ì´ë””ì–´",
        function: generatedContent.function || "ê¸°ëŠ¥ ì„¤ëª…",
        behavior:
          typeof generatedContent.behavior === "object"
            ? JSON.stringify(generatedContent.behavior)
            : generatedContent.behavior || "ë™ì‘ ì„¤ëª…",
        structure:
          typeof generatedContent.structure === "object"
            ? JSON.stringify(generatedContent.structure)
            : generatedContent.structure || "êµ¬ì¡° ì„¤ëª…",
      },
      evaluations: [],
    });

    // ì±„íŒ… ì•Œë¦¼
    await addChatMessage(teamId, {
      sender: agentId,
      type: "system",
      payload: {
        content: `${requestData.requesterName}ì˜ ìš”ì²­ì— ë”°ë¼ ìƒˆë¡œìš´ ì•„ì´ë””ì–´ë¥¼ ìƒì„±í–ˆìŠµë‹ˆë‹¤.`,
      },
    });

    console.log(
      `âœ… ${agentProfile.name} ì•„ì´ë””ì–´ ìƒì„± ì™„ë£Œ:`,
      generatedContent.object
    );
  } catch (error) {
    console.error(
      `âŒ ì—ì´ì „íŠ¸ ${agentId} ì•„ì´ë””ì–´ ìƒì„± ìš”ì²­ ì²˜ë¦¬ ì‹¤íŒ¨:`,
      error
    );
  }
}

// í”¼ë“œë°± ìš”ì²­ ì²˜ë¦¬
async function handleGiveFeedbackRequestDirect(
  teamId: string,
  agentId: string,
  requestData: any
) {
  console.log(`ğŸ’¬ ì—ì´ì „íŠ¸ ${agentId} í”¼ë“œë°± ìš”ì²­ ì§ì ‘ ì²˜ë¦¬`);

  try {
    const team = await getTeamById(teamId);
    const agentProfile = await getAgentById(agentId);

    if (!team || !agentProfile) {
      console.error(`âŒ ${agentId} íŒ€ ë˜ëŠ” ì—ì´ì „íŠ¸ ì •ë³´ ì—†ìŒ`);
      return;
    }

    // ìš”ì²­ì ì •ë³´ í™•ì¸
    const requesterName = requestData.requesterName;
    const requesterId = requestData.requesterId;

    console.log(`ğŸ“‹ í”¼ë“œë°± ìš”ì²­ ìƒì„¸ ì •ë³´:`, {
      requesterName,
      requesterId,
      agentName: agentProfile.name,
      agentId,
    });

    // ğŸš« ìš”ì²­ìê°€ í”¼ë“œë°± ì„¸ì…˜ ì¤‘ì¸ì§€ í™•ì¸
    const activeSessions = await redis.keys("feedback_session:*");
    let requesterInFeedbackSession = false;

    for (const sessionKey of activeSessions) {
      const sessionData = await redis.get(sessionKey);
      if (sessionData) {
        const session =
          typeof sessionData === "string"
            ? JSON.parse(sessionData)
            : sessionData;
        if (
          session.status === "active" &&
          session.participants.some((p: any) => p.id === requesterId)
        ) {
          requesterInFeedbackSession = true;
          break;
        }
      }
    }

    if (requesterInFeedbackSession) {
      console.log(
        `â³ ìš”ì²­ì ${requesterName}ê°€ í”¼ë“œë°± ì„¸ì…˜ ì¤‘ - í”¼ë“œë°± ìš”ì²­ ë¬´ì‹œ`
      );
      return;
    }

    // ğŸš« ëŒ€ìƒ ì—ì´ì „íŠ¸(agentId)ê°€ í”¼ë“œë°± ì„¸ì…˜ ì¤‘ì¸ì§€ í™•ì¸
    let targetInFeedbackSession = false;
    for (const sessionKey of activeSessions) {
      const sessionData = await redis.get(sessionKey);
      if (sessionData) {
        const session =
          typeof sessionData === "string"
            ? JSON.parse(sessionData)
            : sessionData;
        if (
          session.status === "active" &&
          session.participants.some((p: any) => p.id === agentId)
        ) {
          targetInFeedbackSession = true;
          break;
        }
      }
    }

    if (targetInFeedbackSession) {
      console.log(`â³ ëŒ€ìƒ ì—ì´ì „íŠ¸ê°€ í”¼ë“œë°± ì„¸ì…˜ ì¤‘ - í”¼ë“œë°± ìš”ì²­ ë¬´ì‹œ`);
      return;
    }

    // ì—ì´ì „íŠ¸ ìƒíƒœë¥¼ ì‘ì—… ì¤‘ìœ¼ë¡œ ë³€ê²½
    await setAgentState(teamId, agentId, {
      agentId,
      currentState: "action",
      lastStateChange: new Date().toISOString(),
      isProcessing: true,
      currentTask: {
        type: "give_feedback",
        description: `${requesterName}ì˜ ìš”ì²­ì— ë”°ë¥¸ í”¼ë“œë°± ì „ëµ ìˆ˜ë¦½ ì¤‘`,
        startTime: new Date().toISOString(),
        estimatedDuration: 60,
      },
    });

    console.log(`ğŸ¯ ${agentProfile.name} í”¼ë“œë°± ì „ëµ ìˆ˜ë¦½ ì‹œì‘`);

    // ğŸ” ëª¨ë“  í•„ìš”í•œ ì •ë³´ ìˆ˜ì§‘
    // 1. íŒ€ì˜ ëª¨ë“  ì—ì´ì „íŠ¸ ì •ë³´ ê°€ì ¸ì˜¤ê¸°
    const agents = await Promise.all(
      (team?.members || [])
        .filter((m) => !m.isUser && m.agentId)
        .map((m) => getAgentById(m.agentId!))
    );
    const validAgents = agents.filter((agent) => agent !== null);

    // 2. íŒ€ì› ì •ë³´ êµ¬ì„± (ì‚¬ìš© ê°€ëŠ¥ ì—¬ë¶€ í¬í•¨)
    const busyAgents = new Set<string>();
    for (const sessionKey of activeSessions) {
      const sessionData = await redis.get(sessionKey);
      if (sessionData) {
        const session =
          typeof sessionData === "string"
            ? JSON.parse(sessionData)
            : sessionData;
        if (session.status === "active") {
          session.participants.forEach((p: any) => {
            busyAgents.add(p.id);
          });
        }
      }
    }

    const teamMembers = [];

    // AI ì—ì´ì „íŠ¸ë“¤ ì¶”ê°€ (ë³¸ì¸ ì œì™¸)
    for (const member of team.members) {
      if (!member.isUser && member.agentId && member.agentId !== agentId) {
        const agent = validAgents.find((a: any) => a?.id === member.agentId);
        if (agent) {
          teamMembers.push({
            id: member.agentId,
            name: agent.name,
            isUser: false,
            roles: member.roles || [],
            isAvailable: !busyAgents.has(member.agentId),
          });
        }
      }
    }

    // ì¸ê°„ ì‚¬ìš©ì ì¶”ê°€
    const humanMember = team.members.find((member) => member.isUser);
    if (humanMember) {
      teamMembers.push({
        id: "ë‚˜",
        name: "ë‚˜",
        isUser: true,
        roles: humanMember.roles || [],
        isAvailable: !busyAgents.has("ë‚˜"),
      });
    }

    // 3. ì•„ì´ë””ì–´ ì •ë³´ ê°€ì ¸ì˜¤ê¸°
    const ideas = await getIdeas(teamId);
    const existingIdeas = ideas.map((idea, index) => ({
      ideaNumber: index + 1,
      authorId: idea.author,
      authorName:
        idea.author === "ë‚˜"
          ? "ë‚˜"
          : (() => {
              const member = team?.members.find(
                (tm) => tm.agentId === idea.author
              );
              if (member && !member.isUser) {
                const agent = validAgents.find(
                  (a: any) => a?.id === idea.author
                );
                return agent?.name || `ì—ì´ì „íŠ¸ ${idea.author}`;
              }
              return idea.author;
            })(),
      object: idea.content.object,
      function: idea.content.function,
      behavior: idea.content.behavior,
      structure: idea.content.structure,
      timestamp: idea.timestamp,
      evaluations: idea.evaluations || [],
    }));

    // 4. ìµœê·¼ ë©”ì‹œì§€ ê°€ì ¸ì˜¤ê¸°
    const recentMessages = await getChatHistory(teamId, 5);

    // 5. ì—ì´ì „íŠ¸ ë©”ëª¨ë¦¬ ê°€ì ¸ì˜¤ê¸°
    const agentMemory = await getAgentMemory(agentId);

    // ì‚¬ìš© ê°€ëŠ¥í•œ íŒ€ì›ì´ ì—†ëŠ” ê²½ìš°
    const availableMembers = teamMembers.filter((member) => member.isAvailable);
    if (availableMembers.length === 0) {
      console.log(
        `âš ï¸ ${agentProfile.name} í˜„ì¬ ì‚¬ìš© ê°€ëŠ¥í•œ í”¼ë“œë°± ëŒ€ìƒì´ ì—†ìŒ`
      );

      await addChatMessage(teamId, {
        sender: agentId,
        type: "system",
        payload: {
          content: `í˜„ì¬ ëª¨ë“  íŒ€ì›ì´ ë‹¤ë¥¸ ì‘ì—… ì¤‘ì´ì–´ì„œ í”¼ë“œë°±ì„ ì œê³µí•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.`,
        },
      });
      return;
    }

    // ğŸ§  AIì—ê²Œ í”¼ë“œë°± ì „ëµ ê²°ì • ìš”ì²­
    console.log(`ğŸ§  ${agentProfile.name} AI í”¼ë“œë°± ì „ëµ ê²°ì • ì¤‘...`);

    const feedbackStrategy = await planFeedbackStrategy(
      agentProfile,
      {
        teamName: team.teamName || "íŒ€",
        topic: team.topic || "ì•„ì´ë””ì—ì´ì…˜",
        teamMembers: availableMembers, // ì‚¬ìš© ê°€ëŠ¥í•œ íŒ€ì›ë§Œ ì „ë‹¬
        existingIdeas,
        recentMessages,
      },
      {
        requesterName,
        originalMessage:
          requestData.payload?.message || "í”¼ë“œë°±ì„ ìš”ì²­í–ˆìŠµë‹ˆë‹¤.",
      },
      agentMemory || undefined
    );

    console.log(`ğŸ¯ ${agentProfile.name} í”¼ë“œë°± ì „ëµ ê²°ì • ì™„ë£Œ:`, {
      target: feedbackStrategy.targetMember.name,
      type: feedbackStrategy.feedbackType,
      reasoning: feedbackStrategy.reasoning,
    });

    const targetMember = feedbackStrategy.targetMember;

    // ë½ í‚¤ ìƒì„± (ì‘ì€ IDê°€ ë¨¼ì € ì˜¤ë„ë¡ ì •ë ¬)
    const lockKey = `feedback_lock:${[agentId, targetMember.id]
      .sort()
      .join(":")}`;

    // ë¶„ì‚° ë½ ì‚¬ìš©
    const lockAcquired = await redis.set(lockKey, "locked", {
      ex: 30, // 30ì´ˆ TTL
      nx: true, // í‚¤ê°€ ì¡´ì¬í•˜ì§€ ì•Šì„ ë•Œë§Œ ì„¤ì •
    });

    if (!lockAcquired) {
      console.log(
        `âš ï¸ ${agentProfile.name} â†’ ${targetMember.name} í”¼ë“œë°± ì„¸ì…˜ ë½ íšë“ ì‹¤íŒ¨ (ì´ë¯¸ ì§„í–‰ ì¤‘)`
      );

      await addChatMessage(teamId, {
        sender: agentId,
        type: "system",
        payload: {
          content: `${targetMember.name}ì™€ì˜ í”¼ë“œë°± ì„¸ì…˜ì´ ì´ë¯¸ ì§„í–‰ ì¤‘ì…ë‹ˆë‹¤.`,
        },
      });
      return;
    }

    try {
      // í”¼ë“œë°± ì»¨í…ìŠ¤íŠ¸ êµ¬ì„±
      const feedbackContext = {
        type: feedbackStrategy.feedbackType,
        initiatedBy: "user_request",
        description: `${requesterName}ì˜ ìš”ì²­ì— ë”°ë¥¸ ${feedbackStrategy.feedbackType} í”¼ë“œë°±`,
        originalRequest: requestData.payload?.message,
        targetIdea: feedbackStrategy.targetIdea,
        aiStrategy: {
          reasoning: feedbackStrategy.reasoning,
          plannedMessage: feedbackStrategy.feedbackMessage,
        },
      };

      // í”¼ë“œë°± ì„¸ì…˜ ìƒì„± API í˜¸ì¶œ
      const baseUrl = process.env.NEXTAUTH_URL || `http://localhost:3000`;
      const sessionResponse = await fetch(
        `${baseUrl}/api/teams/${teamId}/feedback-sessions`,
        {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "User-Agent": "TeamBuilder-Internal",
          },
          body: JSON.stringify({
            action: "create",
            initiatorId: agentId,
            targetAgentId: targetMember.id,
            message: feedbackStrategy.feedbackMessage,
            feedbackContext: feedbackContext,
          }),
        }
      );

      if (sessionResponse.ok) {
        const sessionData = await sessionResponse.json();
        console.log(
          `âœ… ${agentProfile.name} â†’ ${targetMember.name} í”¼ë“œë°± ì„¸ì…˜ ìƒì„± ì„±ê³µ: ${sessionData.sessionId}`
        );

        // ì„±ê³µ ë©”ì‹œì§€ (ì „ëµ í¬í•¨)
        await addChatMessage(teamId, {
          sender: agentId,
          type: "system",
          payload: {
            content: `${requesterName}ì˜ ìš”ì²­ì— ë”°ë¼ ${targetMember.name}ì™€ ${
              feedbackStrategy.feedbackType === "specific_idea"
                ? "íŠ¹ì • ì•„ì´ë””ì–´ì— ëŒ€í•œ"
                : "í˜‘ì—…"
            } í”¼ë“œë°± ì„¸ì…˜ì„ ì‹œì‘í•©ë‹ˆë‹¤.`,
          },
        });

        // ğŸ”„ í”¼ë“œë°± ì„¸ì…˜ ìƒì„± ì¦‰ì‹œ ì–‘ìª½ ì—ì´ì „íŠ¸ ìƒíƒœ ë³€ê²½
        // 1. í”¼ë“œë°± ì œê³µì(í˜„ì¬ ì—ì´ì „íŠ¸) ìƒíƒœ ë³€ê²½
        try {
          const initiatorResponse = await fetch(
            `${baseUrl}/api/teams/${teamId}/agent-states`,
            {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
                "User-Agent": "TeamBuilder-Internal",
              },
              body: JSON.stringify({
                agentId: agentId,
                currentState: "feedback_session",
                taskType: "feedback_session",
                taskDescription: `${targetMember.name}ì™€ ${feedbackStrategy.feedbackType} í”¼ë“œë°± ì„¸ì…˜ ì§„í–‰ ì¤‘`,
                estimatedDuration: 300,
                trigger: "autonomous",
                sessionInfo: {
                  sessionId: sessionData.sessionId,
                  participants: [agentProfile.name, targetMember.name],
                  feedbackType: feedbackStrategy.feedbackType,
                },
              }),
            }
          );

          if (initiatorResponse.ok) {
            console.log(
              `âœ… ${agentProfile.name} ìƒíƒœê°€ feedback_sessionìœ¼ë¡œ ë³€ê²½ë¨`
            );
          } else {
            console.error(
              `âŒ ${agentProfile.name} feedback_session ìƒíƒœ ë³€ê²½ ì‹¤íŒ¨:`,
              initiatorResponse.status
            );
          }
        } catch (error) {
          console.error(
            `âŒ ${agentProfile.name} feedback_session ìƒíƒœ ë³€ê²½ ì˜¤ë¥˜:`,
            error
          );
        }

        // 2. í”¼ë“œë°± ëŒ€ìƒì(íƒ€ê²Ÿ ì—ì´ì „íŠ¸) ìƒíƒœ ë³€ê²½ (ì¸ê°„ì´ ì•„ë‹Œ ê²½ìš°ë§Œ)
        if (!targetMember.isUser) {
          try {
            const targetResponse = await fetch(
              `${baseUrl}/api/teams/${teamId}/agent-states`,
              {
                method: "POST",
                headers: {
                  "Content-Type": "application/json",
                  "User-Agent": "TeamBuilder-Internal",
                },
                body: JSON.stringify({
                  agentId: targetMember.id,
                  currentState: "feedback_session",
                  taskType: "feedback_session",
                  taskDescription: `${agentProfile.name}ì™€ ${feedbackStrategy.feedbackType} í”¼ë“œë°± ì„¸ì…˜ ì§„í–‰ ì¤‘`,
                  estimatedDuration: 300,
                  trigger: "autonomous",
                  sessionInfo: {
                    sessionId: sessionData.sessionId,
                    participants: [agentProfile.name, targetMember.name],
                    feedbackType: feedbackStrategy.feedbackType,
                  },
                }),
              }
            );

            if (targetResponse.ok) {
              console.log(
                `âœ… ${targetMember.name} ìƒíƒœê°€ feedback_sessionìœ¼ë¡œ ë³€ê²½ë¨`
              );
            } else {
              console.error(
                `âŒ ${targetMember.name} feedback_session ìƒíƒœ ë³€ê²½ ì‹¤íŒ¨:`,
                targetResponse.status
              );
            }
          } catch (error) {
            console.error(
              `âŒ ${targetMember.name} feedback_session ìƒíƒœ ë³€ê²½ ì˜¤ë¥˜:`,
              error
            );
          }
        }

        // ì¸ê°„ì—ê²Œ í”¼ë“œë°±í•˜ëŠ” ê²½ìš° ì¦‰ì‹œ ì²« ë©”ì‹œì§€ ìƒì„±
        const isTargetHuman = targetMember.isUser;
        const delay = isTargetHuman ? 1000 : 3000; // ì¸ê°„ì—ê²ŒëŠ” 1ì´ˆ í›„, AIì—ê²ŒëŠ” 3ì´ˆ í›„

        setTimeout(async () => {
          try {
            const aiProcessResponse = await fetch(
              `${baseUrl}/api/teams/${teamId}/feedback-sessions/${sessionData.sessionId}/ai-process`,
              {
                method: "POST",
                headers: {
                  "Content-Type": "application/json",
                  "User-Agent": "TeamBuilder-Internal",
                },
                body: JSON.stringify({
                  triggerAgentId: agentId,
                  action: "respond",
                }),
              }
            );

            if (aiProcessResponse.ok) {
              console.log(
                `âœ… ${agentProfile.name} ì²« í”¼ë“œë°± ë©”ì‹œì§€ ìƒì„± íŠ¸ë¦¬ê±° ì„±ê³µ (ëŒ€ìƒ: ${targetMember.name})`
              );
            } else {
              console.error(
                `âŒ ${agentProfile.name} ì²« í”¼ë“œë°± ë©”ì‹œì§€ ìƒì„± íŠ¸ë¦¬ê±° ì‹¤íŒ¨:`,
                aiProcessResponse.status
              );
            }
          } catch (error) {
            console.error(
              `âŒ ${agentProfile.name} ì²« í”¼ë“œë°± ë©”ì‹œì§€ ìƒì„± íŠ¸ë¦¬ê±° ì˜¤ë¥˜:`,
              error
            );
          }
        }, delay);
      } else {
        const errorData = await sessionResponse.json();
        console.error(
          `âŒ ${agentProfile.name} â†’ ${targetMember.name} í”¼ë“œë°± ì„¸ì…˜ ìƒì„± ì‹¤íŒ¨:`,
          errorData
        );

        await addChatMessage(teamId, {
          sender: agentId,
          type: "system",
          payload: {
            content: `${targetMember.name}ì™€ì˜ í”¼ë“œë°± ì„¸ì…˜ ìƒì„±ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.`,
          },
        });
      }
    } finally {
      // ë½ í•´ì œ
      await redis.del(lockKey);
      console.log(`ğŸ”“ ${agentProfile.name} â†’ ${targetMember.name} ë½ í•´ì œ`);
    }
  } catch (error) {
    console.error(`âŒ ì—ì´ì „íŠ¸ ${agentId} í”¼ë“œë°± ìš”ì²­ ì²˜ë¦¬ ì‹¤íŒ¨:`, error);

    await addChatMessage(teamId, {
      sender: agentId,
      type: "system",
      payload: {
        content: `í”¼ë“œë°± ìš”ì²­ ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.`,
      },
    });
  }
}
