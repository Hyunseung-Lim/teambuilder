import { AgentMemory } from "@/lib/types";

// Common function to generate agent context sections
export const createAgentContextSections = (
  agentProfile?: any,
  memory?: any,
  actionSpecificMessage?: string,
  actionType?: string, // Specific action type to include only relevant actionPlan
  personaSummary?: string, // Individual persona summary generated by GPT-4o
  _targetParticipant?: string // Specific participant to filter relationships for (unused after refactor)
) => {
  // Agent profile section with persona integration
  const profileContext = agentProfile
    ? `
**Your Identity & Professional Persona:**
- Name: ${agentProfile.name}
- Age: ${agentProfile.age}세
- Gender: ${agentProfile.gender}
- Nationality: ${agentProfile.nationality}
- Education: ${agentProfile.education}
- Major: ${agentProfile.major}
- Professional Background: ${agentProfile.professional}

**You behave in the following manner:**
${personaSummary || `You are ${agentProfile.name}, bringing your unique combination of professional expertise, personality traits, and values to every interaction. Your ${agentProfile.professional} background shapes how you see problems and solutions. Let your authentic self drive your participation and collaboration with the team.`}

${agentProfile.isLeader 
  ? "As the team leader, take initiative, guide the team's ideation process, and use your persona summary to shape your leadership style and team interactions."
  : (actionSpecificMessage || "Contribute to the team in ways that align with your persona summary and feel genuinely authentic to who you are.")
}
`
    : "";

  // Memory context section with enhanced relationship awareness
  const memoryContext = memory
    ? `
**Your Memory and Experience:**
${(() => {
  let formattedMemory = "";

  // v2 메모리 구조 확인
  if (
    memory.longTerm?.knowledge ||
    memory.longTerm?.actionPlan ||
    memory.longTerm?.relation
  ) {
    // v2 메모리 처리
    if (memory.longTerm.knowledge) {
      formattedMemory += `- Knowledge: ${memory.longTerm.knowledge}\n`;
    }
    // Include only relevant actionPlan based on actionType, or all if no specific type
    if (!actionType || actionType === 'idea_generation' || actionType === 'generate_idea') {
      if (memory.longTerm.actionPlan?.idea_generation) {
        formattedMemory += `- Idea Generation Strategy: ${memory.longTerm.actionPlan.idea_generation}\n`;
      }
    }
    if (!actionType || actionType === 'idea_evaluation' || actionType === 'evaluate_idea') {
      if (memory.longTerm.actionPlan?.idea_evaluation) {
        formattedMemory += `- Evaluation Strategy: ${memory.longTerm.actionPlan.idea_evaluation}\n`;
      }
    }
    if (!actionType || actionType === 'feedback' || actionType === 'give_feedback') {
      if (memory.longTerm.actionPlan?.feedback) {
        formattedMemory += `- Feedback Strategy: ${memory.longTerm.actionPlan.feedback}\n`;
      }
    }
    if (!actionType || actionType === 'request' || actionType === 'make_request') {
      if (memory.longTerm.actionPlan?.request) {
        formattedMemory += `- Request Strategy: ${memory.longTerm.actionPlan.request}\n`;
      }
    }
    if (!actionType || actionType === 'response') {
      if (memory.longTerm.actionPlan?.response) {
        formattedMemory += `- Response Strategy: ${memory.longTerm.actionPlan.response}\n`;
      }
    }
    if (!actionType || actionType === 'planning') {
      if (memory.longTerm.actionPlan?.planning) {
        formattedMemory += `- Planning Strategy: ${memory.longTerm.actionPlan.planning}\n`;
      }
    }
    
    // Recent actions summary (skip detailed relationships, show key recent activities)
    if (
      memory.longTerm.relation &&
      Object.keys(memory.longTerm.relation).length > 0
    ) {
      // Collect recent interactions across all team members
      const allRecentInteractions: any[] = [];
      Object.entries(memory.longTerm.relation).forEach(([memberId, relationData]: [string, any]) => {
        const recentInteractions = relationData.interactionHistory?.slice(-2) || [];
        recentInteractions.forEach((interaction: any) => {
          allRecentInteractions.push({
            ...interaction,
            withMember: relationData.agentInfo?.name || relationData.name || memberId
          });
        });
      });
      
      // Show only the most recent 2 activities
      const lastTwoActivities = allRecentInteractions.slice(-2);
      if (lastTwoActivities.length > 0) {
        formattedMemory += `\n**Recent Activities:**\n`;
        lastTwoActivities.forEach((activity: any) => {
          formattedMemory += `- ${activity.actionItem}${activity.withMember ? ` with ${activity.withMember}` : ''}\n`;
        });
      }
    }
  } else {
    // 기존 메모리 구조 처리
    if (memory.longTerm?.self) {
      const selfReflection =
        typeof memory.longTerm.self === "string"
          ? memory.longTerm.self
          : Array.isArray(memory.longTerm.self) &&
            memory.longTerm.self.length > 0
          ? memory.longTerm.self[memory.longTerm.self.length - 1]
          : "";
      if (selfReflection) {
        formattedMemory += `- Self Reflection: ${selfReflection}\n`;
      }
    }
    if (
      memory.longTerm?.relations &&
      Object.keys(memory.longTerm.relations).length > 0
    ) {
      const relationshipDescriptions = Object.entries(memory.longTerm.relations)
        .map(([memberId, relationData]: [string, any]) => {
          const relationshipType = relationData.relationship || 'colleague';
          const opinion = relationData.myOpinion || 'professional working relationship';
          const memberName = relationData.agentInfo?.name || memberId;
          return `${memberName} (${relationshipType}): ${opinion}`;
        })
        .join('; ');
      
      formattedMemory += `- Team Relationships: ${relationshipDescriptions}\n`;
    }
  }

  // Recent Actions 처리 (최근 2개까지)
  const recentActions = [];
  
  if (memory.shortTerm?.lastAction) {
    recentActions.push(memory.shortTerm.lastAction);
  }
  
  // 추가 액션들이 있다면 배열에서 가져오기
  if (memory.shortTerm?.recentActions && Array.isArray(memory.shortTerm.recentActions)) {
    recentActions.push(...memory.shortTerm.recentActions);
  }
  
  // 최신순으로 정렬하고 최근 2개만 선택
  const sortedActions = recentActions
    .filter(action => action && action.type && action.timestamp)
    .sort((a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime())
    .slice(0, 2);
  
  if (sortedActions.length > 0) {
    const actionDescriptions = sortedActions.map(action => {
      const formatActionDescription = (actionData: any) => {
        const payload = actionData.payload || actionData.details || {};
        
        switch (actionData.type) {
          case 'feedback_session_participate':
            const participants = payload.participants;
            if (participants && participants.length > 0) {
              const partnerNames = participants.join(', ');
              return `Recently participated in feedback session with ${partnerNames}`;
            } else {
              const partner = payload.partner || payload.targetMember || payload.otherParticipant || 'team member';
              return `Recently participated in feedback session with ${partner}`;
            }
          
          case 'idea_generation':
          case 'generate_idea':
            const ideaTitle = payload.ideaTitle || payload.object || payload.content?.object || 'new idea';
            return `Recently generated idea: "${ideaTitle}"`;
          
          case 'idea_evaluation':
          case 'evaluate_idea':
            const evalTarget = payload.targetIdea || payload.ideaTitle || payload.content?.object || 'team idea';
            const avgScore = payload.scores?.overall || payload.score || payload.averageScore;
            const scoreText = avgScore ? ` (score: ${avgScore})` : '';
            return `Recently evaluated "${evalTarget}"${scoreText}`;
          
          case 'give_feedback':
            const feedbackTarget = payload.targetMember || payload.recipient || payload.targetAgentId || 'team member';
            return `Recently provided feedback to ${feedbackTarget}`;
          
          case 'make_request':
            const requestTarget = payload.targetMember || payload.recipient || payload.targetAgentId || 'team member';
            const requestType = payload.requestType || payload.actionType || 'collaboration';
            return `Recently made ${requestType} request to ${requestTarget}`;
          
          case 'planning':
            const plannedAction = payload.plannedAction || payload.action;
            return plannedAction ? `Recently planned to ${plannedAction}` : `Recently planned next actions for team collaboration`;
          
          default:
            return `Recently performed ${actionData.type}`;
        }
      };
      
      return `- ${formatActionDescription(action)}`;
    }).join('\n');
    
    formattedMemory += actionDescriptions + '\n';
  }

  return formattedMemory || "- This is your first action in the team";
})()}
`
    : "";

  return { profileContext, memoryContext };
};

// ==========================================================================
// ## IDEATION
// ==========================================================================

// Pre-ideation planning prompt
export const preIdeationPrompt = (
  requestMessage: string,
  ideaList: {
    ideaNumber: number;
    authorName: string;
    object: string;
    function: string;
  }[],
  memory?: AgentMemory,
  agentProfile?: any
) => {
  const simplifiedIdeaList =
    ideaList.length > 0 ? JSON.stringify(ideaList, null, 2) : "No ideas yet.";

  const { profileContext, memoryContext } = createAgentContextSections(
    agentProfile,
    memory,
    "Analyze requests strategically and decide the best approach for idea generation.",
    "idea_generation",
    undefined, // personaSummary
    undefined // targetParticipant - no relationship filtering for ideation
  );

  return `${profileContext}${memoryContext}You are in a team ideation session. Your task is to analyze a request for an idea and decide the best way to generate it.
Inputs:
1. Request Message: "${requestMessage}"
2. Existing Ideas: ${simplifiedIdeaList}

Based on the inputs, you must perform the following tasks:
1.  Decide whether to create a completely "New" idea or "Update" an existing one. A "New" idea is suitable for a broad or novel request. An "Update" is better if the request aims to refine, combine, or build upon an existing concept. If there are no existing ideas, you must choose "New".
2.  If you decide to "Update", you MUST select one idea from the "Existing Ideas" list by its "ideaNumber". The reference idea should be the one most relevant to the request.
3.  Extract a concise "Ideation Strategy" from the request message. This strategy will guide the next stage of idea generation. For example, "Make it more eco-friendly" or "Combine it with AI features".

Respond only in the following JSON format:

{
  "decision": "New" | "Update",
  "referenceIdea": { "ideaNumber": 1, "object": "...", "function": "..." } | null,
  "ideationStrategy": "Your extracted ideation strategy."
}

Example:
Request Message: "I like idea #1, the '교육적 튜터링 스피커', but can we make it more focused on elderly care?"
Existing Ideas: [
  { 
    "ideaNumber": 1, 
    "authorName": "Agent Jane", 
    "object": "교육적 튜터링 스피커", 
    "function": "..."
  }
]

Your output:
{
  "decision": "Update",
  "referenceIdea": { "ideaNumber": 1, "object": "교육적 튜터링 스피커", "function": "..." },
  "ideationStrategy": "Focus on elderly care features instead of general education."
}

Now, process the given inputs and provide your JSON output.
`;
};

// Main ideation prompt
export const ideationPrompt = (
  context?: string,
  agentProfile?: any,
  memory?: any,
  personaSummary?: string
) => {
  // 주제를 안전하게 처리하되 한글은 보존
  const safeContext = context || "Carbon Emission Reduction";

  const { profileContext, memoryContext } = createAgentContextSections(
    agentProfile,
    memory,
    "Generate ideas that reflect your unique professional background, skills, and personality.",
    "idea_generation",
    personaSummary,
    undefined // targetParticipant - no relationship filtering for ideation
  );

  return `${profileContext}${memoryContext}## Design Goals
- Conduct conceptual design
- Propose a design solution to directly address the specified design task
- Prioritize novelty, completeness and quality while maintaining feasibility

## Design Task
${safeContext}

## Design Approach
Choose one of these thinking workflows:

**New Creation Workflow:**
1. Propose an object addressing the design task (Design Task → Object)
2. Derive critical functions for the object (Object → Functions)
3. Translate functions into observable behaviors (Functions → Behaviors)
4. Design structures enabling the behaviors (Behaviors → Structures)
5. Combine the object, functions, behaviors, and structures into a final design solution

**Analogical Reasoning Workflow:**
1. Given a design task, derive a new combination of object and functions through analogical reasoning, based on a predefined combination of object and functions and an analogical distance between these two combinations
2. Translate these new functions into new observable behaviors (New Functions → New Behaviors)
3. Design new structures enabling these new behaviors (New Behaviors → New Structures)
4. Combine the new object, new functions, new behaviors, and new structures into a final new design solution

## Innovation Requirements
- Each solution must include more than 2 disruptive innovations compared to existing solutions
- Challenge conventional approaches and leverage your professional expertise

**Write all content in Korean.**
Respond only in the following JSON format:

Examples (can be more specific than the example):
Task: Design a smart speaker in the future.
Idea: 
{
  "object": "교육적 튜터링 스피커",
  "function": "모든 연령의 학생에게 인터랙티브한 교육을 제공하는 인공지능 어시스턴트",
  "behavior": [
    {"key": "인터랙티브 수업", "value": "다양한 주제와 학생의 수준에 맞는 음성 기반 교육 콘텐츠 제공"},
    {"key": "과제 지원", "value": "학생들에게 적절한 설명과 답변을 제공하여 과제 수행을 지원"}
  ],
  "structure": [
    {"key": "적응형 교육 AI", "value": "사용자의 수준과 선호를 파악해 맞춤형 교육 콘텐츠를 생성"},
    {"key": "고성능 오디오", "value": "효과적인 교육을 위한 고품질 오디오 출력을 지원"},
    {"key": "다중 인식 마이크", "value": "여러 학생의 발화를 인식하기 위한 다중 마이크 배열"},
    {"key": "부모용 컨트롤러", "value": "부모가 교육 콘텐츠를 모니터링하고 관리할 수 있도록 지원"}
  ]
}

Task: Design a toy for cats.
Idea:
{
  "object": "무소음 봉제 공",
  "function": "고양이가 주인을 방해하지 않고 자유롭게 놀 수 있도록 무소음 놀이 경험을 제공합니다.",
  "behavior": [
    {"key": "컴팩트 디자인", "value": "좁은 공간에서도 고양이가 쉽게 물고, 밀고, 들고 다닐 수 있습니다."},
    {"key": "부드럽고 높은 탄성", "value": "변형 후에도 빠르게 원형을 회복해 편안한 촉감을 제공합니다."},
    {"key": "내구성과 저항성", "value": "잦은 물기·긁기·당기기에도 마모나 변형이 거의 없어 장기간 사용이 가능합니다."},
    {"key": "무소음 반동", "value": "소리를 내지 않고 계속 튀며 움직여, 조용한 환경을 유지합니다."},
    {"key": "안전성과 무독성", "value": "유해 화학물질이 없는 소재로 만들어, 고양이가 핥거나 물어도 안전합니다."}
  ],
  "structure": [
    {"key": "크기와 형태", "value": "지름 5 cm, 최대 4 cm까지 압축돼 실수로 삼키는 일을 방지합니다."},
    {"key": "플러시 외피", "value": "부드럽고 편안하며 마모에 강하고 세척이 쉬워 위생적입니다."},
    {"key": "고탄성 솜 충전재", "value": "적당한 부드러움과 구조적 안정성, 우수한 탄성을 제공합니다."},
    {"key": "고강도 봉제 및 구조", "value": "격한 놀이에도 실밥이 풀리거나 끊어지지 않고 장기간 견딜 수 있습니다."}
  ]
}

## Concept Framework
Generate ideas using the following structure:

{
  "object": "",
  "function": "",
  "behavior": [],
  "structure": []
}

### Component Definitions:
- **Object**: The target entity to be designed, which can be either existing or imagined. It is usually a noun or short phrases. Example: Residential house.
- **Function**: Ultimate purposes the object must achieve, describing what the object should do. Example: Provide safety, provide comfort, provide load-bearing capacity.
- **Behavior**: Dynamic characteristics of the object, including how it responds to various inputs and environmental conditions. It describes how the object achieves its functions, and is derived from or anticipated based on its structures. Format as an array of key-value pairs: [{"key": "행동 요소명", "value": "설명"}]
- **Structure**: Physical composition or configuration of the object, including its components and the relationships between them. Format as an array of key-value pairs: [{"key": "구조 요소명", "value": "설명"}]

Task: ${safeContext}`;
};

const baseIdeationPromptText = `Generate one idea based on the provided instructions and return only one JSON object in the following structure:
{
  "object": "",
  "function": "",
  "behavior": {},
  "structure": {}
}
- object: The design target that appears beside each idea node.
- function: The purpose or teleology of the object.
- behavior: What the object does, expressed as a JSON object.
- structure: The object's components and their relationships, as a JSON object.
Write all content in Korean. Respond only in the following JSON format:`;

// New ideation prompt
export const newIdeationPrompt = (
  ideationStrategy: string,
  topic: string,
  memory?: AgentMemory,
  agentProfile?: any
) => {
  const { profileContext, memoryContext } = createAgentContextSections(
    agentProfile,
    memory,
    "Generate innovative ideas based on the provided strategy, leveraging your unique perspective and expertise.",
    "idea_generation",
    undefined, // personaSummary
    undefined // targetParticipant - no relationship filtering for ideation
  );

  return `${profileContext}${memoryContext}${baseIdeationPromptText}

Task: ${topic}
Ideation Strategy: ${ideationStrategy}

Apply the strategy to generate a completely new idea for the given task.
Idea: `;
};

// Update ideation prompt
export const updateIdeationPrompt = (
  referenceIdea: any,
  ideationStrategy: string,
  topic: string,
  memory?: AgentMemory,
  agentProfile?: any
) => {
  const ideaString = JSON.stringify(referenceIdea, null, 2);

  const { profileContext, memoryContext } = createAgentContextSections(
    agentProfile,
    memory,
    "Build upon existing ideas by applying strategic improvements and innovative enhancements based on your expertise.",
    "idea_generation",
    undefined, // personaSummary
    undefined // targetParticipant - no relationship filtering for ideation
  );

  return `${profileContext}${memoryContext}${baseIdeationPromptText}

Task: ${topic}
Reference Idea to Update:
${ideaString}

Ideation Strategy: ${ideationStrategy}

Apply the strategy to the reference idea to create an improved or modified version. The new idea should be a clear evolution of the reference.
Idea: `;
};

// ==========================================================================
// ## EVALUATION
// ==========================================================================

// Pre-evaluation planning prompt
export const preEvaluationPrompt = (
  requestMessage: string,
  ideaList: {
    ideaNumber: number;
    authorName: string;
    object: string;
    function: string;
  }[],
  memory?: AgentMemory,
  agentProfile?: any
) => {
  const ideaListString =
    ideaList.length > 0
      ? JSON.stringify(ideaList, null, 2)
      : "No ideas available for evaluation.";

  const { profileContext, memoryContext } = createAgentContextSections(
    agentProfile,
    memory,
    "Analyze evaluation requests strategically and select ideas objectively based on your expertise.",
    "idea_evaluation",
    undefined, // personaSummary
    undefined // targetParticipant - no relationship filtering for evaluation planning
  );

  return `${profileContext}${memoryContext}You are in a team ideation session. Your task is to analyze a request for idea evaluation and decide which idea to evaluate and how.

IMPORTANT: You should only evaluate ideas created by other team members, not your own ideas. The available ideas list already excludes your own ideas.

Inputs:
1. Request Message: "${requestMessage}"
2. Available Ideas: ${ideaListString}

Based on the inputs, you must perform the following tasks:
1. Select ONE idea from the "Available Ideas" list that is most relevant to the request message. If the request mentions a specific idea number, prioritize that. Otherwise, choose the most suitable one based on the request context.
2. Extract an "Evaluation Strategy" from the request message that will guide how you evaluate the selected idea. This should focus on what aspects to emphasize (e.g., "Focus on environmental impact", "Evaluate technical feasibility", "Consider user experience").

Respond only in the following JSON format:

{
  "selectedIdea": {
    "ideaNumber": 1,
    "object": "...",
    "function": "..."
  },
  "evaluationStrategy": "Your extracted evaluation strategy focusing on specific aspects to evaluate."
}

Example:
Request Message: "Can you evaluate idea #2 focusing on its environmental benefits?"
Available Ideas: [
  { "ideaNumber": 1, "authorName": "User", "object": "스마트 조명", "function": "..." },
  { "ideaNumber": 2, "authorName": "Agent A", "object": "태양광 충전기", "function": "..." }
]

Your output:
{
  "selectedIdea": { "ideaNumber": 2, "object": "태양광 충전기", "function": "..." },
  "evaluationStrategy": "Focus on environmental benefits and sustainability impact."
}

Now, process the given inputs and provide your JSON output.
`;
};

// Execute evaluation prompt
export const evaluationPrompt = (
  selectedIdea: any,
  evaluationStrategy: string,
  memory?: AgentMemory,
  agentProfile?: any
) => {
  const ideaString = JSON.stringify(selectedIdea, null, 2);

  const { profileContext, memoryContext } = createAgentContextSections(
    agentProfile,
    memory,
    "Evaluate ideas thoroughly and objectively using your professional expertise and analytical skills.",
    "idea_evaluation",
    undefined, // personaSummary
    undefined // targetParticipant - no relationship filtering for evaluation
  );

  return `${profileContext}${memoryContext}You are an AI agent evaluating an idea in a team ideation session. Your task is to provide a comprehensive evaluation based on the given strategy.

IMPORTANT: You should only evaluate ideas created by other team members, not your own ideas.

Idea to Evaluate:
${ideaString}

Evaluation Strategy: ${evaluationStrategy}

You must evaluate the idea on three dimensions using a 7-point scale (1-7):
- Novelty: How novel, creative, and original is this idea? (1=not novel at all, 7=extremely novel)
- Completeness: How complete and well-developed is this idea? (1=not complete at all, 7=extremely complete)  
- Quality: How high-quality and well-thought-out is this idea? (1=very low quality, 7=extremely high quality)

Use the following 7-point scale for all dimensions:
- 1: Strongly Disagree/Very Poor
- 2: Disagree/Poor  
- 3: Somewhat Disagree/Below Average
- 4: Neutral/Average
- 5: Somewhat Agree/Above Average
- 6: Agree/Good
- 7: Strongly Agree/Excellent

Apply the evaluation strategy to focus your assessment on the specified aspects while still providing scores for all three dimensions.

Be specific and critical in your evaluation. Don't hesitate to point out weaknesses or limitations. Provide concrete reasons for your scores and specific suggestions for improvement.

Provide your evaluation in the following JSON format. Write your comment in Korean.

{
  "scores": {
    "novelty": <1-7>,
    "completeness": <1-7>,
    "quality": <1-7>
  },
  "comment": "Your detailed evaluation comment in Korean, focusing on the evaluation strategy while covering all three dimensions."
}

Respond only in the following JSON format:
`;
};

// ==========================================================================
// ## FEEDBACK
// ==========================================================================

// Pre-feedback planning prompt
export const preFeedbackPrompt = (
  targetMemberName: string,
  targetMemberIdeas: any[],
  memory?: any,
  agentProfile?: any,
  requestContext?: {
    isRequestBased?: boolean;
    requesterName?: string;
    requestMessage?: string;
    teamContext?: any;
  }
) => {
  // 디버깅: targetMemberIdeas 상태 확인
  console.log(`🔍 preFeedbackPrompt에서 ${targetMemberName}의 아이디어 확인:`);
  console.log(`- targetMemberIdeas:`, targetMemberIdeas);
  console.log(`- Array인가?:`, Array.isArray(targetMemberIdeas));
  console.log(`- 길이:`, targetMemberIdeas?.length);
  console.log(`- 길이 > 0 체크:`, targetMemberIdeas.length > 0);
  
  const ideasText = targetMemberIdeas.length > 0 
    ? targetMemberIdeas.map((idea, index) => 
        `${index + 1}. "${idea.content?.object || '제목 없음'}" - ${idea.content?.function || '설명 없음'}`
      ).join('\n')
    : '아직 아이디어가 없습니다.';
    
  console.log(`📝 preFeedbackPrompt에서 생성된 ideasText:`, ideasText);

  const { profileContext, memoryContext } = createAgentContextSections(
    agentProfile,
    memory,
    "Analyze feedback opportunities strategically to provide maximum value to team members.",
    "feedback",
    undefined, // personaSummary
    targetMemberName // targetParticipant - only show relationship with feedback target
  );

  // 요청 기반 피드백인지 확인
  const isRequestBased = requestContext?.isRequestBased || false;
  const requestInfo = isRequestBased ? `

**REQUEST CONTEXT:**
- This feedback is requested by: ${requestContext?.requesterName}
- Request message: "${requestContext?.requestMessage}"
- You should select ${targetMemberName} as the feedback target and plan accordingly
` : '';

  return `${profileContext}${memoryContext}You are planning to provide feedback${isRequestBased ? ' in response to a team member request' : ''} to ${targetMemberName} in a team ideation session.
${requestInfo}
**Target Member:** ${targetMemberName}
**Their Ideas:**
${ideasText}

**Feedback Taxonomy Guidelines:**
Choose appropriate feedback approaches among the 15 taxonomy based on the situation:

- **1. Verification**: Ensure you understand their idea correctly
- **2. Completion**: Ask for clarification on unclear aspects
- **3. Understanding Feedback Receiver**: Learn about their background and perspective
- **4. Logical/Causal Reasoning**: Prompt them to think about feasibility, effectiveness, realization
- **5. Instrumental/Procedural Reasoning**: Ask about procedures and decision reasoning
- **6. Brainstorming/Ideation**: Provide or elicit new ideas without specific goals
- **7. Negotiation**: Suggest alternative ideas or approaches
- **8. Scenario Creation**: Present specific scenarios that could occur
- **9. Sharing Examples/Personal Experience**: Provide relevant examples or experiences
- **10. Providing Design Knowledge**: Share design principles or domain knowledge
- **11. Positive Assessment**: Explicitly acknowledge good aspects of the design
- **12. Negative Assessment**: Explicitly point out areas for improvement
- **13. Direct Recommendation**: Give specific advice on what or how to do
- **14. Hinting**: Indirectly suggest ways to proceed
- **15. Project Management**: Address scheduling, deliverables, stakeholder management

**Planning Task:**
Based on your knowledge of ${targetMemberName} and their ideas, develop a strategic approach for providing meaningful feedback.

**CRITICAL: Idea Status Analysis**
- ${targetMemberName} currently has ${targetMemberIdeas.length} ideas
- Set hasIdeas to true if they have 1 or more ideas, false if they have 0 ideas
- This determines the entire feedback approach

Consider:
1. **Idea Status**: Based on the ${targetMemberIdeas.length} ideas shown above, set hasIdeas appropriately
2. **Feedback Focus**: What specific aspects should you focus on (ideas, collaboration style, team contribution, other assigned roles)?
3. **Feedback Approach**: What tone and approach would be most effective given your relationship?
4. **Value Proposition**: How can you provide maximum value to help them improve?
5. **Taxonomy Selection**: Which 1-2 feedback taxonomy approaches best fit this situation?${isRequestBased ? `
6. **Target Selection**: Since this is a requested feedback, confirm ${targetMemberName} as your feedback target
7. **Feedback Type**: Determine the most appropriate feedback type (general_collaboration, specific_idea, skill_development, team_dynamics)` : ''}

${isRequestBased ? `Respond only in the following JSON format for REQUEST-BASED feedback:
{
  "targetMember": {
    "id": "${targetMemberName}",
    "name": "${targetMemberName}",
    "isUser": true
  },
  "feedbackType": "general_collaboration" | "specific_idea" | "skill_development" | "team_dynamics",
  "hasIdeas": true | false,
  "feedbackFocus": "What specific aspects you will focus on in your feedback",
  "feedbackApproach": "Your planned tone and approach for the feedback", 
  "keyPoints": "Main points you want to communicate",
  "selectedTaxonomy": ["Selected taxonomy approach(es) from the 15 options above"],
  "reasoning": "Why you chose this approach and feedback type"
}` : `Respond only in the following JSON format:
{
  "hasIdeas": true | false,
  "feedbackFocus": "What specific aspects you will focus on in your feedback",
  "feedbackApproach": "Your planned tone and approach for the feedback",
  "keyPoints": "Main points you want to communicate",
  "selectedTaxonomy": ["Selected taxonomy approach(es) from the 15 options above"]
}`}`;
};

// Main feedback prompt
export const feedbackPrompt = (
  targetMember: string,
  targetMemberIdeas: any[],
  teamContext: any,
  agentProfile?: any,
  memory?: any,
  targetMemberRoles?: string[],
  allIdeas?: any[],
  feedbackStrategy?: any // preFeedback에서 전달된 전략
) => {
  const { profileContext, memoryContext } = createAgentContextSections(
    agentProfile,
    memory,
    "Provide natural, conversational feedback on specific ideas while reflecting your personality and relationships.",
    "feedback",
    undefined, // personaSummary
    targetMember // targetParticipant - only show relationship with feedback target
  );

  const agentContext = `You are participating in the ideation session.

${profileContext}${memoryContext}`;

  // 피드백 전략에 따라 다른 접근 방식 사용, 하지만 논리적 오류 방지
  const actualHasIdeas = targetMemberIdeas.length > 0;
  const aiJudgedHasIdeas = feedbackStrategy?.hasIdeas;
  
  // 디버깅: feedbackPrompt에 전달된 팀 정보 확인
  console.log(`🔍 feedbackPrompt에서 ${targetMember}의 팀 정보 확인:`);
  console.log(`- teamContext:`, teamContext);
  console.log(`- teamContext.teamMembers:`, teamContext?.teamMembers);
  console.log(`- teamContext.relationships:`, teamContext?.relationships);
  console.log(`- allIdeas:`, allIdeas);
  console.log(`- targetMemberRoles:`, targetMemberRoles);

  // 안전 장치: AI가 잘못 판단한 경우 실제 아이디어 개수를 우선
  let hasIdeas = actualHasIdeas;
  if (aiJudgedHasIdeas !== undefined && aiJudgedHasIdeas !== actualHasIdeas) {
    console.log(`🚨🚨🚨 CRITICAL: AI 판단 오류 감지!`);
    console.log(`🚨 AI가 판단한 hasIdeas: ${aiJudgedHasIdeas}`);
    console.log(`🚨 실제 아이디어 개수: ${actualHasIdeas}`);
    console.log(`🚨 실제값으로 강제 변경됨: ${actualHasIdeas}`);
    hasIdeas = actualHasIdeas;
  } else {
    hasIdeas = aiJudgedHasIdeas ?? actualHasIdeas;
  }
  
  
  let contextSection = "";
  let feedbackGuidelines = "";
  
  if (hasIdeas) {
    // 아이디어가 있는 경우: 아이디어 중심 피드백
    console.log(`🔍 feedbackPrompt에서 ${targetMember}의 아이디어 처리 (hasIdeas=true):`);
    console.log(`- targetMemberIdeas:`, targetMemberIdeas);
    console.log(`- Array인가?:`, Array.isArray(targetMemberIdeas));
    console.log(`- 길이:`, targetMemberIdeas?.length);
    
    const ideasText = targetMemberIdeas.map((idea, index) => 
      `${index + 1}. "${idea.content?.object || '제목 없음'}" - ${idea.content?.function || '설명 없음'}`
    ).join('\n');
    
    console.log(`📝 feedbackPrompt에서 생성된 ideasText (hasIdeas=true):`, ideasText);
    
    contextSection = `**Team Member:** ${targetMember}
**Their Assigned Roles:** ${targetMemberRoles?.join(', ') || 'No specific roles'}
**Their Ideas:**
${ideasText}`;

    feedbackGuidelines = `**Feedback Guidelines:**
- Focus on their specific ideas and provide constructive feedback
- Reference specific details of their ideas
- Suggest improvements, extensions, or alternative approaches
- Use natural Korean language appropriate for your relationship level
- Balance positive recognition with constructive suggestions`;
    
  } else {
    // 아이디어가 없는 경우: 전체 팀 정보와 아이디어를 보여주고 역할 기반 피드백
    const allIdeasText = allIdeas && allIdeas.length > 0 
      ? allIdeas.map((idea, index) => {
          // 작성자 ID를 이름으로 매핑
          let authorName = idea.author;
          if (idea.author === '나') {
            authorName = '나';
          } else if (teamContext?.agentNameMap && teamContext.agentNameMap[idea.author]) {
            authorName = teamContext.agentNameMap[idea.author];
          } else if (teamContext?.teamMembers) {
            const authorMember = teamContext.teamMembers.find((m: any) => 
              m.agentId === idea.author || m.userId === idea.author || m.name === idea.author
            );
            if (authorMember) {
              authorName = authorMember.isUser ? '나' : (authorMember.name || authorMember.agentId || idea.author);
            }
          }
          return `${index + 1}. "${idea.content?.object || '제목 없음'}" (작성자: ${authorName}) - ${idea.content?.function || '설명 없음'}`;
        }).join('\n')
      : '팀에 아직 아이디어가 없습니다.';

    // 팀 멤버 정보 생성 (이름, 역할, 관계)
    const teamMembersInfo = teamContext?.teamMembers?.map((member: any) => {
      const roles = member.roles ? member.roles.join(', ') : '역할 없음';
      const isLeader = member.isLeader ? ' (팀장)' : '';
      let memberName = member.isUser ? '나' : '알 수 없음';
      if (!member.isUser) {
        if (teamContext?.agentNameMap && member.agentId && teamContext.agentNameMap[member.agentId]) {
          memberName = teamContext.agentNameMap[member.agentId];
        } else {
          memberName = member.name || member.agentId || '알 수 없음';
        }
      }
      return `- ${memberName}${isLeader}: ${roles}`;
    }).join('\n') || '팀 멤버 정보 없음';

    // 관계 정보 생성
    const relationshipsInfo = teamContext?.relationships && teamContext.relationships.length > 0
      ? teamContext.relationships.map((rel: any) => {
          let fromName = rel.from === '나' ? '나' : rel.from;
          let toName = rel.to === '나' ? '나' : rel.to;
          
          // agentNameMap을 사용해서 agent ID를 이름으로 변환
          if (rel.from !== '나' && teamContext?.agentNameMap && teamContext.agentNameMap[rel.from]) {
            fromName = teamContext.agentNameMap[rel.from];
          } else if (rel.from !== '나' && teamContext?.teamMembers) {
            const fromMember = teamContext.teamMembers.find((m: any) => m.agentId === rel.from);
            if (fromMember) {
              fromName = fromMember.name || rel.from;
            }
          }
          
          if (rel.to !== '나' && teamContext?.agentNameMap && teamContext.agentNameMap[rel.to]) {
            toName = teamContext.agentNameMap[rel.to];
          } else if (rel.to !== '나' && teamContext?.teamMembers) {
            const toMember = teamContext.teamMembers.find((m: any) => m.agentId === rel.to);
            if (toMember) {
              toName = toMember.name || rel.to;
            }
          }
          const relType = rel.type === 'SUPERVISOR' ? '상사' : rel.type === 'SUBORDINATE' ? '부하' : rel.type === 'PEER' ? '동료' : rel.type;
          return `- ${fromName} → ${toName}: ${relType}`;
        }).join('\n')
      : '설정된 관계 없음';
    
    contextSection = `**Team Member:** ${targetMember}
**Their Assigned Roles:** ${targetMemberRoles?.join(', ') || 'No specific roles'}

**Team Context:**
- Topic: ${teamContext?.topic || 'General ideation'}
- Team Size: ${teamContext?.teamMembers?.length || 'Unknown'} members

**Team Members & Roles:**
${teamMembersInfo}

**Team Relationships:**
${relationshipsInfo}

**All Team Ideas:**
${allIdeasText}`;

    feedbackGuidelines = `**Feedback Guidelines:**
- **Focus on Role Excellence**: Discuss how they can maximize their assigned roles (${targetMemberRoles?.join(', ') || '역할 없음'}) to boost team ideation performance
- **Actionable Role Improvements**: Suggest specific, practical ways they can enhance their role execution for better team outcomes
- **Team Performance Enhancement**: Connect their role improvements to overall team meeting effectiveness and ideation quality
- Consider team relationships and dynamics when suggesting role improvements
- If they have "아이디어 생성하기" role: suggest techniques, approaches, or collaboration methods to generate higher-quality ideas
- If they have "아이디어 평가하기" role: recommend evaluation frameworks or criteria to provide more valuable assessments
- If they have "피드백하기" role: propose feedback strategies that drive better team discussions and idea refinement
- If they have "요청하기" role: suggest strategic request approaches that unlock team potential and facilitate better collaboration
- **Constructive & Executable**: Provide concrete, implementable suggestions they can use immediately in the current meeting
- Use natural Korean language appropriate for your relationship level`;
  }

  const mainPrompt = `Provide natural, conversational feedback to your team member based on the strategic approach below.

${contextSection}

**Feedback Strategy from Analysis:**
- Focus: ${feedbackStrategy?.feedbackFocus || 'General team contribution'}
- Approach: ${feedbackStrategy?.feedbackApproach || 'Supportive and constructive'}
- Key Points: ${feedbackStrategy?.keyPoints || 'Help them improve their contributions'}

${feedbackGuidelines}
- Keep the tone collaborative and supportive
- Keep your feedback concise and focused (2-4 sentences maximum)
- Show your personality and professional background

Provide your feedback in the following JSON format:
{
  "feedback": "Your natural, conversational feedback message in Korean"
}`;

  return { agentContext, mainPrompt };
};

// Feedback response prompt
export const responsePrompt = (
  messageHistory: Array<{
    sender: string;
    content: string;
    timestamp: string;
  }>,
  targetMember: string,
  agentProfile?: any,
  memory?: any,
  targetMemberRoles?: string[],
  targetMemberIdeas?: any[],
  teamContext?: any,
  allIdeas?: any[]
) => {
  const historyText = messageHistory
    .map((msg) => `${msg.sender}: ${msg.content}`)
    .join("\n");

  const { profileContext, memoryContext } = createAgentContextSections(
    agentProfile,
    memory,
    "Respond naturally and authentically to feedback conversations, maintaining your personality and relationship dynamics.",
    "response",
    undefined, // personaSummary
    targetMember // targetParticipant - only show relationship with conversation partner
  );

  
  const hasIdeas = targetMemberIdeas && targetMemberIdeas.length > 0;
  let contextSection = "";
  
  if (hasIdeas) {
    // 아이디어가 있는 경우: 개인 아이디어만 표시
    const ideasText = targetMemberIdeas.map((idea, index) => 
      `${index + 1}. "${idea.content?.object || '제목 없음'}" - ${idea.content?.function || '설명 없음'}`
    ).join('\n');
    
    contextSection = `**Team Member:** ${targetMember}
**Their Assigned Roles:** ${targetMemberRoles?.join(', ') || 'No specific roles'}
**Their Ideas:**
${ideasText}`;
  } else {
    // 아이디어가 없는 경우: 팀 전체 정보 표시
    const allIdeasText = allIdeas && allIdeas.length > 0 
      ? allIdeas.map((idea, index) => {
          // 작성자 ID를 이름으로 매핑
          let authorName = idea.author;
          if (idea.author === '나') {
            authorName = '나';
          } else if (teamContext?.agentNameMap && teamContext.agentNameMap[idea.author]) {
            authorName = teamContext.agentNameMap[idea.author];
          } else if (teamContext?.teamMembers) {
            const authorMember = teamContext.teamMembers.find((m: any) => 
              m.agentId === idea.author || m.userId === idea.author || m.name === idea.author
            );
            if (authorMember) {
              authorName = authorMember.isUser ? '나' : (authorMember.name || authorMember.agentId || idea.author);
            }
          }
          return `${index + 1}. "${idea.content?.object || '제목 없음'}" (작성자: ${authorName}) - ${idea.content?.function || '설명 없음'}`;
        }).join('\n')
      : '팀에 아직 아이디어가 없습니다.';

    // 팀 멤버 정보 생성
    const teamMembersInfo = teamContext?.teamMembers?.map((member: any) => {
      const roles = member.roles ? member.roles.join(', ') : '역할 없음';
      const isLeader = member.isLeader ? ' (팀장)' : '';
      let memberName = member.isUser ? '나' : '알 수 없음';
      if (!member.isUser) {
        if (teamContext?.agentNameMap && member.agentId && teamContext.agentNameMap[member.agentId]) {
          memberName = teamContext.agentNameMap[member.agentId];
        } else {
          memberName = member.name || member.agentId || '알 수 없음';
        }
      }
      return `- ${memberName}${isLeader}: ${roles}`;
    }).join('\n') || '팀 멤버 정보 없음';

    // 관계 정보 생성
    const relationshipsInfo = teamContext?.relationships && teamContext.relationships.length > 0
      ? teamContext.relationships.map((rel: any) => {
          let fromName = rel.from === '나' ? '나' : rel.from;
          let toName = rel.to === '나' ? '나' : rel.to;
          
          // agentNameMap을 사용해서 agent ID를 이름으로 변환
          if (rel.from !== '나' && teamContext?.agentNameMap && teamContext.agentNameMap[rel.from]) {
            fromName = teamContext.agentNameMap[rel.from];
          } else if (rel.from !== '나' && teamContext?.teamMembers) {
            const fromMember = teamContext.teamMembers.find((m: any) => m.agentId === rel.from);
            if (fromMember) {
              fromName = fromMember.name || rel.from;
            }
          }
          
          if (rel.to !== '나' && teamContext?.agentNameMap && teamContext.agentNameMap[rel.to]) {
            toName = teamContext.agentNameMap[rel.to];
          } else if (rel.to !== '나' && teamContext?.teamMembers) {
            const toMember = teamContext.teamMembers.find((m: any) => m.agentId === rel.to);
            if (toMember) {
              toName = toMember.name || rel.to;
            }
          }
          const relType = rel.type === 'SUPERVISOR' ? '상사' : rel.type === 'SUBORDINATE' ? '부하' : rel.type === 'PEER' ? '동료' : rel.type;
          return `- ${fromName} → ${toName}: ${relType}`;
        }).join('\n')
      : '설정된 관계 없음';
    
    contextSection = `**Team Member:** ${targetMember}
**Their Assigned Roles:** ${targetMemberRoles?.join(', ') || 'No specific roles'}

**Team Context:**
- Topic: ${teamContext?.topic || 'General ideation'}
- Team Size: ${teamContext?.teamMembers?.length || 'Unknown'} members

**Team Members & Roles:**
${teamMembersInfo}

**Team Relationships:**
${relationshipsInfo}

**All Team Ideas:**
${allIdeasText}`;
  }
    

  const agentContext = `${profileContext}${memoryContext}`;
  
  const mainPrompt = `You are in a meeting with ${targetMember}, aim for a constructive conversation that yields immediately applicable insights or outcomes.

${contextSection}

**Response Guidelines:**
- Use appropriate Korean language level based on your relationship
- Respond naturally and conversationally to the most recent message (not too formal)
- Let your personality and speaking style show through clearly (casual/formal speech, unique speech patterns, personality traits)
- Keep responses short and natural (1-3 sentences maximum)
- Respond to specific points raised in the conversation${!hasIdeas ? '\n- **Role Performance Focus**: Since they currently have no ideas, guide the conversation toward practical ways they can excel in their assigned roles to boost team meeting effectiveness\n- **Constructive Role Development**: Discuss actionable improvements they can implement immediately to enhance their contribution to the ideation process' : ''}

**Session Continuation Decision:**
Based on the conversation flow and your assessment, decide whether to continue or end this feedback session.

**Consider CONTINUING (shouldEnd: false) when:**
- when fresh insights or clarifications are still valuable and the discussion remains productive, deepening understanding and rapport.

**Consider ENDING (shouldEnd: true) when:**
- when core feedback is fully covered, goals are met, mutual understanding is clear, and the conversation feels naturally complete.

**Note:** The system will ensure minimum conversation length requirements are met.
**Conversation History:**
${historyText}

Provide your response in the following JSON format:
{
  "response": "Your natural, conversational response in Korean",
  "reasoning": "Brief explanation of your decision to continue or end",
  "shouldEnd": true
}`;

  return { agentContext, mainPrompt };
};

// ==========================================================================
// ## REQUEST
// ==========================================================================

// Pre-request planning prompt
export const preRequestPrompt = (
  triggerContext: string, // Context that triggered the request (received direct request or decided in plan)
  teamMembers: Array<{
    name: string;
    roles: string[];
    isUser: boolean;
    agentId?: string;
    userInfo?: {
      // 인간 팀원인 경우 추가 정보
      age?: number;
      gender?: string;
      professional?: string;
      skills?: string;
      personality?: string;
      value?: string;
    };
  }>,
  currentIdeas: Array<{
    ideaNumber: number;
    authorName: string;
    object: string;
    function: string;
  }>,
  memory?: AgentMemory,
  agentProfile?: any
) => {
  const teamMembersInfo = teamMembers
    .map((member) => {
      const memberType = member.isUser ? "Human User" : "AI Agent";
      let memberDetails = `- ${
        member.name
      } (${memberType}): Roles - ${member.roles.join(", ")}`;

      // 인간 팀원인 경우 추가 정보 포함
      if (member.isUser && member.userInfo) {
        const info = member.userInfo;
        const details = [];
        if (info.age) details.push(`${info.age}세`);
        if (info.professional) details.push(`직업: ${info.professional}`);
        if (info.skills) details.push(`스킬: ${info.skills}`);
        if (info.personality) details.push(`성격: ${info.personality}`);

        if (details.length > 0) {
          memberDetails += `\n    → ${details.join(", ")}`;
        }
      }

      return memberDetails;
    })
    .join("\n");

  const currentIdeasInfo =
    currentIdeas.length > 0
      ? currentIdeas
          .map(
            (idea) =>
              `${idea.ideaNumber}. "${idea.object}" (Author: ${idea.authorName})`
          )
          .join("\n")
      : "No ideas have been generated yet.";

  const { profileContext, memoryContext } = createAgentContextSections(
    agentProfile,
    memory,
    "Strategically analyze team members and make requests that leverage their strengths while advancing team goals.",
    "request",
    undefined, // personaSummary
    undefined // targetParticipant - show all relationships for request planning
  );

  return `${profileContext}${memoryContext}You are making a request to another team member in the team ideation session. Strategically analyze who to request and what to request.

**Request Context:**
${triggerContext}

**Team Member Information:**
${teamMembersInfo}

**Current Ideas Status:**
${currentIdeasInfo}

**Analysis Required:**
1. Choose who to request (only within the roles that team member can perform)
2. Decide what to request (choose from "generate_idea", "evaluate_idea", "give_feedback")
3. Develop request strategy (why request this work from this team member, what perspective to approach from, considering their background)
4. Consider team member's background and expertise when making the request

**Important Constraints:**
- Can only request within the scope of roles that team member has
- Request must be specific and actionable
- Consider avoiding duplicate work
- For human users, consider their professional background and skills when crafting requests
- For AI agents, consider their programmed personality and capabilities

Respond only in the following JSON format:
{
  "targetMember": "Name of team member to request",
  "requestType": "generate_idea" | "evaluate_idea" | "give_feedback",
  "requestStrategy": "Explanation of request strategy (why request this work from this team member, what perspective to approach from, considering their background)",
  "contextToProvide": "Specific context or background information to provide with the request"
}

Start your analysis now and respond only in the following JSON format:`;
};

// Execute request prompt
export const requestPrompt = (
  targetMember: string,
  requestType: string,
  requestStrategy: string,
  contextToProvide: string,
  targetMemberRoles: string[],
  relationshipType?: string,
  memory?: AgentMemory,
  originalRequest?: string,
  originalRequester?: string,
  targetMemberInfo?: {
    // 인간 팀원인 경우 추가 정보
    isUser: boolean;
    age?: number;
    gender?: string;
    professional?: string;
    skills?: string;
    personality?: string;
    value?: string;
  },
  agentProfile?: any
) => {
  const relationshipDescription = relationshipType
    ? {
        PEER: "As colleagues, communicate in a professional and collaborative tone.",
        SUPERVISOR:
          "As this person's supervisor, communicate in a friendly yet guiding tone. Use informal speech as is appropriate for a superior addressing a subordinate in Korean workplace culture.",
        SUBORDINATE:
          "As this person's subordinate, use respectful language and maintain a formal tone.",
        NULL: "You have no established relationship with this person, so you cannot directly interact with them for feedback or requests.",
      }[relationshipType] || "Communicate as general team members."
    : "Communicate as general team members.";

  // 타겟 멤버 정보 추가
  const targetMemberDetails = targetMemberInfo
    ? `
**Target Member Details:**
- Type: ${targetMemberInfo.isUser ? "Human User" : "AI Agent"}
- Roles: ${targetMemberRoles.join(", ")}${
        targetMemberInfo.isUser && targetMemberInfo.professional
          ? `\n- Professional Background: ${targetMemberInfo.professional}`
          : ""
      }${
        targetMemberInfo.isUser && targetMemberInfo.skills
          ? `\n- Skills: ${targetMemberInfo.skills}`
          : ""
      }${
        targetMemberInfo.isUser && targetMemberInfo.personality
          ? `\n- Personality: ${targetMemberInfo.personality}`
          : ""
      }
`
    : `
**Target Member Details:**
- Roles: ${targetMemberRoles.join(", ")}
`;

  const { profileContext, memoryContext } = createAgentContextSections(
    agentProfile,
    memory,
    "Craft requests strategically, considering relationships and team dynamics to maximize effectiveness.",
    "request",
    undefined, // personaSummary
    targetMember // targetParticipant - show only relationship with request target
  );

  const isDelegation = originalRequest && originalRequester;

  if (isDelegation) {
    return `${profileContext}${memoryContext}You are delegating a request received from ${originalRequester} to ${targetMember}.

${targetMemberDetails}

**Original Request from ${originalRequester}:**
"${originalRequest}"

**Delegation Strategy:**
${requestStrategy}

**Context to Provide:**
${contextToProvide}

**Request Type:** ${requestType}

Based on the analysis, craft a natural and conversational message to delegate this request to ${targetMember}. Consider the following:
- ${relationshipDescription}
- Explain why you're delegating this specific request to them
- Provide the necessary context for them to act on the request
- Be clear about what specific action you want them to take
- Reference the original requester if appropriate

Write in Korean using casual but respectful language.

Respond only in the following JSON format:
{
  "message": "Your delegation message to ${targetMember} in Korean"
}`;
  } else {
    return `${profileContext}${memoryContext}You are making a request to ${targetMember} based on your strategic analysis.

${targetMemberDetails}

**Request Analysis:**
- Target: ${targetMember}
- Request Type: ${requestType}
- Strategy: ${requestStrategy}
- Context: ${contextToProvide}

Based on the analysis, craft a natural and conversational message to request ${requestType} from ${targetMember}. Consider the following:
- ${relationshipDescription}
- Explain why you're specifically requesting this from them
- Provide any necessary context or background
- Be clear about what specific action you want them to take
- Consider their expertise and background when framing the request

Write in Korean using casual but respectful language.

Respond only in the following JSON format:
{
  "message": "Your request message to ${targetMember} in Korean"
}`;
  }
};

// ==========================================================================
// ## PLANNING
// ==========================================================================

// Planning prompt - agents decide their next action autonomously
export function planningPrompt(
  agentProfile: any,
  teamContext: {
    teamName: string;
    topic: string;
    currentIdeasCount: number;
    recentMessages: any[];
    teamMembers: string[];
    existingIdeas: Array<{
      ideaNumber: number;
      authorName: string;
      object: string;
      function: string;
    }>;
    sharedMentalModel?: string;
    relationships?: any[];
    agentNameMap?: { [agentId: string]: string };
    canGiveFeedback?: boolean;
    canMakeRequest?: boolean;
  },
  memory?: any
): { agentContext: string; mainPrompt: string } {
  // 최근 메시지에서 각 액션 타입별 빈도 분석
  const recentActions = teamContext.recentMessages
    .map((msg) => {
      // make_request 타입 메시지 직접 감지
      if (msg.type === "make_request") {
        return { action: "make_request", author: msg.sender };
      }
      
      // 시스템 메시지에서 다른 액션들 감지
      if (
        msg.type === "system" &&
        typeof msg.payload === "object" &&
        msg.payload.content
      ) {
        const content = msg.payload.content;
        if (content.includes("생성했습니다"))
          return { action: "generate_idea", author: msg.sender };
        if (content.includes("평가했습니다"))
          return { action: "evaluate_idea", author: msg.sender };
        if (content.includes("피드백 세션"))
          return { action: "give_feedback", author: msg.sender };
      }
      
      return null;
    })
    .filter(
      (item): item is { action: string; author: string } => item !== null
    );

  // 액션별 빈도 계산
  const actionFrequency = {
    generate_idea: recentActions.filter((a) => a.action === "generate_idea")
      .length,
    evaluate_idea: recentActions.filter((a) => a.action === "evaluate_idea")
      .length,
    give_feedback: recentActions.filter((a) => a.action === "give_feedback")
      .length,
    make_request: recentActions.filter((a) => a.action === "make_request")
      .length,
  };

  // 가장 적게 수행된 액션들 찾기 (참고용)
  const minFrequency = Math.min(...Object.values(actionFrequency));
  const underperformedActions = Object.entries(actionFrequency)
    .filter(([, freq]) => freq === minFrequency)
    .map(([action]) => action);

  // 본인의 최근 액션 패턴 분석
  const myRecentActions = recentActions
    .filter((a) => a.author === agentProfile.name)
    .slice(-3)
    .map((a) => a.action);

  const actionFrequencyText = Object.entries(actionFrequency)
    .map(([action, freq]) => `${action}: ${freq}`)
    .join(", ");

  const balanceAnalysis =
    underperformedActions.length > 0
      ? `Least performed actions: ${underperformedActions.join(", ")} (consider prioritizing)`
      : "All actions performed evenly";

  const myActionPattern =
    myRecentActions.length > 0
      ? `Your recent pattern: ${myRecentActions.join(" → ")} (vary your contributions)`
      : "No previous actions";

  const { profileContext, memoryContext } = createAgentContextSections(
    agentProfile,
    memory,
    "Plan your next action strategically, considering team balance, your role constraints, and current needs.",
    "planning",
    undefined, // personaSummary
    undefined // targetParticipant - show all relationships for planning
  );

  const agentContext = `${profileContext}${memoryContext}`;
  
  const mainPrompt = `You are AI agent ${agentProfile.name} in the "${
    teamContext.teamName
  }" team. You are currently in the planning phase. Based on your role, personality, current team situation, and team action balance, decide what to do next.

Current Team Situation:
- Topic: ${teamContext.topic}
- Current number of ideas: ${teamContext.currentIdeasCount}
- **Team members**: ${teamContext.teamMembers.join(", ")}

Recent Team Activity (Last ${teamContext.recentMessages.length} messages):
${teamContext.recentMessages
  .filter((msg) => msg.sender !== "system" && msg.payload !== undefined && msg.payload !== null)
  .map((msg) => {
    // agent ID를 실제 이름으로 변환
    let senderName = msg.sender;
    if (msg.sender === "나") {
      senderName = "나";
    } else if (teamContext?.agentNameMap && teamContext.agentNameMap[msg.sender]) {
      senderName = teamContext.agentNameMap[msg.sender];
    }
    
    const content = typeof msg.payload === "object" ? msg.payload.content : msg.payload;
    return `- ${senderName}: ${content}`;
  })
  .join("\n")}

${(() => {
  // 팀 관계 정보 생성 (responsePrompt와 동일한 로직)
  if (teamContext.relationships && teamContext.relationships.length > 0) {
    const relationshipsInfo = teamContext.relationships.map((rel: any) => {
      let fromName = rel.from === '나' ? '나' : rel.from;
      let toName = rel.to === '나' ? '나' : rel.to;
      
      // agentNameMap을 사용해서 agent ID를 이름으로 변환
      if (rel.from !== '나' && teamContext?.agentNameMap && teamContext.agentNameMap[rel.from]) {
        fromName = teamContext.agentNameMap[rel.from];
      }
      if (rel.to !== '나' && teamContext?.agentNameMap && teamContext.agentNameMap[rel.to]) {
        toName = teamContext.agentNameMap[rel.to];
      }
      
      const relType = rel.type === 'SUPERVISOR' ? '상사' : rel.type === 'SUBORDINATE' ? '부하' : rel.type === 'PEER' ? '동료' : rel.type;
      return `- ${fromName} → ${toName}: ${relType}`;
    }).join('\n');
    
    return `Team Relationships:
${relationshipsInfo}

`;
  }
  return '';
})()}Team Action Balance Analysis:
- Action frequency: ${actionFrequencyText}
- ${balanceAnalysis}
- ${myActionPattern}

🎯 ACTION SELECTION GUIDANCE:
**Role Constraints**: You may only perform actions within your assigned roles.
**Team Balance**: ${balanceAnalysis}
**Diversification**: Avoid repeating the same actions. Choose what feels natural for your personality and expertise while contributing in diverse ways.

Available Actions (ONLY within your assigned roles):
1. "generate_idea" - Generate new ideas for the topic ${
    agentProfile.roles?.includes("아이디어 생성하기") ? "✅" : "❌"
  }
2. "evaluate_idea" - Evaluate existing ideas (only when there are ideas to evaluate) ${
    agentProfile.roles?.includes("아이디어 평가하기") ? "✅" : "❌"
  }
3. "give_feedback" - Provide feedback to team members ${
    agentProfile.roles?.includes("피드백하기") ? 
      (teamContext.canGiveFeedback ? "✅" : "❌ (역할 있음, 관계 없음)") : 
      "❌ (역할 없음)"
  }
4. "make_request" - Request work from other team members ${
    agentProfile.roles?.includes("요청하기") ? 
      (teamContext.canMakeRequest ? "✅" : "❌ (역할 있음, 관계 없음)") : 
      "❌ (역할 없음)"
  }
5. "wait" - Return to waiting state (always available)

Decision Considerations:
🔹 ROLE CONSTRAINT: You can ONLY perform actions within your assigned roles (marked with ✅)
🔹 RELATIONSHIP CONSTRAINT: Feedback and requests are only possible if you have established relationships with team members
${teamContext.canGiveFeedback === false ? "⚠️ You currently have no relationships that allow giving feedback" : ""}
${teamContext.canMakeRequest === false ? "⚠️ You currently have no relationships that allow making requests" : ""}
${(() => {
  const hasIdeation = agentProfile.roles?.includes("아이디어 생성하기");
  const hasEvaluation = agentProfile.roles?.includes("아이디어 평가하기");
  const hasRequest = agentProfile.roles?.includes("요청하기");
  const hasFeedback = agentProfile.roles?.includes("피드백하기");
  const coreRoles = [];
  
  if (hasIdeation) coreRoles.push("아이디어 생성하기");
  if (hasEvaluation) coreRoles.push("아이디어 평가하기");
  if (hasRequest) coreRoles.push("요청하기");
  if (hasFeedback) coreRoles.push("피드백하기");
  
  if (coreRoles.length > 0) {
    const contributions = [];
    if (hasIdeation) contributions.push("Generate creative ideas to drive innovation");
    if (hasEvaluation) contributions.push("Evaluate ideas to ensure quality and feasibility");
    if (hasRequest) contributions.push("Coordinate team work and request assistance when needed");
    if (hasFeedback) contributions.push("Provide developmental feedback to improve collaboration");
    
    return `🔹 **PRIMARY ROLE FOCUS**: Your main responsibility is ${coreRoles.join(" and ")} - prioritize these actions when appropriate
🔹 CORE CONTRIBUTION: ${contributions.join(" / ")}`;
  }
  return "";
})()}

**Priority at a Glance**  
   "evaluate_idea" and "generate_idea" ▶ "make_request" and "give_feedback" ▶ "wait"

IMPORTANT: Do not select actions outside your role permissions. This will result in automatic conversion to "wait".

Respond only in the following JSON format.:
{
  "reasoning": "Detailed explanation of why you chose this action, considering team balance, your role constraints, and strategic priorities",
  "action": "generate_idea" | "evaluate_idea" | "give_feedback" | "make_request" | "wait",
  "target": "Team member name if giving feedback or making a request (optional)"
}`;

  return { agentContext, mainPrompt };
}

// ==========================================================================
// ## OTHER PROMPTS
// ==========================================================================

// Memory-related prompts

export const createSelfReflectionPrompt = (
  agentProfile: any,
  team: any,
  idea: any,
  isAutonomous: boolean,
  currentSelfReflection: string
) => `
You are ${agentProfile.name}.

**Your Information:**
- Name: ${agentProfile.name}
- Age: ${agentProfile.age}세
- Gender: ${agentProfile.gender}
- Professional Background: ${agentProfile.professional}
- Skills: ${agentProfile.skills}
- Personality: ${agentProfile.personality || "정보 없음"}
- Values: ${agentProfile.value || "정보 없음"}
- Work Style: ${agentProfile.workStyle || "협력적"}

**What Just Happened:**
${
  isAutonomous
    ? `You autonomously planned and generated a new idea: "${idea.content.object}"`
    : `You generated a new idea in response to a team member's request: "${idea.content.object}"`
}

**Team Context:**
- Team Name: ${team.teamName}
- Topic: ${team.topic || "Carbon Emission Reduction"}

**Current Self-Reflection:**
${
  typeof currentSelfReflection === "string" && currentSelfReflection.trim()
    ? currentSelfReflection
    : "아직 특별한 성찰 내용이 없습니다."
}

Based on your experience of just generating an idea, please update your self-reflection. 
Build upon your existing reflection, but include what this new experience means to you, 
and any new insights you've gained about your personality or work style.

**Response Format:**
Write in a concise and natural style, within 200 Korean characters.
`;

export const createRelationOpinionPrompt = (
  relation: any,
  context: string
) => `
You are an AI agent forming opinions about other team members.

Target Agent Information:
- Name: ${relation.agentInfo.name}
- Professional Background: ${relation.agentInfo.professional}
- Relationship Status: ${relation.relationship}

Recent Interactions:
${relation.interactionHistory
  .slice(-5)
  .map(
    (interaction: any) =>
      `- ${interaction.action}: ${interaction.content} (${interaction.timestamp})`
  )
  .join("\n")}

Current Context: ${context}

Existing Opinion: ${relation.myOpinion}

Based on the above information, please write a new opinion about this person in 1-2 sentences. 
Reference your existing opinion, but update it to reflect recent interactions.
Respond only in plain text format, not JSON format.
`;

export const createDeepSelfReflectionPrompt = (
  currentReflection: string,
  newExperience: string,
  triggeringEvent: string
) => `
You are an AI agent working in a team. Please update your self-reflection based on new experiences.

Current Reflection:
${currentReflection || "아직 특별한 성찰 내용이 없습니다."}

New Experience:
${newExperience}

Triggering Event: ${triggeringEvent}

Based on the above content, please write your reflection following these guidelines:

1. **Reflective Attitude**: Deeply reflect on your actions and emotions
2. **Learning and Growth**: Reflect on what you learned from this experience  
3. **Future-Oriented**: Commit to how you will improve and develop going forward
4. **Team-Oriented**: Think about relationships and collaboration with team members

If you have existing reflection content, develop it further and integrate the new experience for a deeper, updated reflection.
Please write in one paragraph of about 200-300 Korean characters.
`;

export const createMemoryCompressionPrompt = (
  agentName: string,
  oldInteractions: any[]
) => `
The following are interaction records with ${agentName}. 
Please compress these into 5-7 key interaction summaries.

Interaction Records:
${oldInteractions.map((i) => `- ${i.action}: ${i.content}`).join("\n")}

Please write each summary in the following format:
{
  "action": "compressed_summary",
  "content": "요약된 상호작용 내용",
  "timestamp": "${new Date().toISOString()}"
}

Please respond with a JSON array.
`;

// Memory-v2 related prompts

export const createKnowledgeAndActionPlanUpdatePrompt = (
  agentProfile: any,
  memory: any,
  interactionSummary: string
) => `
You are ${agentProfile.name}, an AI agent participating in a team ideation session.

==================== ① YOUR CONTEXT ====================
• Name: ${agentProfile.name}
• Professional Background: ${agentProfile.professional}
• Skills: ${agentProfile.skills}
• Personality: ${agentProfile.personality || "No information"}

=== Current Knowledge Base ===
${memory.longTerm.knowledge}

=== Current Action Plans ===
idea_generation: ${memory.longTerm.actionPlan.idea_generation}
idea_evaluation: ${memory.longTerm.actionPlan.idea_evaluation}
feedback:        ${memory.longTerm.actionPlan.feedback}
request:         ${memory.longTerm.actionPlan.request}
response:        ${memory.longTerm.actionPlan.response}
planning:        ${memory.longTerm.actionPlan.planning}

==================== ② NEW INPUT =======================
Recent Interaction Log:
${interactionSummary}

==================== ③ UPDATE DECISION =================
Update ONLY if you gained **significant new design knowledge** (e.g., principles, frameworks, user constraints, technical insights).  
Ignore routine idea creation/evaluation, minor status updates, or information you already know.

==================== ④ REASON & METHOD =================
Apply the 4-step lens **(Pattern → Context → Prediction → Meta-reflection)** to derive insights.

If updating:
1. **Knowledge** - Append insights; keep existing content.
2. **Action Plan** - Update **max TWO** most relevant categories with actual action plans (2-3 sentences each). For unchanged categories, provide the current action plan content.

==================== ⑤ OUTPUT FORMAT ===================
Return valid JSON, English only. For actionPlan, provide the ACTUAL action plan content, not meta-information like "updated" or "unchanged".

{
  "knowledge": "<your updated knowledge content>",
  "actionPlan": {
    "idea_generation": "<actual action plan for idea generation>",
    "idea_evaluation": "<actual action plan for idea evaluation>", 
    "feedback": "<actual action plan for feedback>",
    "request": "<actual action plan for requests>",
    "response": "<actual action plan for responses>",
    "planning": "<actual action plan for planning>"
  }
}
`;

export const createRelationOpinionUpdatePrompt = (
  relation: any,
  interactionSummary: string
) => `
You will refine your opinion of teammate **${relation.agentInfo.name}**.

### 🎯 Input
- **Role / Background**: ${relation.agentInfo.professional}
- **Relationship**: ${relation.relationship}
- **Current Opinion**: ${relation.myOpinion}

### 📝 Recent Interactions
${interactionSummary}

### 🔍 Analysis Lens
1. **Patterns → Traits** - Link repeated behaviors to personality & values  
2. **Motivations** - What drives their choices & collaboration style  
3. **Predictions** - How they’ll likely react to requests, feedback, challenges  
4. **Strategy** - Best ways to leverage strengths, mitigate issues  

### ⚙️ Enhancement Rules
• Keep useful insights, add deeper causal reasoning  
• Deduce motivations & preferences, forecast future behavior  
• Deliver actionable collaboration tips  

### Output
- **English only, ≤ 250 characters**  
- Objective, causal (“Their habit of X implies Y”), predictive (“Thus they’ll respond to Z”), strategic (“Best approach: …”)  
- Return **only** the updated opinion string—no headers or extra text.
`;

// Feedback session summary prompt
export const generateFeedbackSessionSummaryPrompt = (
  sessionParticipants: string[],
  conversationHistory: Array<{
    sender: string;
    content: string;
    timestamp: string;
  }>
) => {
  const conversationText = conversationHistory
    .map((msg) => `${msg.sender}: ${msg.content}`)
    .join("\n");

  return {
    agentContext: `You are an AI assistant specialized in analyzing team feedback conversations and extracting key insights about collaboration patterns and team dynamics.`,
    mainPrompt: `Please analyze the following feedback conversation and create a comprehensive summary.

**Participants:** ${sessionParticipants.join(", ")}

**Conversation:**
${conversationText}

Create a summary that captures:
1. **Main Topics Discussed**: Key themes and subjects covered
2. **Feedback Provided**: Specific feedback given between participants
3. **Insights Shared**: Important insights or suggestions exchanged
4. **Collaboration Patterns**: How participants interacted and collaborated
5. **Action Items**: Any next steps or commitments made

Write the summary in Korean and keep it concise but comprehensive.

Respond in the following JSON format:
{
  "summary": "피드백 세션의 주요 내용, 제공된 피드백, 공유된 인사이트, 그리고 협업 패턴을 포함한 종합적인 요약"
}`
  };
};

// Agent persona summary prompt
export const generateAgentPersonaSummaryPrompt = (
  agentProfile: any,
  sharedMentalModel?: string
) => `
You are an AI assistant who turns individual Agent profiles into concise, actionable persona summaries.
Rather than simply summarizing the persona, please infer how that persona might behave.

### 🧑‍💼 Agent Profile
- **Name**: ${agentProfile.name}
- **Age**: ${agentProfile.age}세
- **Gender**: ${agentProfile.gender}
- **Nationality**: ${agentProfile.nationality}
- **Education / Major**: ${agentProfile.education} / ${agentProfile.major}
- **Background**: ${agentProfile.professional}
- **Skills**: ${agentProfile.skills}
- **Personality**: ${agentProfile.personality || "정보 없음"}
- **Values**: ${agentProfile.value || "정보 없음"}
- **Work Style**: ${agentProfile.workStyle || "정보 없음"}
- **Preferences**: ${agentProfile.preferences || "정보 없음"}
- **Dislikes**: ${agentProfile.dislikes || "정보 없음"}

${sharedMentalModel ? `### 🤝 Shared Mental Model of the team
${sharedMentalModel}
` : ""}

### 🎯 Persona Summary Requirements (200-300 words)
1. **Personality in Action** - How traits surface at work  
2. **Professional Approach** - Skills & background → problem-solving style  
3. **Collaboration Style** - Preferred ways of working with others  
4. **Communication** - Likely tone, channels, cadence  
5. **Decision-Making** - How they choose & handle challenges  
6. **Team Contribution** - Reflects the mental model shared by the team

**Guidelines:**  
• English only (internal use) • Specific & behavior-focused • Cohesive narrative

### 📤 Output (JSON only)
{
  "personaSummary": "<your 200-300 word summary here>"
}
`;

