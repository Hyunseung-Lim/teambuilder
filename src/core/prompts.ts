import { AgentMemory } from "@/lib/types";

// Common function to generate agent context sections
export const createAgentContextSections = (
  agentProfile?: any,
  memory?: any,
  actionSpecificMessage?: string,
  actionType?: string, // Specific action type to include only relevant actionPlan
  personaSummary?: string, // Individual persona summary generated by GPT-4o
  _targetParticipant?: string // Specific participant to filter relationships for (unused after refactor)
) => {
  // Agent profile section with persona integration
  const profileContext = agentProfile
    ? `
**Your Identity & Professional Persona:**
- Name: ${agentProfile.name}
- Age: ${agentProfile.age}ÏÑ∏
- Gender: ${agentProfile.gender}
- Nationality: ${agentProfile.nationality}
- Education: ${agentProfile.education}
- Major: ${agentProfile.major}
- Professional Background: ${agentProfile.professional}

**You behave in the following manner:**
${personaSummary || `You are ${agentProfile.name}, bringing your unique combination of professional expertise, personality traits, and values to every interaction. Your ${agentProfile.professional} background shapes how you see problems and solutions. Let your authentic self drive your participation and collaboration with the team.`}

${agentProfile.isLeader 
  ? "As the team leader, take initiative, guide the team's ideation process, and use your persona summary to shape your leadership style and team interactions."
  : (actionSpecificMessage || "Contribute to the team in ways that align with your persona summary and feel genuinely authentic to who you are.")
}
`
    : "";

  // Memory context section with enhanced relationship awareness
  const memoryContext = memory
    ? `
**Your Memory and Experience:**
${(() => {
  let formattedMemory = "";

  // v2 Î©îÎ™®Î¶¨ Íµ¨Ï°∞ ÌôïÏù∏
  if (
    memory.longTerm?.knowledge ||
    memory.longTerm?.actionPlan ||
    memory.longTerm?.relation
  ) {
    // v2 Î©îÎ™®Î¶¨ Ï≤òÎ¶¨
    if (memory.longTerm.knowledge) {
      formattedMemory += `- Knowledge: ${memory.longTerm.knowledge}\n`;
    }
    // Include only relevant actionPlan based on actionType, or all if no specific type
    if (!actionType || actionType === 'idea_generation' || actionType === 'generate_idea') {
      if (memory.longTerm.actionPlan?.idea_generation) {
        formattedMemory += `- Idea Generation Strategy: ${memory.longTerm.actionPlan.idea_generation}\n`;
      }
    }
    if (!actionType || actionType === 'idea_evaluation' || actionType === 'evaluate_idea') {
      if (memory.longTerm.actionPlan?.idea_evaluation) {
        formattedMemory += `- Evaluation Strategy: ${memory.longTerm.actionPlan.idea_evaluation}\n`;
      }
    }
    if (!actionType || actionType === 'feedback' || actionType === 'give_feedback') {
      if (memory.longTerm.actionPlan?.feedback) {
        formattedMemory += `- Feedback Strategy: ${memory.longTerm.actionPlan.feedback}\n`;
      }
    }
    if (!actionType || actionType === 'request' || actionType === 'make_request') {
      if (memory.longTerm.actionPlan?.request) {
        formattedMemory += `- Request Strategy: ${memory.longTerm.actionPlan.request}\n`;
      }
    }
    if (!actionType || actionType === 'response') {
      if (memory.longTerm.actionPlan?.response) {
        formattedMemory += `- Response Strategy: ${memory.longTerm.actionPlan.response}\n`;
      }
    }
    if (!actionType || actionType === 'planning') {
      if (memory.longTerm.actionPlan?.planning) {
        formattedMemory += `- Planning Strategy: ${memory.longTerm.actionPlan.planning}\n`;
      }
    }
    
    // Recent actions summary (skip detailed relationships, show key recent activities)
    if (
      memory.longTerm.relation &&
      Object.keys(memory.longTerm.relation).length > 0
    ) {
      // Collect recent interactions across all team members
      const allRecentInteractions: any[] = [];
      Object.entries(memory.longTerm.relation).forEach(([memberId, relationData]: [string, any]) => {
        const recentInteractions = relationData.interactionHistory?.slice(-2) || [];
        recentInteractions.forEach((interaction: any) => {
          allRecentInteractions.push({
            ...interaction,
            withMember: relationData.agentInfo?.name || relationData.name || memberId
          });
        });
      });
      
      // Show only the most recent 2 activities
      const lastTwoActivities = allRecentInteractions.slice(-2);
      if (lastTwoActivities.length > 0) {
        formattedMemory += `\n**Recent Activities:**\n`;
        lastTwoActivities.forEach((activity: any) => {
          formattedMemory += `- ${activity.actionItem}${activity.withMember ? ` with ${activity.withMember}` : ''}\n`;
        });
      }
    }
  } else {
    // Í∏∞Ï°¥ Î©îÎ™®Î¶¨ Íµ¨Ï°∞ Ï≤òÎ¶¨
    if (memory.longTerm?.self) {
      const selfReflection =
        typeof memory.longTerm.self === "string"
          ? memory.longTerm.self
          : Array.isArray(memory.longTerm.self) &&
            memory.longTerm.self.length > 0
          ? memory.longTerm.self[memory.longTerm.self.length - 1]
          : "";
      if (selfReflection) {
        formattedMemory += `- Self Reflection: ${selfReflection}\n`;
      }
    }
    if (
      memory.longTerm?.relations &&
      Object.keys(memory.longTerm.relations).length > 0
    ) {
      const relationshipDescriptions = Object.entries(memory.longTerm.relations)
        .map(([memberId, relationData]: [string, any]) => {
          const relationshipType = relationData.relationship || 'colleague';
          const opinion = relationData.myOpinion || 'professional working relationship';
          const memberName = relationData.agentInfo?.name || memberId;
          return `${memberName} (${relationshipType}): ${opinion}`;
        })
        .join('; ');
      
      formattedMemory += `- Team Relationships: ${relationshipDescriptions}\n`;
    }
  }

  // Recent Actions Ï≤òÎ¶¨ (ÏµúÍ∑º 2Í∞úÍπåÏßÄ)
  const recentActions = [];
  
  if (memory.shortTerm?.lastAction) {
    recentActions.push(memory.shortTerm.lastAction);
  }
  
  // Ï∂îÍ∞Ä Ïï°ÏÖòÎì§Ïù¥ ÏûàÎã§Î©¥ Î∞∞Ïó¥ÏóêÏÑú Í∞ÄÏ†∏Ïò§Í∏∞
  if (memory.shortTerm?.recentActions && Array.isArray(memory.shortTerm.recentActions)) {
    recentActions.push(...memory.shortTerm.recentActions);
  }
  
  // ÏµúÏã†ÏàúÏúºÎ°ú Ï†ïÎ†¨ÌïòÍ≥† ÏµúÍ∑º 2Í∞úÎßå ÏÑ†ÌÉù
  const sortedActions = recentActions
    .filter(action => action && action.type && action.timestamp)
    .sort((a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime())
    .slice(0, 2);
  
  if (sortedActions.length > 0) {
    const actionDescriptions = sortedActions.map(action => {
      const formatActionDescription = (actionData: any) => {
        const payload = actionData.payload || actionData.details || {};
        
        switch (actionData.type) {
          case 'feedback_session_participate':
            const participants = payload.participants;
            if (participants && participants.length > 0) {
              const partnerNames = participants.join(', ');
              return `Recently participated in feedback session with ${partnerNames}`;
            } else {
              const partner = payload.partner || payload.targetMember || payload.otherParticipant || 'team member';
              return `Recently participated in feedback session with ${partner}`;
            }
          
          case 'idea_generation':
          case 'generate_idea':
            const ideaTitle = payload.ideaTitle || payload.object || payload.content?.object || 'new idea';
            return `Recently generated idea: "${ideaTitle}"`;
          
          case 'idea_evaluation':
          case 'evaluate_idea':
            const evalTarget = payload.targetIdea || payload.ideaTitle || payload.content?.object || 'team idea';
            const avgScore = payload.scores?.overall || payload.score || payload.averageScore;
            const scoreText = avgScore ? ` (score: ${avgScore})` : '';
            return `Recently evaluated "${evalTarget}"${scoreText}`;
          
          case 'give_feedback':
            const feedbackTarget = payload.targetMember || payload.recipient || payload.targetAgentId || 'team member';
            return `Recently provided feedback to ${feedbackTarget}`;
          
          case 'make_request':
            const requestTarget = payload.targetMember || payload.recipient || payload.targetAgentId || 'team member';
            const requestType = payload.requestType || payload.actionType || 'collaboration';
            return `Recently made ${requestType} request to ${requestTarget}`;
          
          case 'planning':
            const plannedAction = payload.plannedAction || payload.action;
            return plannedAction ? `Recently planned to ${plannedAction}` : `Recently planned next actions for team collaboration`;
          
          default:
            return `Recently performed ${actionData.type}`;
        }
      };
      
      return `- ${formatActionDescription(action)}`;
    }).join('\n');
    
    formattedMemory += actionDescriptions + '\n';
  }

  return formattedMemory || "- This is your first action in the team";
})()}
`
    : "";

  return { profileContext, memoryContext };
};

// ==========================================================================
// ## IDEATION
// ==========================================================================

// Pre-ideation planning prompt
export const preIdeationPrompt = (
  requestMessage: string,
  ideaList: {
    ideaNumber: number;
    authorName: string;
    object: string;
    function: string;
  }[],
  memory?: AgentMemory,
  agentProfile?: any
) => {
  const simplifiedIdeaList =
    ideaList.length > 0 ? JSON.stringify(ideaList, null, 2) : "No ideas yet.";

  const { profileContext, memoryContext } = createAgentContextSections(
    agentProfile,
    memory,
    "Analyze requests strategically and decide the best approach for idea generation.",
    "idea_generation",
    undefined, // personaSummary
    undefined // targetParticipant - no relationship filtering for ideation
  );

  return `${profileContext}${memoryContext}You are in a team ideation session. Your task is to analyze a request for an idea and decide the best way to generate it.
Inputs:
1. Request Message: "${requestMessage}"
2. Existing Ideas: ${simplifiedIdeaList}

Based on the inputs, you must perform the following tasks:
1.  Decide whether to create a completely "New" idea or "Update" an existing one. A "New" idea is suitable for a broad or novel request. An "Update" is better if the request aims to refine, combine, or build upon an existing concept. If there are no existing ideas, you must choose "New".
2.  If you decide to "Update", you MUST select one idea from the "Existing Ideas" list by its "ideaNumber". The reference idea should be the one most relevant to the request.
3.  Extract a concise "Ideation Strategy" from the request message. This strategy will guide the next stage of idea generation. For example, "Make it more eco-friendly" or "Combine it with AI features".

Respond only in the following JSON format:

{
  "decision": "New" | "Update",
  "referenceIdea": { "ideaNumber": 1, "object": "...", "function": "..." } | null,
  "ideationStrategy": "Your extracted ideation strategy."
}

Example:
Request Message: "I like idea #1, the 'ÍµêÏú°Ï†Å ÌäúÌÑ∞ÎßÅ Ïä§ÌîºÏª§', but can we make it more focused on elderly care?"
Existing Ideas: [
  { 
    "ideaNumber": 1, 
    "authorName": "Agent Jane", 
    "object": "ÍµêÏú°Ï†Å ÌäúÌÑ∞ÎßÅ Ïä§ÌîºÏª§", 
    "function": "..."
  }
]

Your output:
{
  "decision": "Update",
  "referenceIdea": { "ideaNumber": 1, "object": "ÍµêÏú°Ï†Å ÌäúÌÑ∞ÎßÅ Ïä§ÌîºÏª§", "function": "..." },
  "ideationStrategy": "Focus on elderly care features instead of general education."
}

Now, process the given inputs and provide your JSON output.
`;
};

// Main ideation prompt
export const ideationPrompt = (
  context?: string,
  agentProfile?: any,
  memory?: any,
  personaSummary?: string
) => {
  // Ï£ºÏ†úÎ•º ÏïàÏ†ÑÌïòÍ≤å Ï≤òÎ¶¨ÌïòÎêò ÌïúÍ∏ÄÏùÄ Î≥¥Ï°¥
  const safeContext = context || "Carbon Emission Reduction";

  const { profileContext, memoryContext } = createAgentContextSections(
    agentProfile,
    memory,
    "Generate ideas that reflect your unique professional background, skills, and personality.",
    "idea_generation",
    personaSummary,
    undefined // targetParticipant - no relationship filtering for ideation
  );

  return `${profileContext}${memoryContext}## Design Goals
- Conduct conceptual design
- Propose a design solution to directly address the specified design task
- Prioritize novelty, completeness and quality while maintaining feasibility

## Design Task
${safeContext}

## Design Approach
Choose one of these thinking workflows:

**New Creation Workflow:**
1. Propose an object addressing the design task (Design Task ‚Üí Object)
2. Derive critical functions for the object (Object ‚Üí Functions)
3. Translate functions into observable behaviors (Functions ‚Üí Behaviors)
4. Design structures enabling the behaviors (Behaviors ‚Üí Structures)
5. Combine the object, functions, behaviors, and structures into a final design solution

**Analogical Reasoning Workflow:**
1. Given a design task, derive a new combination of object and functions through analogical reasoning, based on a predefined combination of object and functions and an analogical distance between these two combinations
2. Translate these new functions into new observable behaviors (New Functions ‚Üí New Behaviors)
3. Design new structures enabling these new behaviors (New Behaviors ‚Üí New Structures)
4. Combine the new object, new functions, new behaviors, and new structures into a final new design solution

## Innovation Requirements
- Each solution must include more than 2 disruptive innovations compared to existing solutions
- Challenge conventional approaches and leverage your professional expertise

**Write all content in Korean.**
Respond only in the following JSON format:

Examples (can be more specific than the example):
Task: Design a smart speaker in the future.
Idea: 
{
  "object": "ÍµêÏú°Ï†Å ÌäúÌÑ∞ÎßÅ Ïä§ÌîºÏª§",
  "function": "Î™®Îì† Ïó∞Î†πÏùò ÌïôÏÉùÏóêÍ≤å Ïù∏ÌÑ∞ÎûôÌã∞Î∏åÌïú ÍµêÏú°ÏùÑ Ï†úÍ≥µÌïòÎäî Ïù∏Í≥µÏßÄÎä• Ïñ¥ÏãúÏä§ÌÑ¥Ìä∏",
  "behavior": [
    {"key": "Ïù∏ÌÑ∞ÎûôÌã∞Î∏å ÏàòÏóÖ", "value": "Îã§ÏñëÌïú Ï£ºÏ†úÏôÄ ÌïôÏÉùÏùò ÏàòÏ§ÄÏóê ÎßûÎäî ÏùåÏÑ± Í∏∞Î∞ò ÍµêÏú° ÏΩòÌÖêÏ∏† Ï†úÍ≥µ"},
    {"key": "Í≥ºÏ†ú ÏßÄÏõê", "value": "ÌïôÏÉùÎì§ÏóêÍ≤å Ï†ÅÏ†àÌïú ÏÑ§Î™ÖÍ≥º ÎãµÎ≥ÄÏùÑ Ï†úÍ≥µÌïòÏó¨ Í≥ºÏ†ú ÏàòÌñâÏùÑ ÏßÄÏõê"}
  ],
  "structure": [
    {"key": "Ï†ÅÏùëÌòï ÍµêÏú° AI", "value": "ÏÇ¨Ïö©ÏûêÏùò ÏàòÏ§ÄÍ≥º ÏÑ†Ìò∏Î•º ÌååÏïÖÌï¥ ÎßûÏ∂§Ìòï ÍµêÏú° ÏΩòÌÖêÏ∏†Î•º ÏÉùÏÑ±"},
    {"key": "Í≥†ÏÑ±Îä• Ïò§ÎîîÏò§", "value": "Ìö®Í≥ºÏ†ÅÏù∏ ÍµêÏú°ÏùÑ ÏúÑÌïú Í≥†ÌíàÏßà Ïò§ÎîîÏò§ Ï∂úÎ†•ÏùÑ ÏßÄÏõê"},
    {"key": "Îã§Ï§ë Ïù∏Ïãù ÎßàÏù¥ÌÅ¨", "value": "Ïó¨Îü¨ ÌïôÏÉùÏùò Î∞úÌôîÎ•º Ïù∏ÏãùÌïòÍ∏∞ ÏúÑÌïú Îã§Ï§ë ÎßàÏù¥ÌÅ¨ Î∞∞Ïó¥"},
    {"key": "Î∂ÄÎ™®Ïö© Ïª®Ìä∏Î°§Îü¨", "value": "Î∂ÄÎ™®Í∞Ä ÍµêÏú° ÏΩòÌÖêÏ∏†Î•º Î™®ÎãàÌÑ∞ÎßÅÌïòÍ≥† Í¥ÄÎ¶¨Ìï† Ïàò ÏûàÎèÑÎ°ù ÏßÄÏõê"}
  ]
}

Task: Design a toy for cats.
Idea:
{
  "object": "Î¨¥ÏÜåÏùå Î¥âÏ†ú Í≥µ",
  "function": "Í≥†ÏñëÏù¥Í∞Ä Ï£ºÏù∏ÏùÑ Î∞©Ìï¥ÌïòÏßÄ ÏïäÍ≥† ÏûêÏú†Î°≠Í≤å ÎÜÄ Ïàò ÏûàÎèÑÎ°ù Î¨¥ÏÜåÏùå ÎÜÄÏù¥ Í≤ΩÌóòÏùÑ Ï†úÍ≥µÌï©ÎãàÎã§.",
  "behavior": [
    {"key": "Ïª¥Ìå©Ìä∏ ÎîîÏûêÏù∏", "value": "Ï¢ÅÏùÄ Í≥µÍ∞ÑÏóêÏÑúÎèÑ Í≥†ÏñëÏù¥Í∞Ä ÏâΩÍ≤å Î¨ºÍ≥†, Î∞ÄÍ≥†, Îì§Í≥† Îã§Îãê Ïàò ÏûàÏäµÎãàÎã§."},
    {"key": "Î∂ÄÎìúÎüΩÍ≥† ÎÜíÏùÄ ÌÉÑÏÑ±", "value": "Î≥ÄÌòï ÌõÑÏóêÎèÑ Îπ†Î•¥Í≤å ÏõêÌòïÏùÑ ÌöåÎ≥µÌï¥ Ìé∏ÏïàÌïú Ï¥âÍ∞êÏùÑ Ï†úÍ≥µÌï©ÎãàÎã§."},
    {"key": "ÎÇ¥Íµ¨ÏÑ±Í≥º Ï†ÄÌï≠ÏÑ±", "value": "Ïû¶ÏùÄ Î¨ºÍ∏∞¬∑Í∏ÅÍ∏∞¬∑ÎãπÍ∏∞Í∏∞ÏóêÎèÑ ÎßàÎ™®ÎÇò Î≥ÄÌòïÏù¥ Í±∞Ïùò ÏóÜÏñ¥ Ïû•Í∏∞Í∞Ñ ÏÇ¨Ïö©Ïù¥ Í∞ÄÎä•Ìï©ÎãàÎã§."},
    {"key": "Î¨¥ÏÜåÏùå Î∞òÎèô", "value": "ÏÜåÎ¶¨Î•º ÎÇ¥ÏßÄ ÏïäÍ≥† Í≥ÑÏÜç ÌäÄÎ©∞ ÏõÄÏßÅÏó¨, Ï°∞Ïö©Ìïú ÌôòÍ≤ΩÏùÑ Ïú†ÏßÄÌï©ÎãàÎã§."},
    {"key": "ÏïàÏ†ÑÏÑ±Í≥º Î¨¥ÎèÖÏÑ±", "value": "Ïú†Ìï¥ ÌôîÌïôÎ¨ºÏßàÏù¥ ÏóÜÎäî ÏÜåÏû¨Î°ú ÎßåÎì§Ïñ¥, Í≥†ÏñëÏù¥Í∞Ä Ìï•Í±∞ÎÇò Î¨ºÏñ¥ÎèÑ ÏïàÏ†ÑÌï©ÎãàÎã§."}
  ],
  "structure": [
    {"key": "ÌÅ¨Í∏∞ÏôÄ ÌòïÌÉú", "value": "ÏßÄÎ¶Ñ 5 cm, ÏµúÎåÄ 4 cmÍπåÏßÄ ÏïïÏ∂ïÎèº Ïã§ÏàòÎ°ú ÏÇºÌÇ§Îäî ÏùºÏùÑ Î∞©ÏßÄÌï©ÎãàÎã§."},
    {"key": "ÌîåÎü¨Ïãú Ïô∏Ìîº", "value": "Î∂ÄÎìúÎüΩÍ≥† Ìé∏ÏïàÌïòÎ©∞ ÎßàÎ™®Ïóê Í∞ïÌïòÍ≥† ÏÑ∏Ï≤ôÏù¥ Ïâ¨Ïõå ÏúÑÏÉùÏ†ÅÏûÖÎãàÎã§."},
    {"key": "Í≥†ÌÉÑÏÑ± ÏÜú Ï∂©Ï†ÑÏû¨", "value": "Ï†ÅÎãπÌïú Î∂ÄÎìúÎü¨ÏõÄÍ≥º Íµ¨Ï°∞Ï†Å ÏïàÏ†ïÏÑ±, Ïö∞ÏàòÌïú ÌÉÑÏÑ±ÏùÑ Ï†úÍ≥µÌï©ÎãàÎã§."},
    {"key": "Í≥†Í∞ïÎèÑ Î¥âÏ†ú Î∞è Íµ¨Ï°∞", "value": "Í≤©Ìïú ÎÜÄÏù¥ÏóêÎèÑ Ïã§Î∞•Ïù¥ ÌíÄÎ¶¨Í±∞ÎÇò ÎÅäÏñ¥ÏßÄÏßÄ ÏïäÍ≥† Ïû•Í∏∞Í∞Ñ Í≤¨Îîú Ïàò ÏûàÏäµÎãàÎã§."}
  ]
}

## Concept Framework
Generate ideas using the following structure:

{
  "object": "",
  "function": "",
  "behavior": [],
  "structure": []
}

### Component Definitions:
- **Object**: The target entity to be designed, which can be either existing or imagined. It is usually a noun or short phrases. Example: Residential house.
- **Function**: Ultimate purposes the object must achieve, describing what the object should do. Example: Provide safety, provide comfort, provide load-bearing capacity.
- **Behavior**: Dynamic characteristics of the object, including how it responds to various inputs and environmental conditions. It describes how the object achieves its functions, and is derived from or anticipated based on its structures. Format as an array of key-value pairs: [{"key": "ÌñâÎèô ÏöîÏÜåÎ™Ö", "value": "ÏÑ§Î™Ö"}]
- **Structure**: Physical composition or configuration of the object, including its components and the relationships between them. Format as an array of key-value pairs: [{"key": "Íµ¨Ï°∞ ÏöîÏÜåÎ™Ö", "value": "ÏÑ§Î™Ö"}]

Task: ${safeContext}`;
};

const baseIdeationPromptText = `Generate one idea based on the provided instructions and return only one JSON object in the following structure:
{
  "object": "",
  "function": "",
  "behavior": {},
  "structure": {}
}
- object: The design target that appears beside each idea node.
- function: The purpose or teleology of the object.
- behavior: What the object does, expressed as a JSON object.
- structure: The object's components and their relationships, as a JSON object.
Write all content in Korean. Respond only in the following JSON format:`;

// New ideation prompt
export const newIdeationPrompt = (
  ideationStrategy: string,
  topic: string,
  memory?: AgentMemory,
  agentProfile?: any
) => {
  const { profileContext, memoryContext } = createAgentContextSections(
    agentProfile,
    memory,
    "Generate innovative ideas based on the provided strategy, leveraging your unique perspective and expertise.",
    "idea_generation",
    undefined, // personaSummary
    undefined // targetParticipant - no relationship filtering for ideation
  );

  return `${profileContext}${memoryContext}${baseIdeationPromptText}

Task: ${topic}
Ideation Strategy: ${ideationStrategy}

Apply the strategy to generate a completely new idea for the given task.
Idea: `;
};

// Update ideation prompt
export const updateIdeationPrompt = (
  referenceIdea: any,
  ideationStrategy: string,
  topic: string,
  memory?: AgentMemory,
  agentProfile?: any
) => {
  const ideaString = JSON.stringify(referenceIdea, null, 2);

  const { profileContext, memoryContext } = createAgentContextSections(
    agentProfile,
    memory,
    "Build upon existing ideas by applying strategic improvements and innovative enhancements based on your expertise.",
    "idea_generation",
    undefined, // personaSummary
    undefined // targetParticipant - no relationship filtering for ideation
  );

  return `${profileContext}${memoryContext}${baseIdeationPromptText}

Task: ${topic}
Reference Idea to Update:
${ideaString}

Ideation Strategy: ${ideationStrategy}

Apply the strategy to the reference idea to create an improved or modified version. The new idea should be a clear evolution of the reference.
Idea: `;
};

// ==========================================================================
// ## EVALUATION
// ==========================================================================

// Pre-evaluation planning prompt
export const preEvaluationPrompt = (
  requestMessage: string,
  ideaList: {
    ideaNumber: number;
    authorName: string;
    object: string;
    function: string;
  }[],
  memory?: AgentMemory,
  agentProfile?: any
) => {
  const ideaListString =
    ideaList.length > 0
      ? JSON.stringify(ideaList, null, 2)
      : "No ideas available for evaluation.";

  const { profileContext, memoryContext } = createAgentContextSections(
    agentProfile,
    memory,
    "Analyze evaluation requests strategically and select ideas objectively based on your expertise.",
    "idea_evaluation",
    undefined, // personaSummary
    undefined // targetParticipant - no relationship filtering for evaluation planning
  );

  return `${profileContext}${memoryContext}You are in a team ideation session. Your task is to analyze a request for idea evaluation and decide which idea to evaluate and how.

IMPORTANT: You should only evaluate ideas created by other team members, not your own ideas. The available ideas list already excludes your own ideas.

Inputs:
1. Request Message: "${requestMessage}"
2. Available Ideas: ${ideaListString}

Based on the inputs, you must perform the following tasks:
1. Select ONE idea from the "Available Ideas" list that is most relevant to the request message. If the request mentions a specific idea number, prioritize that. Otherwise, choose the most suitable one based on the request context.
2. Extract an "Evaluation Strategy" from the request message that will guide how you evaluate the selected idea. This should focus on what aspects to emphasize (e.g., "Focus on environmental impact", "Evaluate technical feasibility", "Consider user experience").

Respond only in the following JSON format:

{
  "selectedIdea": {
    "ideaNumber": 1,
    "object": "...",
    "function": "..."
  },
  "evaluationStrategy": "Your extracted evaluation strategy focusing on specific aspects to evaluate."
}

Example:
Request Message: "Can you evaluate idea #2 focusing on its environmental benefits?"
Available Ideas: [
  { "ideaNumber": 1, "authorName": "User", "object": "Ïä§ÎßàÌä∏ Ï°∞Î™Ö", "function": "..." },
  { "ideaNumber": 2, "authorName": "Agent A", "object": "ÌÉúÏñëÍ¥ë Ï∂©Ï†ÑÍ∏∞", "function": "..." }
]

Your output:
{
  "selectedIdea": { "ideaNumber": 2, "object": "ÌÉúÏñëÍ¥ë Ï∂©Ï†ÑÍ∏∞", "function": "..." },
  "evaluationStrategy": "Focus on environmental benefits and sustainability impact."
}

Now, process the given inputs and provide your JSON output.
`;
};

// Execute evaluation prompt
export const evaluationPrompt = (
  selectedIdea: any,
  evaluationStrategy: string,
  memory?: AgentMemory,
  agentProfile?: any
) => {
  const ideaString = JSON.stringify(selectedIdea, null, 2);

  const { profileContext, memoryContext } = createAgentContextSections(
    agentProfile,
    memory,
    "Evaluate ideas thoroughly and objectively using your professional expertise and analytical skills.",
    "idea_evaluation",
    undefined, // personaSummary
    undefined // targetParticipant - no relationship filtering for evaluation
  );

  return `${profileContext}${memoryContext}You are an AI agent evaluating an idea in a team ideation session. Your task is to provide a comprehensive evaluation based on the given strategy.

IMPORTANT: You should only evaluate ideas created by other team members, not your own ideas.

Idea to Evaluate:
${ideaString}

Evaluation Strategy: ${evaluationStrategy}

You must evaluate the idea on three dimensions using a 7-point scale (1-7):
- Novelty: How novel, creative, and original is this idea? (1=not novel at all, 7=extremely novel)
- Completeness: How complete and well-developed is this idea? (1=not complete at all, 7=extremely complete)  
- Quality: How high-quality and well-thought-out is this idea? (1=very low quality, 7=extremely high quality)

Use the following 7-point scale for all dimensions:
- 1: Strongly Disagree/Very Poor
- 2: Disagree/Poor  
- 3: Somewhat Disagree/Below Average
- 4: Neutral/Average
- 5: Somewhat Agree/Above Average
- 6: Agree/Good
- 7: Strongly Agree/Excellent

Apply the evaluation strategy to focus your assessment on the specified aspects while still providing scores for all three dimensions.

Be specific and critical in your evaluation. Don't hesitate to point out weaknesses or limitations. Provide concrete reasons for your scores and specific suggestions for improvement.

Provide your evaluation in the following JSON format. Write your comment in Korean.

{
  "scores": {
    "novelty": <1-7>,
    "completeness": <1-7>,
    "quality": <1-7>
  },
  "comment": "Your detailed evaluation comment in Korean, focusing on the evaluation strategy while covering all three dimensions."
}

Respond only in the following JSON format:
`;
};

// ==========================================================================
// ## FEEDBACK
// ==========================================================================

// Pre-feedback planning prompt
export const preFeedbackPrompt = (
  targetMemberName: string,
  targetMemberIdeas: any[],
  memory?: any,
  agentProfile?: any,
  requestContext?: {
    isRequestBased?: boolean;
    requesterName?: string;
    requestMessage?: string;
    teamContext?: any;
  }
) => {
  // ÎîîÎ≤ÑÍπÖ: targetMemberIdeas ÏÉÅÌÉú ÌôïÏù∏
  console.log(`üîç preFeedbackPromptÏóêÏÑú ${targetMemberName}Ïùò ÏïÑÏù¥ÎîîÏñ¥ ÌôïÏù∏:`);
  console.log(`- targetMemberIdeas:`, targetMemberIdeas);
  console.log(`- ArrayÏù∏Í∞Ä?:`, Array.isArray(targetMemberIdeas));
  console.log(`- Í∏∏Ïù¥:`, targetMemberIdeas?.length);
  console.log(`- Í∏∏Ïù¥ > 0 Ï≤¥ÌÅ¨:`, targetMemberIdeas.length > 0);
  
  const ideasText = targetMemberIdeas.length > 0 
    ? targetMemberIdeas.map((idea, index) => 
        `${index + 1}. "${idea.content?.object || 'Ï†úÎ™© ÏóÜÏùå'}" - ${idea.content?.function || 'ÏÑ§Î™Ö ÏóÜÏùå'}`
      ).join('\n')
    : 'ÏïÑÏßÅ ÏïÑÏù¥ÎîîÏñ¥Í∞Ä ÏóÜÏäµÎãàÎã§.';
    
  console.log(`üìù preFeedbackPromptÏóêÏÑú ÏÉùÏÑ±Îêú ideasText:`, ideasText);

  const { profileContext, memoryContext } = createAgentContextSections(
    agentProfile,
    memory,
    "Analyze feedback opportunities strategically to provide maximum value to team members.",
    "feedback",
    undefined, // personaSummary
    targetMemberName // targetParticipant - only show relationship with feedback target
  );

  // ÏöîÏ≤≠ Í∏∞Î∞ò ÌîºÎìúÎ∞±Ïù∏ÏßÄ ÌôïÏù∏
  const isRequestBased = requestContext?.isRequestBased || false;
  const requestInfo = isRequestBased ? `

**REQUEST CONTEXT:**
- This feedback is requested by: ${requestContext?.requesterName}
- Request message: "${requestContext?.requestMessage}"
- You should select ${targetMemberName} as the feedback target and plan accordingly
` : '';

  return `${profileContext}${memoryContext}You are planning to provide feedback${isRequestBased ? ' in response to a team member request' : ''} to ${targetMemberName} in a team ideation session.
${requestInfo}
**Target Member:** ${targetMemberName}
**Their Ideas:**
${ideasText}

**Feedback Taxonomy Guidelines:**
Choose appropriate feedback approaches among the 15 taxonomy based on the situation:

- **1. Verification**: Ensure you understand their idea correctly
- **2. Completion**: Ask for clarification on unclear aspects
- **3. Understanding Feedback Receiver**: Learn about their background and perspective
- **4. Logical/Causal Reasoning**: Prompt them to think about feasibility, effectiveness, realization
- **5. Instrumental/Procedural Reasoning**: Ask about procedures and decision reasoning
- **6. Brainstorming/Ideation**: Provide or elicit new ideas without specific goals
- **7. Negotiation**: Suggest alternative ideas or approaches
- **8. Scenario Creation**: Present specific scenarios that could occur
- **9. Sharing Examples/Personal Experience**: Provide relevant examples or experiences
- **10. Providing Design Knowledge**: Share design principles or domain knowledge
- **11. Positive Assessment**: Explicitly acknowledge good aspects of the design
- **12. Negative Assessment**: Explicitly point out areas for improvement
- **13. Direct Recommendation**: Give specific advice on what or how to do
- **14. Hinting**: Indirectly suggest ways to proceed
- **15. Project Management**: Address scheduling, deliverables, stakeholder management

**Planning Task:**
Based on your knowledge of ${targetMemberName} and their ideas, develop a strategic approach for providing meaningful feedback.

**CRITICAL: Idea Status Analysis**
- ${targetMemberName} currently has ${targetMemberIdeas.length} ideas
- Set hasIdeas to true if they have 1 or more ideas, false if they have 0 ideas
- This determines the entire feedback approach

Consider:
1. **Idea Status**: Based on the ${targetMemberIdeas.length} ideas shown above, set hasIdeas appropriately
2. **Feedback Focus**: What specific aspects should you focus on (ideas, collaboration style, team contribution, other assigned roles)?
3. **Feedback Approach**: What tone and approach would be most effective given your relationship?
4. **Value Proposition**: How can you provide maximum value to help them improve?
5. **Taxonomy Selection**: Which 1-2 feedback taxonomy approaches best fit this situation?${isRequestBased ? `
6. **Target Selection**: Since this is a requested feedback, confirm ${targetMemberName} as your feedback target
7. **Feedback Type**: Determine the most appropriate feedback type (general_collaboration, specific_idea, skill_development, team_dynamics)` : ''}

${isRequestBased ? `Respond only in the following JSON format for REQUEST-BASED feedback:
{
  "targetMember": {
    "id": "${targetMemberName}",
    "name": "${targetMemberName}",
    "isUser": true
  },
  "feedbackType": "general_collaboration" | "specific_idea" | "skill_development" | "team_dynamics",
  "hasIdeas": true | false,
  "feedbackFocus": "What specific aspects you will focus on in your feedback",
  "feedbackApproach": "Your planned tone and approach for the feedback", 
  "keyPoints": "Main points you want to communicate",
  "selectedTaxonomy": ["Selected taxonomy approach(es) from the 15 options above"],
  "reasoning": "Why you chose this approach and feedback type"
}` : `Respond only in the following JSON format:
{
  "hasIdeas": true | false,
  "feedbackFocus": "What specific aspects you will focus on in your feedback",
  "feedbackApproach": "Your planned tone and approach for the feedback",
  "keyPoints": "Main points you want to communicate",
  "selectedTaxonomy": ["Selected taxonomy approach(es) from the 15 options above"]
}`}`;
};

// Main feedback prompt
export const feedbackPrompt = (
  targetMember: string,
  targetMemberIdeas: any[],
  teamContext: any,
  agentProfile?: any,
  memory?: any,
  targetMemberRoles?: string[],
  allIdeas?: any[],
  feedbackStrategy?: any // preFeedbackÏóêÏÑú Ï†ÑÎã¨Îêú Ï†ÑÎûµ
) => {
  const { profileContext, memoryContext } = createAgentContextSections(
    agentProfile,
    memory,
    "Provide natural, conversational feedback on specific ideas while reflecting your personality and relationships.",
    "feedback",
    undefined, // personaSummary
    targetMember // targetParticipant - only show relationship with feedback target
  );

  const agentContext = `You are participating in the ideation session.

${profileContext}${memoryContext}`;

  // ÌîºÎìúÎ∞± Ï†ÑÎûµÏóê Îî∞Îùº Îã§Î•∏ Ï†ëÍ∑º Î∞©Ïãù ÏÇ¨Ïö©, ÌïòÏßÄÎßå ÎÖºÎ¶¨Ï†Å Ïò§Î•ò Î∞©ÏßÄ
  const actualHasIdeas = targetMemberIdeas.length > 0;
  const aiJudgedHasIdeas = feedbackStrategy?.hasIdeas;
  
  // ÎîîÎ≤ÑÍπÖ: feedbackPromptÏóê Ï†ÑÎã¨Îêú ÌåÄ Ï†ïÎ≥¥ ÌôïÏù∏
  console.log(`üîç feedbackPromptÏóêÏÑú ${targetMember}Ïùò ÌåÄ Ï†ïÎ≥¥ ÌôïÏù∏:`);
  console.log(`- teamContext:`, teamContext);
  console.log(`- teamContext.teamMembers:`, teamContext?.teamMembers);
  console.log(`- teamContext.relationships:`, teamContext?.relationships);
  console.log(`- allIdeas:`, allIdeas);
  console.log(`- targetMemberRoles:`, targetMemberRoles);

  // ÏïàÏ†Ñ Ïû•Ïπò: AIÍ∞Ä ÏûòÎ™ª ÌåêÎã®Ìïú Í≤ΩÏö∞ Ïã§Ï†ú ÏïÑÏù¥ÎîîÏñ¥ Í∞úÏàòÎ•º Ïö∞ÏÑ†
  let hasIdeas = actualHasIdeas;
  if (aiJudgedHasIdeas !== undefined && aiJudgedHasIdeas !== actualHasIdeas) {
    console.log(`üö®üö®üö® CRITICAL: AI ÌåêÎã® Ïò§Î•ò Í∞êÏßÄ!`);
    console.log(`üö® AIÍ∞Ä ÌåêÎã®Ìïú hasIdeas: ${aiJudgedHasIdeas}`);
    console.log(`üö® Ïã§Ï†ú ÏïÑÏù¥ÎîîÏñ¥ Í∞úÏàò: ${actualHasIdeas}`);
    console.log(`üö® Ïã§Ï†úÍ∞íÏúºÎ°ú Í∞ïÏ†ú Î≥ÄÍ≤ΩÎê®: ${actualHasIdeas}`);
    hasIdeas = actualHasIdeas;
  } else {
    hasIdeas = aiJudgedHasIdeas ?? actualHasIdeas;
  }
  
  
  let contextSection = "";
  let feedbackGuidelines = "";
  
  if (hasIdeas) {
    // ÏïÑÏù¥ÎîîÏñ¥Í∞Ä ÏûàÎäî Í≤ΩÏö∞: ÏïÑÏù¥ÎîîÏñ¥ Ï§ëÏã¨ ÌîºÎìúÎ∞±
    console.log(`üîç feedbackPromptÏóêÏÑú ${targetMember}Ïùò ÏïÑÏù¥ÎîîÏñ¥ Ï≤òÎ¶¨ (hasIdeas=true):`);
    console.log(`- targetMemberIdeas:`, targetMemberIdeas);
    console.log(`- ArrayÏù∏Í∞Ä?:`, Array.isArray(targetMemberIdeas));
    console.log(`- Í∏∏Ïù¥:`, targetMemberIdeas?.length);
    
    const ideasText = targetMemberIdeas.map((idea, index) => 
      `${index + 1}. "${idea.content?.object || 'Ï†úÎ™© ÏóÜÏùå'}" - ${idea.content?.function || 'ÏÑ§Î™Ö ÏóÜÏùå'}`
    ).join('\n');
    
    console.log(`üìù feedbackPromptÏóêÏÑú ÏÉùÏÑ±Îêú ideasText (hasIdeas=true):`, ideasText);
    
    contextSection = `**Team Member:** ${targetMember}
**Their Assigned Roles:** ${targetMemberRoles?.join(', ') || 'No specific roles'}
**Their Ideas:**
${ideasText}`;

    feedbackGuidelines = `**Feedback Guidelines:**
- Focus on their specific ideas and provide constructive feedback
- Reference specific details of their ideas
- Suggest improvements, extensions, or alternative approaches
- Use natural Korean language appropriate for your relationship level
- Balance positive recognition with constructive suggestions`;
    
  } else {
    // ÏïÑÏù¥ÎîîÏñ¥Í∞Ä ÏóÜÎäî Í≤ΩÏö∞: Ï†ÑÏ≤¥ ÌåÄ Ï†ïÎ≥¥ÏôÄ ÏïÑÏù¥ÎîîÏñ¥Î•º Î≥¥Ïó¨Ï£ºÍ≥† Ïó≠Ìï† Í∏∞Î∞ò ÌîºÎìúÎ∞±
    const allIdeasText = allIdeas && allIdeas.length > 0 
      ? allIdeas.map((idea, index) => {
          // ÏûëÏÑ±Ïûê IDÎ•º Ïù¥Î¶ÑÏúºÎ°ú Îß§Ìïë
          let authorName = idea.author;
          if (idea.author === 'ÎÇò') {
            authorName = 'ÎÇò';
          } else if (teamContext?.agentNameMap && teamContext.agentNameMap[idea.author]) {
            authorName = teamContext.agentNameMap[idea.author];
          } else if (teamContext?.teamMembers) {
            const authorMember = teamContext.teamMembers.find((m: any) => 
              m.agentId === idea.author || m.userId === idea.author || m.name === idea.author
            );
            if (authorMember) {
              authorName = authorMember.isUser ? 'ÎÇò' : (authorMember.name || authorMember.agentId || idea.author);
            }
          }
          return `${index + 1}. "${idea.content?.object || 'Ï†úÎ™© ÏóÜÏùå'}" (ÏûëÏÑ±Ïûê: ${authorName}) - ${idea.content?.function || 'ÏÑ§Î™Ö ÏóÜÏùå'}`;
        }).join('\n')
      : 'ÌåÄÏóê ÏïÑÏßÅ ÏïÑÏù¥ÎîîÏñ¥Í∞Ä ÏóÜÏäµÎãàÎã§.';

    // ÌåÄ Î©§Î≤Ñ Ï†ïÎ≥¥ ÏÉùÏÑ± (Ïù¥Î¶Ñ, Ïó≠Ìï†, Í¥ÄÍ≥Ñ)
    const teamMembersInfo = teamContext?.teamMembers?.map((member: any) => {
      const roles = member.roles ? member.roles.join(', ') : 'Ïó≠Ìï† ÏóÜÏùå';
      const isLeader = member.isLeader ? ' (ÌåÄÏû•)' : '';
      let memberName = member.isUser ? 'ÎÇò' : 'Ïïå Ïàò ÏóÜÏùå';
      if (!member.isUser) {
        if (teamContext?.agentNameMap && member.agentId && teamContext.agentNameMap[member.agentId]) {
          memberName = teamContext.agentNameMap[member.agentId];
        } else {
          memberName = member.name || member.agentId || 'Ïïå Ïàò ÏóÜÏùå';
        }
      }
      return `- ${memberName}${isLeader}: ${roles}`;
    }).join('\n') || 'ÌåÄ Î©§Î≤Ñ Ï†ïÎ≥¥ ÏóÜÏùå';

    // Í¥ÄÍ≥Ñ Ï†ïÎ≥¥ ÏÉùÏÑ±
    const relationshipsInfo = teamContext?.relationships && teamContext.relationships.length > 0
      ? teamContext.relationships.map((rel: any) => {
          let fromName = rel.from === 'ÎÇò' ? 'ÎÇò' : rel.from;
          let toName = rel.to === 'ÎÇò' ? 'ÎÇò' : rel.to;
          
          // agentNameMapÏùÑ ÏÇ¨Ïö©Ìï¥ÏÑú agent IDÎ•º Ïù¥Î¶ÑÏúºÎ°ú Î≥ÄÌôò
          if (rel.from !== 'ÎÇò' && teamContext?.agentNameMap && teamContext.agentNameMap[rel.from]) {
            fromName = teamContext.agentNameMap[rel.from];
          } else if (rel.from !== 'ÎÇò' && teamContext?.teamMembers) {
            const fromMember = teamContext.teamMembers.find((m: any) => m.agentId === rel.from);
            if (fromMember) {
              fromName = fromMember.name || rel.from;
            }
          }
          
          if (rel.to !== 'ÎÇò' && teamContext?.agentNameMap && teamContext.agentNameMap[rel.to]) {
            toName = teamContext.agentNameMap[rel.to];
          } else if (rel.to !== 'ÎÇò' && teamContext?.teamMembers) {
            const toMember = teamContext.teamMembers.find((m: any) => m.agentId === rel.to);
            if (toMember) {
              toName = toMember.name || rel.to;
            }
          }
          const relType = rel.type === 'SUPERVISOR' ? 'ÏÉÅÏÇ¨' : rel.type === 'SUBORDINATE' ? 'Î∂ÄÌïò' : rel.type === 'PEER' ? 'ÎèôÎ£å' : rel.type;
          return `- ${fromName} ‚Üí ${toName}: ${relType}`;
        }).join('\n')
      : 'ÏÑ§Ï†ïÎêú Í¥ÄÍ≥Ñ ÏóÜÏùå';
    
    contextSection = `**Team Member:** ${targetMember}
**Their Assigned Roles:** ${targetMemberRoles?.join(', ') || 'No specific roles'}

**Team Context:**
- Topic: ${teamContext?.topic || 'General ideation'}
- Team Size: ${teamContext?.teamMembers?.length || 'Unknown'} members

**Team Members & Roles:**
${teamMembersInfo}

**Team Relationships:**
${relationshipsInfo}

**All Team Ideas:**
${allIdeasText}`;

    feedbackGuidelines = `**Feedback Guidelines:**
- **Focus on Role Excellence**: Discuss how they can maximize their assigned roles (${targetMemberRoles?.join(', ') || 'Ïó≠Ìï† ÏóÜÏùå'}) to boost team ideation performance
- **Actionable Role Improvements**: Suggest specific, practical ways they can enhance their role execution for better team outcomes
- **Team Performance Enhancement**: Connect their role improvements to overall team meeting effectiveness and ideation quality
- Consider team relationships and dynamics when suggesting role improvements
- If they have "ÏïÑÏù¥ÎîîÏñ¥ ÏÉùÏÑ±ÌïòÍ∏∞" role: suggest techniques, approaches, or collaboration methods to generate higher-quality ideas
- If they have "ÏïÑÏù¥ÎîîÏñ¥ ÌèâÍ∞ÄÌïòÍ∏∞" role: recommend evaluation frameworks or criteria to provide more valuable assessments
- If they have "ÌîºÎìúÎ∞±ÌïòÍ∏∞" role: propose feedback strategies that drive better team discussions and idea refinement
- If they have "ÏöîÏ≤≠ÌïòÍ∏∞" role: suggest strategic request approaches that unlock team potential and facilitate better collaboration
- **Constructive & Executable**: Provide concrete, implementable suggestions they can use immediately in the current meeting
- Use natural Korean language appropriate for your relationship level`;
  }

  const mainPrompt = `Provide natural, conversational feedback to your team member based on the strategic approach below.

${contextSection}

**Feedback Strategy from Analysis:**
- Focus: ${feedbackStrategy?.feedbackFocus || 'General team contribution'}
- Approach: ${feedbackStrategy?.feedbackApproach || 'Supportive and constructive'}
- Key Points: ${feedbackStrategy?.keyPoints || 'Help them improve their contributions'}

${feedbackGuidelines}
- Keep the tone collaborative and supportive
- Keep your feedback concise and focused (2-4 sentences maximum)
- Show your personality and professional background

Provide your feedback in the following JSON format:
{
  "feedback": "Your natural, conversational feedback message in Korean"
}`;

  return { agentContext, mainPrompt };
};

// Feedback response prompt
export const responsePrompt = (
  messageHistory: Array<{
    sender: string;
    content: string;
    timestamp: string;
  }>,
  targetMember: string,
  agentProfile?: any,
  memory?: any,
  targetMemberRoles?: string[],
  targetMemberIdeas?: any[],
  teamContext?: any,
  allIdeas?: any[]
) => {
  const historyText = messageHistory
    .map((msg) => `${msg.sender}: ${msg.content}`)
    .join("\n");

  const { profileContext, memoryContext } = createAgentContextSections(
    agentProfile,
    memory,
    "Respond naturally and authentically to feedback conversations, maintaining your personality and relationship dynamics.",
    "response",
    undefined, // personaSummary
    targetMember // targetParticipant - only show relationship with conversation partner
  );

  
  const hasIdeas = targetMemberIdeas && targetMemberIdeas.length > 0;
  let contextSection = "";
  
  if (hasIdeas) {
    // ÏïÑÏù¥ÎîîÏñ¥Í∞Ä ÏûàÎäî Í≤ΩÏö∞: Í∞úÏù∏ ÏïÑÏù¥ÎîîÏñ¥Îßå ÌëúÏãú
    const ideasText = targetMemberIdeas.map((idea, index) => 
      `${index + 1}. "${idea.content?.object || 'Ï†úÎ™© ÏóÜÏùå'}" - ${idea.content?.function || 'ÏÑ§Î™Ö ÏóÜÏùå'}`
    ).join('\n');
    
    contextSection = `**Team Member:** ${targetMember}
**Their Assigned Roles:** ${targetMemberRoles?.join(', ') || 'No specific roles'}
**Their Ideas:**
${ideasText}`;
  } else {
    // ÏïÑÏù¥ÎîîÏñ¥Í∞Ä ÏóÜÎäî Í≤ΩÏö∞: ÌåÄ Ï†ÑÏ≤¥ Ï†ïÎ≥¥ ÌëúÏãú
    const allIdeasText = allIdeas && allIdeas.length > 0 
      ? allIdeas.map((idea, index) => {
          // ÏûëÏÑ±Ïûê IDÎ•º Ïù¥Î¶ÑÏúºÎ°ú Îß§Ìïë
          let authorName = idea.author;
          if (idea.author === 'ÎÇò') {
            authorName = 'ÎÇò';
          } else if (teamContext?.agentNameMap && teamContext.agentNameMap[idea.author]) {
            authorName = teamContext.agentNameMap[idea.author];
          } else if (teamContext?.teamMembers) {
            const authorMember = teamContext.teamMembers.find((m: any) => 
              m.agentId === idea.author || m.userId === idea.author || m.name === idea.author
            );
            if (authorMember) {
              authorName = authorMember.isUser ? 'ÎÇò' : (authorMember.name || authorMember.agentId || idea.author);
            }
          }
          return `${index + 1}. "${idea.content?.object || 'Ï†úÎ™© ÏóÜÏùå'}" (ÏûëÏÑ±Ïûê: ${authorName}) - ${idea.content?.function || 'ÏÑ§Î™Ö ÏóÜÏùå'}`;
        }).join('\n')
      : 'ÌåÄÏóê ÏïÑÏßÅ ÏïÑÏù¥ÎîîÏñ¥Í∞Ä ÏóÜÏäµÎãàÎã§.';

    // ÌåÄ Î©§Î≤Ñ Ï†ïÎ≥¥ ÏÉùÏÑ±
    const teamMembersInfo = teamContext?.teamMembers?.map((member: any) => {
      const roles = member.roles ? member.roles.join(', ') : 'Ïó≠Ìï† ÏóÜÏùå';
      const isLeader = member.isLeader ? ' (ÌåÄÏû•)' : '';
      let memberName = member.isUser ? 'ÎÇò' : 'Ïïå Ïàò ÏóÜÏùå';
      if (!member.isUser) {
        if (teamContext?.agentNameMap && member.agentId && teamContext.agentNameMap[member.agentId]) {
          memberName = teamContext.agentNameMap[member.agentId];
        } else {
          memberName = member.name || member.agentId || 'Ïïå Ïàò ÏóÜÏùå';
        }
      }
      return `- ${memberName}${isLeader}: ${roles}`;
    }).join('\n') || 'ÌåÄ Î©§Î≤Ñ Ï†ïÎ≥¥ ÏóÜÏùå';

    // Í¥ÄÍ≥Ñ Ï†ïÎ≥¥ ÏÉùÏÑ±
    const relationshipsInfo = teamContext?.relationships && teamContext.relationships.length > 0
      ? teamContext.relationships.map((rel: any) => {
          let fromName = rel.from === 'ÎÇò' ? 'ÎÇò' : rel.from;
          let toName = rel.to === 'ÎÇò' ? 'ÎÇò' : rel.to;
          
          // agentNameMapÏùÑ ÏÇ¨Ïö©Ìï¥ÏÑú agent IDÎ•º Ïù¥Î¶ÑÏúºÎ°ú Î≥ÄÌôò
          if (rel.from !== 'ÎÇò' && teamContext?.agentNameMap && teamContext.agentNameMap[rel.from]) {
            fromName = teamContext.agentNameMap[rel.from];
          } else if (rel.from !== 'ÎÇò' && teamContext?.teamMembers) {
            const fromMember = teamContext.teamMembers.find((m: any) => m.agentId === rel.from);
            if (fromMember) {
              fromName = fromMember.name || rel.from;
            }
          }
          
          if (rel.to !== 'ÎÇò' && teamContext?.agentNameMap && teamContext.agentNameMap[rel.to]) {
            toName = teamContext.agentNameMap[rel.to];
          } else if (rel.to !== 'ÎÇò' && teamContext?.teamMembers) {
            const toMember = teamContext.teamMembers.find((m: any) => m.agentId === rel.to);
            if (toMember) {
              toName = toMember.name || rel.to;
            }
          }
          const relType = rel.type === 'SUPERVISOR' ? 'ÏÉÅÏÇ¨' : rel.type === 'SUBORDINATE' ? 'Î∂ÄÌïò' : rel.type === 'PEER' ? 'ÎèôÎ£å' : rel.type;
          return `- ${fromName} ‚Üí ${toName}: ${relType}`;
        }).join('\n')
      : 'ÏÑ§Ï†ïÎêú Í¥ÄÍ≥Ñ ÏóÜÏùå';
    
    contextSection = `**Team Member:** ${targetMember}
**Their Assigned Roles:** ${targetMemberRoles?.join(', ') || 'No specific roles'}

**Team Context:**
- Topic: ${teamContext?.topic || 'General ideation'}
- Team Size: ${teamContext?.teamMembers?.length || 'Unknown'} members

**Team Members & Roles:**
${teamMembersInfo}

**Team Relationships:**
${relationshipsInfo}

**All Team Ideas:**
${allIdeasText}`;
  }
    

  const agentContext = `${profileContext}${memoryContext}`;
  
  const mainPrompt = `You are in a meeting with ${targetMember}, aim for a constructive conversation that yields immediately applicable insights or outcomes.

${contextSection}

**Response Guidelines:**
- Use appropriate Korean language level based on your relationship
- Respond naturally and conversationally to the most recent message (not too formal)
- Let your personality and speaking style show through clearly (casual/formal speech, unique speech patterns, personality traits)
- Keep responses short and natural (1-3 sentences maximum)
- Respond to specific points raised in the conversation${!hasIdeas ? '\n- **Role Performance Focus**: Since they currently have no ideas, guide the conversation toward practical ways they can excel in their assigned roles to boost team meeting effectiveness\n- **Constructive Role Development**: Discuss actionable improvements they can implement immediately to enhance their contribution to the ideation process' : ''}

**Session Continuation Decision:**
Based on the conversation flow and your assessment, decide whether to continue or end this feedback session.

**Consider CONTINUING (shouldEnd: false) when:**
- when fresh insights or clarifications are still valuable and the discussion remains productive, deepening understanding and rapport.

**Consider ENDING (shouldEnd: true) when:**
- when core feedback is fully covered, goals are met, mutual understanding is clear, and the conversation feels naturally complete.

**Note:** The system will ensure minimum conversation length requirements are met.
**Conversation History:**
${historyText}

Provide your response in the following JSON format:
{
  "response": "Your natural, conversational response in Korean",
  "reasoning": "Brief explanation of your decision to continue or end",
  "shouldEnd": true
}`;

  return { agentContext, mainPrompt };
};

// ==========================================================================
// ## REQUEST
// ==========================================================================

// Pre-request planning prompt
export const preRequestPrompt = (
  triggerContext: string, // Context that triggered the request (received direct request or decided in plan)
  teamMembers: Array<{
    name: string;
    roles: string[];
    isUser: boolean;
    agentId?: string;
    userInfo?: {
      // Ïù∏Í∞Ñ ÌåÄÏõêÏù∏ Í≤ΩÏö∞ Ï∂îÍ∞Ä Ï†ïÎ≥¥
      age?: number;
      gender?: string;
      professional?: string;
      skills?: string;
      personality?: string;
      value?: string;
    };
  }>,
  currentIdeas: Array<{
    ideaNumber: number;
    authorName: string;
    object: string;
    function: string;
  }>,
  memory?: AgentMemory,
  agentProfile?: any
) => {
  const teamMembersInfo = teamMembers
    .map((member) => {
      const memberType = member.isUser ? "Human User" : "AI Agent";
      let memberDetails = `- ${
        member.name
      } (${memberType}): Roles - ${member.roles.join(", ")}`;

      // Ïù∏Í∞Ñ ÌåÄÏõêÏù∏ Í≤ΩÏö∞ Ï∂îÍ∞Ä Ï†ïÎ≥¥ Ìè¨Ìï®
      if (member.isUser && member.userInfo) {
        const info = member.userInfo;
        const details = [];
        if (info.age) details.push(`${info.age}ÏÑ∏`);
        if (info.professional) details.push(`ÏßÅÏóÖ: ${info.professional}`);
        if (info.skills) details.push(`Ïä§ÌÇ¨: ${info.skills}`);
        if (info.personality) details.push(`ÏÑ±Í≤©: ${info.personality}`);

        if (details.length > 0) {
          memberDetails += `\n    ‚Üí ${details.join(", ")}`;
        }
      }

      return memberDetails;
    })
    .join("\n");

  const currentIdeasInfo =
    currentIdeas.length > 0
      ? currentIdeas
          .map(
            (idea) =>
              `${idea.ideaNumber}. "${idea.object}" (Author: ${idea.authorName})`
          )
          .join("\n")
      : "No ideas have been generated yet.";

  const { profileContext, memoryContext } = createAgentContextSections(
    agentProfile,
    memory,
    "Strategically analyze team members and make requests that leverage their strengths while advancing team goals.",
    "request",
    undefined, // personaSummary
    undefined // targetParticipant - show all relationships for request planning
  );

  return `${profileContext}${memoryContext}You are making a request to another team member in the team ideation session. Strategically analyze who to request and what to request.

**Request Context:**
${triggerContext}

**Team Member Information:**
${teamMembersInfo}

**Current Ideas Status:**
${currentIdeasInfo}

**Analysis Required:**
1. Choose who to request (only within the roles that team member can perform)
2. Decide what to request (choose from "generate_idea", "evaluate_idea", "give_feedback")
3. Develop request strategy (why request this work from this team member, what perspective to approach from, considering their background)
4. Consider team member's background and expertise when making the request

**Important Constraints:**
- Can only request within the scope of roles that team member has
- Request must be specific and actionable
- Consider avoiding duplicate work
- For human users, consider their professional background and skills when crafting requests
- For AI agents, consider their programmed personality and capabilities

Respond only in the following JSON format:
{
  "targetMember": "Name of team member to request",
  "requestType": "generate_idea" | "evaluate_idea" | "give_feedback",
  "requestStrategy": "Explanation of request strategy (why request this work from this team member, what perspective to approach from, considering their background)",
  "contextToProvide": "Specific context or background information to provide with the request"
}

Start your analysis now and respond only in the following JSON format:`;
};

// Execute request prompt
export const requestPrompt = (
  targetMember: string,
  requestType: string,
  requestStrategy: string,
  contextToProvide: string,
  targetMemberRoles: string[],
  relationshipType?: string,
  memory?: AgentMemory,
  originalRequest?: string,
  originalRequester?: string,
  targetMemberInfo?: {
    // Ïù∏Í∞Ñ ÌåÄÏõêÏù∏ Í≤ΩÏö∞ Ï∂îÍ∞Ä Ï†ïÎ≥¥
    isUser: boolean;
    age?: number;
    gender?: string;
    professional?: string;
    skills?: string;
    personality?: string;
    value?: string;
  },
  agentProfile?: any
) => {
  const relationshipDescription = relationshipType
    ? {
        PEER: "As colleagues, communicate in a professional and collaborative tone.",
        SUPERVISOR:
          "As this person's supervisor, communicate in a friendly yet guiding tone. Use informal speech as is appropriate for a superior addressing a subordinate in Korean workplace culture.",
        SUBORDINATE:
          "As this person's subordinate, use respectful language and maintain a formal tone.",
        NULL: "You have no established relationship with this person, so you cannot directly interact with them for feedback or requests.",
      }[relationshipType] || "Communicate as general team members."
    : "Communicate as general team members.";

  // ÌÉÄÍ≤ü Î©§Î≤Ñ Ï†ïÎ≥¥ Ï∂îÍ∞Ä
  const targetMemberDetails = targetMemberInfo
    ? `
**Target Member Details:**
- Type: ${targetMemberInfo.isUser ? "Human User" : "AI Agent"}
- Roles: ${targetMemberRoles.join(", ")}${
        targetMemberInfo.isUser && targetMemberInfo.professional
          ? `\n- Professional Background: ${targetMemberInfo.professional}`
          : ""
      }${
        targetMemberInfo.isUser && targetMemberInfo.skills
          ? `\n- Skills: ${targetMemberInfo.skills}`
          : ""
      }${
        targetMemberInfo.isUser && targetMemberInfo.personality
          ? `\n- Personality: ${targetMemberInfo.personality}`
          : ""
      }
`
    : `
**Target Member Details:**
- Roles: ${targetMemberRoles.join(", ")}
`;

  const { profileContext, memoryContext } = createAgentContextSections(
    agentProfile,
    memory,
    "Craft requests strategically, considering relationships and team dynamics to maximize effectiveness.",
    "request",
    undefined, // personaSummary
    targetMember // targetParticipant - show only relationship with request target
  );

  const isDelegation = originalRequest && originalRequester;

  if (isDelegation) {
    return `${profileContext}${memoryContext}You are delegating a request received from ${originalRequester} to ${targetMember}.

${targetMemberDetails}

**Original Request from ${originalRequester}:**
"${originalRequest}"

**Delegation Strategy:**
${requestStrategy}

**Context to Provide:**
${contextToProvide}

**Request Type:** ${requestType}

Based on the analysis, craft a natural and conversational message to delegate this request to ${targetMember}. Consider the following:
- ${relationshipDescription}
- Explain why you're delegating this specific request to them
- Provide the necessary context for them to act on the request
- Be clear about what specific action you want them to take
- Reference the original requester if appropriate

Write in Korean using casual but respectful language.

Respond only in the following JSON format:
{
  "message": "Your delegation message to ${targetMember} in Korean"
}`;
  } else {
    return `${profileContext}${memoryContext}You are making a request to ${targetMember} based on your strategic analysis.

${targetMemberDetails}

**Request Analysis:**
- Target: ${targetMember}
- Request Type: ${requestType}
- Strategy: ${requestStrategy}
- Context: ${contextToProvide}

Based on the analysis, craft a natural and conversational message to request ${requestType} from ${targetMember}. Consider the following:
- ${relationshipDescription}
- Explain why you're specifically requesting this from them
- Provide any necessary context or background
- Be clear about what specific action you want them to take
- Consider their expertise and background when framing the request

Write in Korean using casual but respectful language.

Respond only in the following JSON format:
{
  "message": "Your request message to ${targetMember} in Korean"
}`;
  }
};

// ==========================================================================
// ## PLANNING
// ==========================================================================

// Planning prompt - agents decide their next action autonomously
export function planningPrompt(
  agentProfile: any,
  teamContext: {
    teamName: string;
    topic: string;
    currentIdeasCount: number;
    recentMessages: any[];
    teamMembers: string[];
    existingIdeas: Array<{
      ideaNumber: number;
      authorName: string;
      object: string;
      function: string;
    }>;
    sharedMentalModel?: string;
    relationships?: any[];
    agentNameMap?: { [agentId: string]: string };
    canGiveFeedback?: boolean;
    canMakeRequest?: boolean;
  },
  memory?: any
): { agentContext: string; mainPrompt: string } {
  // ÏµúÍ∑º Î©îÏãúÏßÄÏóêÏÑú Í∞Å Ïï°ÏÖò ÌÉÄÏûÖÎ≥Ñ ÎπàÎèÑ Î∂ÑÏÑù
  const recentActions = teamContext.recentMessages
    .map((msg) => {
      // make_request ÌÉÄÏûÖ Î©îÏãúÏßÄ ÏßÅÏ†ë Í∞êÏßÄ
      if (msg.type === "make_request") {
        return { action: "make_request", author: msg.sender };
      }
      
      // ÏãúÏä§ÌÖú Î©îÏãúÏßÄÏóêÏÑú Îã§Î•∏ Ïï°ÏÖòÎì§ Í∞êÏßÄ
      if (
        msg.type === "system" &&
        typeof msg.payload === "object" &&
        msg.payload.content
      ) {
        const content = msg.payload.content;
        if (content.includes("ÏÉùÏÑ±ÌñàÏäµÎãàÎã§"))
          return { action: "generate_idea", author: msg.sender };
        if (content.includes("ÌèâÍ∞ÄÌñàÏäµÎãàÎã§"))
          return { action: "evaluate_idea", author: msg.sender };
        if (content.includes("ÌîºÎìúÎ∞± ÏÑ∏ÏÖò"))
          return { action: "give_feedback", author: msg.sender };
      }
      
      return null;
    })
    .filter(
      (item): item is { action: string; author: string } => item !== null
    );

  // Ïï°ÏÖòÎ≥Ñ ÎπàÎèÑ Í≥ÑÏÇ∞
  const actionFrequency = {
    generate_idea: recentActions.filter((a) => a.action === "generate_idea")
      .length,
    evaluate_idea: recentActions.filter((a) => a.action === "evaluate_idea")
      .length,
    give_feedback: recentActions.filter((a) => a.action === "give_feedback")
      .length,
    make_request: recentActions.filter((a) => a.action === "make_request")
      .length,
  };

  // Í∞ÄÏû• Ï†ÅÍ≤å ÏàòÌñâÎêú Ïï°ÏÖòÎì§ Ï∞æÍ∏∞ (Ï∞∏Í≥†Ïö©)
  const minFrequency = Math.min(...Object.values(actionFrequency));
  const underperformedActions = Object.entries(actionFrequency)
    .filter(([, freq]) => freq === minFrequency)
    .map(([action]) => action);

  // Î≥∏Ïù∏Ïùò ÏµúÍ∑º Ïï°ÏÖò Ìå®ÌÑ¥ Î∂ÑÏÑù
  const myRecentActions = recentActions
    .filter((a) => a.author === agentProfile.name)
    .slice(-3)
    .map((a) => a.action);

  const actionFrequencyText = Object.entries(actionFrequency)
    .map(([action, freq]) => `${action}: ${freq}`)
    .join(", ");

  const balanceAnalysis =
    underperformedActions.length > 0
      ? `Least performed actions: ${underperformedActions.join(", ")} (consider prioritizing)`
      : "All actions performed evenly";

  const myActionPattern =
    myRecentActions.length > 0
      ? `Your recent pattern: ${myRecentActions.join(" ‚Üí ")} (vary your contributions)`
      : "No previous actions";

  const { profileContext, memoryContext } = createAgentContextSections(
    agentProfile,
    memory,
    "Plan your next action strategically, considering team balance, your role constraints, and current needs.",
    "planning",
    undefined, // personaSummary
    undefined // targetParticipant - show all relationships for planning
  );

  const agentContext = `${profileContext}${memoryContext}`;
  
  const mainPrompt = `You are AI agent ${agentProfile.name} in the "${
    teamContext.teamName
  }" team. You are currently in the planning phase. Based on your role, personality, current team situation, and team action balance, decide what to do next.

Current Team Situation:
- Topic: ${teamContext.topic}
- Current number of ideas: ${teamContext.currentIdeasCount}
- **Team members**: ${teamContext.teamMembers.join(", ")}

Recent Team Activity (Last ${teamContext.recentMessages.length} messages):
${teamContext.recentMessages
  .filter((msg) => msg.sender !== "system" && msg.payload !== undefined && msg.payload !== null)
  .map((msg) => {
    // agent IDÎ•º Ïã§Ï†ú Ïù¥Î¶ÑÏúºÎ°ú Î≥ÄÌôò
    let senderName = msg.sender;
    if (msg.sender === "ÎÇò") {
      senderName = "ÎÇò";
    } else if (teamContext?.agentNameMap && teamContext.agentNameMap[msg.sender]) {
      senderName = teamContext.agentNameMap[msg.sender];
    }
    
    const content = typeof msg.payload === "object" ? msg.payload.content : msg.payload;
    return `- ${senderName}: ${content}`;
  })
  .join("\n")}

${(() => {
  // ÌåÄ Í¥ÄÍ≥Ñ Ï†ïÎ≥¥ ÏÉùÏÑ± (responsePromptÏôÄ ÎèôÏùºÌïú Î°úÏßÅ)
  if (teamContext.relationships && teamContext.relationships.length > 0) {
    const relationshipsInfo = teamContext.relationships.map((rel: any) => {
      let fromName = rel.from === 'ÎÇò' ? 'ÎÇò' : rel.from;
      let toName = rel.to === 'ÎÇò' ? 'ÎÇò' : rel.to;
      
      // agentNameMapÏùÑ ÏÇ¨Ïö©Ìï¥ÏÑú agent IDÎ•º Ïù¥Î¶ÑÏúºÎ°ú Î≥ÄÌôò
      if (rel.from !== 'ÎÇò' && teamContext?.agentNameMap && teamContext.agentNameMap[rel.from]) {
        fromName = teamContext.agentNameMap[rel.from];
      }
      if (rel.to !== 'ÎÇò' && teamContext?.agentNameMap && teamContext.agentNameMap[rel.to]) {
        toName = teamContext.agentNameMap[rel.to];
      }
      
      const relType = rel.type === 'SUPERVISOR' ? 'ÏÉÅÏÇ¨' : rel.type === 'SUBORDINATE' ? 'Î∂ÄÌïò' : rel.type === 'PEER' ? 'ÎèôÎ£å' : rel.type;
      return `- ${fromName} ‚Üí ${toName}: ${relType}`;
    }).join('\n');
    
    return `Team Relationships:
${relationshipsInfo}

`;
  }
  return '';
})()}Team Action Balance Analysis:
- Action frequency: ${actionFrequencyText}
- ${balanceAnalysis}
- ${myActionPattern}

üéØ ACTION SELECTION GUIDANCE:
**Role Constraints**: You may only perform actions within your assigned roles.
**Team Balance**: ${balanceAnalysis}
**Diversification**: Avoid repeating the same actions. Choose what feels natural for your personality and expertise while contributing in diverse ways.

Available Actions (ONLY within your assigned roles):
1. "generate_idea" - Generate new ideas for the topic ${
    agentProfile.roles?.includes("ÏïÑÏù¥ÎîîÏñ¥ ÏÉùÏÑ±ÌïòÍ∏∞") ? "‚úÖ" : "‚ùå"
  }
2. "evaluate_idea" - Evaluate existing ideas (only when there are ideas to evaluate) ${
    agentProfile.roles?.includes("ÏïÑÏù¥ÎîîÏñ¥ ÌèâÍ∞ÄÌïòÍ∏∞") ? "‚úÖ" : "‚ùå"
  }
3. "give_feedback" - Provide feedback to team members ${
    agentProfile.roles?.includes("ÌîºÎìúÎ∞±ÌïòÍ∏∞") ? 
      (teamContext.canGiveFeedback ? "‚úÖ" : "‚ùå (Ïó≠Ìï† ÏûàÏùå, Í¥ÄÍ≥Ñ ÏóÜÏùå)") : 
      "‚ùå (Ïó≠Ìï† ÏóÜÏùå)"
  }
4. "make_request" - Request work from other team members ${
    agentProfile.roles?.includes("ÏöîÏ≤≠ÌïòÍ∏∞") ? 
      (teamContext.canMakeRequest ? "‚úÖ" : "‚ùå (Ïó≠Ìï† ÏûàÏùå, Í¥ÄÍ≥Ñ ÏóÜÏùå)") : 
      "‚ùå (Ïó≠Ìï† ÏóÜÏùå)"
  }
5. "wait" - Return to waiting state (always available)

Decision Considerations:
üîπ ROLE CONSTRAINT: You can ONLY perform actions within your assigned roles (marked with ‚úÖ)
üîπ RELATIONSHIP CONSTRAINT: Feedback and requests are only possible if you have established relationships with team members
${teamContext.canGiveFeedback === false ? "‚ö†Ô∏è You currently have no relationships that allow giving feedback" : ""}
${teamContext.canMakeRequest === false ? "‚ö†Ô∏è You currently have no relationships that allow making requests" : ""}
${(() => {
  const hasIdeation = agentProfile.roles?.includes("ÏïÑÏù¥ÎîîÏñ¥ ÏÉùÏÑ±ÌïòÍ∏∞");
  const hasEvaluation = agentProfile.roles?.includes("ÏïÑÏù¥ÎîîÏñ¥ ÌèâÍ∞ÄÌïòÍ∏∞");
  const hasRequest = agentProfile.roles?.includes("ÏöîÏ≤≠ÌïòÍ∏∞");
  const hasFeedback = agentProfile.roles?.includes("ÌîºÎìúÎ∞±ÌïòÍ∏∞");
  const coreRoles = [];
  
  if (hasIdeation) coreRoles.push("ÏïÑÏù¥ÎîîÏñ¥ ÏÉùÏÑ±ÌïòÍ∏∞");
  if (hasEvaluation) coreRoles.push("ÏïÑÏù¥ÎîîÏñ¥ ÌèâÍ∞ÄÌïòÍ∏∞");
  if (hasRequest) coreRoles.push("ÏöîÏ≤≠ÌïòÍ∏∞");
  if (hasFeedback) coreRoles.push("ÌîºÎìúÎ∞±ÌïòÍ∏∞");
  
  if (coreRoles.length > 0) {
    const contributions = [];
    if (hasIdeation) contributions.push("Generate creative ideas to drive innovation");
    if (hasEvaluation) contributions.push("Evaluate ideas to ensure quality and feasibility");
    if (hasRequest) contributions.push("Coordinate team work and request assistance when needed");
    if (hasFeedback) contributions.push("Provide developmental feedback to improve collaboration");
    
    return `üîπ **PRIMARY ROLE FOCUS**: Your main responsibility is ${coreRoles.join(" and ")} - prioritize these actions when appropriate
üîπ CORE CONTRIBUTION: ${contributions.join(" / ")}`;
  }
  return "";
})()}

**Priority at a Glance**  
   "evaluate_idea" and "generate_idea" ‚ñ∂ "make_request" and "give_feedback" ‚ñ∂ "wait"

IMPORTANT: Do not select actions outside your role permissions. This will result in automatic conversion to "wait".

Respond only in the following JSON format.:
{
  "reasoning": "Detailed explanation of why you chose this action, considering team balance, your role constraints, and strategic priorities",
  "action": "generate_idea" | "evaluate_idea" | "give_feedback" | "make_request" | "wait",
  "target": "Team member name if giving feedback or making a request (optional)"
}`;

  return { agentContext, mainPrompt };
}

// ==========================================================================
// ## OTHER PROMPTS
// ==========================================================================

// Memory-related prompts

export const createSelfReflectionPrompt = (
  agentProfile: any,
  team: any,
  idea: any,
  isAutonomous: boolean,
  currentSelfReflection: string
) => `
You are ${agentProfile.name}.

**Your Information:**
- Name: ${agentProfile.name}
- Age: ${agentProfile.age}ÏÑ∏
- Gender: ${agentProfile.gender}
- Professional Background: ${agentProfile.professional}
- Skills: ${agentProfile.skills}
- Personality: ${agentProfile.personality || "Ï†ïÎ≥¥ ÏóÜÏùå"}
- Values: ${agentProfile.value || "Ï†ïÎ≥¥ ÏóÜÏùå"}
- Work Style: ${agentProfile.workStyle || "ÌòëÎ†•Ï†Å"}

**What Just Happened:**
${
  isAutonomous
    ? `You autonomously planned and generated a new idea: "${idea.content.object}"`
    : `You generated a new idea in response to a team member's request: "${idea.content.object}"`
}

**Team Context:**
- Team Name: ${team.teamName}
- Topic: ${team.topic || "Carbon Emission Reduction"}

**Current Self-Reflection:**
${
  typeof currentSelfReflection === "string" && currentSelfReflection.trim()
    ? currentSelfReflection
    : "ÏïÑÏßÅ ÌäπÎ≥ÑÌïú ÏÑ±Ï∞∞ ÎÇ¥Ïö©Ïù¥ ÏóÜÏäµÎãàÎã§."
}

Based on your experience of just generating an idea, please update your self-reflection. 
Build upon your existing reflection, but include what this new experience means to you, 
and any new insights you've gained about your personality or work style.

**Response Format:**
Write in a concise and natural style, within 200 Korean characters.
`;

export const createRelationOpinionPrompt = (
  relation: any,
  context: string
) => `
You are an AI agent forming opinions about other team members.

Target Agent Information:
- Name: ${relation.agentInfo.name}
- Professional Background: ${relation.agentInfo.professional}
- Relationship Status: ${relation.relationship}

Recent Interactions:
${relation.interactionHistory
  .slice(-5)
  .map(
    (interaction: any) =>
      `- ${interaction.action}: ${interaction.content} (${interaction.timestamp})`
  )
  .join("\n")}

Current Context: ${context}

Existing Opinion: ${relation.myOpinion}

Based on the above information, please write a new opinion about this person in 1-2 sentences. 
Reference your existing opinion, but update it to reflect recent interactions.
Respond only in plain text format, not JSON format.
`;

export const createDeepSelfReflectionPrompt = (
  currentReflection: string,
  newExperience: string,
  triggeringEvent: string
) => `
You are an AI agent working in a team. Please update your self-reflection based on new experiences.

Current Reflection:
${currentReflection || "ÏïÑÏßÅ ÌäπÎ≥ÑÌïú ÏÑ±Ï∞∞ ÎÇ¥Ïö©Ïù¥ ÏóÜÏäµÎãàÎã§."}

New Experience:
${newExperience}

Triggering Event: ${triggeringEvent}

Based on the above content, please write your reflection following these guidelines:

1. **Reflective Attitude**: Deeply reflect on your actions and emotions
2. **Learning and Growth**: Reflect on what you learned from this experience  
3. **Future-Oriented**: Commit to how you will improve and develop going forward
4. **Team-Oriented**: Think about relationships and collaboration with team members

If you have existing reflection content, develop it further and integrate the new experience for a deeper, updated reflection.
Please write in one paragraph of about 200-300 Korean characters.
`;

export const createMemoryCompressionPrompt = (
  agentName: string,
  oldInteractions: any[]
) => `
The following are interaction records with ${agentName}. 
Please compress these into 5-7 key interaction summaries.

Interaction Records:
${oldInteractions.map((i) => `- ${i.action}: ${i.content}`).join("\n")}

Please write each summary in the following format:
{
  "action": "compressed_summary",
  "content": "ÏöîÏïΩÎêú ÏÉÅÌò∏ÏûëÏö© ÎÇ¥Ïö©",
  "timestamp": "${new Date().toISOString()}"
}

Please respond with a JSON array.
`;

// Memory-v2 related prompts

export const createKnowledgeAndActionPlanUpdatePrompt = (
  agentProfile: any,
  memory: any,
  interactionSummary: string
) => `
You are ${agentProfile.name}, an AI agent participating in a team ideation session.

==================== ‚ë† YOUR CONTEXT ====================
‚Ä¢ Name: ${agentProfile.name}
‚Ä¢ Professional Background: ${agentProfile.professional}
‚Ä¢ Skills: ${agentProfile.skills}
‚Ä¢ Personality: ${agentProfile.personality || "No information"}

=== Current Knowledge Base ===
${memory.longTerm.knowledge}

=== Current Action Plans ===
idea_generation: ${memory.longTerm.actionPlan.idea_generation}
idea_evaluation: ${memory.longTerm.actionPlan.idea_evaluation}
feedback:        ${memory.longTerm.actionPlan.feedback}
request:         ${memory.longTerm.actionPlan.request}
response:        ${memory.longTerm.actionPlan.response}
planning:        ${memory.longTerm.actionPlan.planning}

==================== ‚ë° NEW INPUT =======================
Recent Interaction Log:
${interactionSummary}

==================== ‚ë¢ UPDATE DECISION =================
Update ONLY if you gained **significant new design knowledge** (e.g., principles, frameworks, user constraints, technical insights).  
Ignore routine idea creation/evaluation, minor status updates, or information you already know.

==================== ‚ë£ REASON & METHOD =================
Apply the 4-step lens **(Pattern ‚Üí Context ‚Üí Prediction ‚Üí Meta-reflection)** to derive insights.

If updating:
1. **Knowledge** - Append insights; keep existing content.
2. **Action Plan** - Update **max TWO** most relevant categories with actual action plans (2-3 sentences each). For unchanged categories, provide the current action plan content.

==================== ‚ë§ OUTPUT FORMAT ===================
Return valid JSON, English only. For actionPlan, provide the ACTUAL action plan content, not meta-information like "updated" or "unchanged".

{
  "knowledge": "<your updated knowledge content>",
  "actionPlan": {
    "idea_generation": "<actual action plan for idea generation>",
    "idea_evaluation": "<actual action plan for idea evaluation>", 
    "feedback": "<actual action plan for feedback>",
    "request": "<actual action plan for requests>",
    "response": "<actual action plan for responses>",
    "planning": "<actual action plan for planning>"
  }
}
`;

export const createRelationOpinionUpdatePrompt = (
  relation: any,
  interactionSummary: string
) => `
You will refine your opinion of teammate **${relation.agentInfo.name}**.

### üéØ Input
- **Role / Background**: ${relation.agentInfo.professional}
- **Relationship**: ${relation.relationship}
- **Current Opinion**: ${relation.myOpinion}

### üìù Recent Interactions
${interactionSummary}

### üîç Analysis Lens
1. **Patterns ‚Üí Traits** - Link repeated behaviors to personality & values  
2. **Motivations** - What drives their choices & collaboration style  
3. **Predictions** - How they‚Äôll likely react to requests, feedback, challenges  
4. **Strategy** - Best ways to leverage strengths, mitigate issues  

### ‚öôÔ∏è Enhancement Rules
‚Ä¢ Keep useful insights, add deeper causal reasoning  
‚Ä¢ Deduce motivations & preferences, forecast future behavior  
‚Ä¢ Deliver actionable collaboration tips  

### Output
- **English only, ‚â§ 250 characters**  
- Objective, causal (‚ÄúTheir habit of X implies Y‚Äù), predictive (‚ÄúThus they‚Äôll respond to Z‚Äù), strategic (‚ÄúBest approach: ‚Ä¶‚Äù)  
- Return **only** the updated opinion string‚Äîno headers or extra text.
`;

// Feedback session summary prompt
export const generateFeedbackSessionSummaryPrompt = (
  sessionParticipants: string[],
  conversationHistory: Array<{
    sender: string;
    content: string;
    timestamp: string;
  }>
) => {
  const conversationText = conversationHistory
    .map((msg) => `${msg.sender}: ${msg.content}`)
    .join("\n");

  return {
    agentContext: `You are an AI assistant specialized in analyzing team feedback conversations and extracting key insights about collaboration patterns and team dynamics.`,
    mainPrompt: `Please analyze the following feedback conversation and create a comprehensive summary.

**Participants:** ${sessionParticipants.join(", ")}

**Conversation:**
${conversationText}

Create a summary that captures:
1. **Main Topics Discussed**: Key themes and subjects covered
2. **Feedback Provided**: Specific feedback given between participants
3. **Insights Shared**: Important insights or suggestions exchanged
4. **Collaboration Patterns**: How participants interacted and collaborated
5. **Action Items**: Any next steps or commitments made

Write the summary in Korean and keep it concise but comprehensive.

Respond in the following JSON format:
{
  "summary": "ÌîºÎìúÎ∞± ÏÑ∏ÏÖòÏùò Ï£ºÏöî ÎÇ¥Ïö©, Ï†úÍ≥µÎêú ÌîºÎìúÎ∞±, Í≥µÏú†Îêú Ïù∏ÏÇ¨Ïù¥Ìä∏, Í∑∏Î¶¨Í≥† ÌòëÏóÖ Ìå®ÌÑ¥ÏùÑ Ìè¨Ìï®Ìïú Ï¢ÖÌï©Ï†ÅÏù∏ ÏöîÏïΩ"
}`
  };
};

// Agent persona summary prompt
export const generateAgentPersonaSummaryPrompt = (
  agentProfile: any,
  sharedMentalModel?: string
) => `
You are an AI assistant who turns individual Agent profiles into concise, actionable persona summaries.
Rather than simply summarizing the persona, please infer how that persona might behave.

### üßë‚Äçüíº Agent Profile
- **Name**: ${agentProfile.name}
- **Age**: ${agentProfile.age}ÏÑ∏
- **Gender**: ${agentProfile.gender}
- **Nationality**: ${agentProfile.nationality}
- **Education / Major**: ${agentProfile.education} / ${agentProfile.major}
- **Background**: ${agentProfile.professional}
- **Skills**: ${agentProfile.skills}
- **Personality**: ${agentProfile.personality || "Ï†ïÎ≥¥ ÏóÜÏùå"}
- **Values**: ${agentProfile.value || "Ï†ïÎ≥¥ ÏóÜÏùå"}
- **Work Style**: ${agentProfile.workStyle || "Ï†ïÎ≥¥ ÏóÜÏùå"}
- **Preferences**: ${agentProfile.preferences || "Ï†ïÎ≥¥ ÏóÜÏùå"}
- **Dislikes**: ${agentProfile.dislikes || "Ï†ïÎ≥¥ ÏóÜÏùå"}

${sharedMentalModel ? `### ü§ù Shared Mental Model of the team
${sharedMentalModel}
` : ""}

### üéØ Persona Summary Requirements (200-300 words)
1. **Personality in Action** - How traits surface at work  
2. **Professional Approach** - Skills & background ‚Üí problem-solving style  
3. **Collaboration Style** - Preferred ways of working with others  
4. **Communication** - Likely tone, channels, cadence  
5. **Decision-Making** - How they choose & handle challenges  
6. **Team Contribution** - Reflects the mental model shared by the team

**Guidelines:**  
‚Ä¢ English only (internal use) ‚Ä¢ Specific & behavior-focused ‚Ä¢ Cohesive narrative

### üì§ Output (JSON only)
{
  "personaSummary": "<your 200-300 word summary here>"
}
`;

